| id  | afirma√ß√£o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | resposta | explica√ß√£o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | Julgue o item a seguir, a respeito do modelo relacional: A ordem das colunas e das linhas em uma tabela √© fundamental para a correta interpreta√ß√£o dos dados, e cada tabela deve possuir um nome √∫nico e atributos com nomes distintos.                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ No modelo relacional, o nome da tabela e os nomes dos atributos dentro dela devem ser √∫nicos, sim. Contudo, a ordem das linhas (tuplas) e das colunas (atributos) √© **irrelevante** para a l√≥gica do modelo. O sistema pode armazen√°-las e apresent√°-las em qualquer ordem. üí° **Dica:** A banca CESPE adora misturar afirma√ß√µes verdadeiras com uma falsa para invalidar o item. Aten√ß√£o aos detalhes! (Cap√≠tulo 1, p. 32)                                                                                                                                                                                                                                                                                            |
| 2   | A linguagem SQL (Structured Query Language) √© considerada uma linguagem procedural, pois exige que o usu√°rio especifique detalhadamente os passos para a recupera√ß√£o dos dados desejados.                                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ SQL √© uma linguagem **descritiva** (ou declarativa). O usu√°rio especifica O QU√ä deseja (o resultado), e n√£o COMO o sistema deve obt√™-lo (os passos). O SGBD se encarrega da otimiza√ß√£o e da execu√ß√£o. üí° **Dica:** Diferenciar linguagens declarativas de procedurais √© crucial. Pense em SQL como "me diga o que voc√™ quer", n√£o "me diga como fazer". (Cap√≠tulo 1, p. 34)                                                                                                                                                                                                                                                                                                                                            |
| 3   | Em um grafo de propriedades, modelo fundamental para bancos de dados orientados a grafos, apenas os n√≥s podem possuir propriedades, enquanto as arestas servem unicamente para conectar os n√≥s, sem carregar atributos pr√≥prios.                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Em um grafo de propriedades (Property Graph), tanto os **n√≥s** (v√©rtices) quanto as **arestas** (relacionamentos) podem ter propriedades (pares atributo-valor). üí° **Dica:** "Apenas" e "unicamente" s√£o palavras restritivas que frequentemente tornam uma afirma√ß√£o falsa em provas. (Cap√≠tulo 1, p. 42)                                                                                                                                                                                                                                                                                                                                                                                                            |
| 4   | Uma tabela est√° na Primeira Forma Normal (1FN) se, e somente se, todos os seus atributos n√£o chave forem totalmente dependentes da chave prim√°ria, permitindo-se grupos repetitivos para otimiza√ß√£o de armazenamento.                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ A Primeira Forma Normal (1FN) exige que todos os valores dos atributos sejam **at√¥micos**, ou seja, indivis√≠veis, e que n√£o haja grupos repetitivos dentro de uma tupla. A depend√™ncia funcional total da chave prim√°ria por atributos n√£o chave √© caracter√≠stica da Segunda Forma Normal (2FN). üí° **Dica:** Memorize a defini√ß√£o principal de cada FN. 1FN = atomicidade. (Cap√≠tulo 2, p. 81)                                                                                                                                                                                                                                                                                                                        |
| 5   | O princ√≠pio ACID, fundamental em transa√ß√µes de banco de dados, garante que as transa√ß√µes sejam At√¥micas, Concorrentes, Isoladas e Distribu√≠das, assegurando a integridade mesmo em falhas parciais do sistema.                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ ACID √© um acr√¥nimo para: **A**tomicidade, **C**onsist√™ncia, **I**solamento e **D**urabilidade. "Concorrentes" e "Distribu√≠das" n√£o fazem parte do acr√¥nimo ACID, embora SGBDs lidem com concorr√™ncia e possam ser distribu√≠dos. üí° **Dica:** Mnem√¥nicos s√£o seus amigos! ACID √© um cl√°ssico. (Cap√≠tulo 4, p. 218)                                                                                                                                                                                                                                                                                                                                                                                                      |
| 6   | No contexto do Teorema CAP, um sistema de gerenciamento de dados distribu√≠do pode, no m√°ximo, garantir simultaneamente duas das tr√™s seguintes propriedades: Consist√™ncia (C), Acessibilidade (A) e Toler√¢ncia a Parti√ß√µes (P).                                                                                                                                                                                                                                                                                                      | V        | üë®‚Äçüè´ Exatamente! O Teorema CAP (Consistency, Availability, Partition tolerance), de Eric Brewer, postula que em um sistema distribu√≠do √© imposs√≠vel garantir simultaneamente as tr√™s propriedades. Deve-se escolher duas, ou priorizar duas em detrimento parcial da terceira. üí° **Dica:** CAP √© fundamental para entender tradeoffs em sistemas distribu√≠dos, especialmente NoSQL. (Cap√≠tulo 4, p. 233)                                                                                                                                                                                                                                                                                                                   |
| 7   | O m√©todo MapReduce, utilizado em processamento paralelo de grandes volumes de dados, consiste em duas fases principais: a fase Map, onde os dados s√£o filtrados e transformados, e a fase Reduce, onde os dados s√£o agregados para produzir um resultado final.                                                                                                                                                                                                                                                                      | V        | üë®‚Äçüè´ Correto. A fase **Map** processa pares chave-valor para gerar um conjunto de pares chave-valor intermedi√°rios. A fase **Reduce** combina todos os valores intermedi√°rios associados com a mesma chave. üí° **Dica:** Map = Mapear/Transformar individualmente. Reduce = Reduzir/Agregar o grupo. (Cap√≠tulo 5, p. 277)                                                                                                                                                                                                                                                                                                                                                                                                   |
| 8   | Considere o seguinte comando SQL: `SELECT E#, Name FROM EMPLOYEE WHERE City = 'Kent' AND Sub = 'D6'`. Este comando selecionar√° o n√∫mero e nome de todos os empregados que residem em Kent OU trabalham no departamento D6.                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ O operador `AND` em SQL requer que **ambas** as condi√ß√µes sejam verdadeiras para que uma linha seja retornada. Portanto, o comando selecionar√° empregados que residem em Kent E trabalham no departamento D6. Para a l√≥gica OU, usar-se-ia o operador `OR`. üí° **Dica:** `AND` √© mais restritivo que `OR`. A banca pode tentar confundir com a interpreta√ß√£o l√≥gica. (Cap√≠tulo 3, p. 177-178; similar √† p. 169)                                                                                                                                                                                                                                                                                                        |
| 9   | Em bancos de dados NoSQL do tipo chave-valor, a integridade referencial √© rigorosamente verificada pelo sistema, garantindo que todas as chaves estrangeiras apontem para registros existentes, de forma similar aos bancos de dados relacionais.                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ Bancos de dados chave-valor geralmente **n√£o** verificam integridade referencial. Eles s√£o schema-less ou t√™m esquemas flex√≠veis, focando em escalabilidade e performance, o que muitas vezes implica abrir m√£o de garantias relacionais como essa. A responsabilidade pela consist√™ncia referencial frequentemente recai sobre a aplica√ß√£o. üí° **Dica:** NoSQL geralmente sacrifica consist√™ncia forte por outros benef√≠cios. (Cap√≠tulo 7, p. 345-346)                                                                                                                                                                                                                                                                |
| 10  | A utiliza√ß√£o de √çndices em bancos de dados relacionais, como √Årvores B, sempre melhora o desempenho de todas as opera√ß√µes de consulta (`SELECT`), inser√ß√£o (`INSERT`), atualiza√ß√£o (`UPDATE`) e dele√ß√£o (`DELETE`).                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ √çndices melhoram significativamente o desempenho de consultas (`SELECT`) que utilizam as colunas indexadas em suas cl√°usulas `WHERE` ou `JOIN`. No entanto, eles podem **degradar** o desempenho de opera√ß√µes de escrita (`INSERT`, `UPDATE`, `DELETE`), pois o √≠ndice tamb√©m precisa ser atualizado. üí° **Dica:** √çndices s√£o uma faca de dois gumes. √ìtimos para leitura, custo adicional para escrita. (Cap√≠tulo 5, p. 252)                                                                                                                                                                                                                                                                                         |
| 11  | O processamento da informa√ß√£o, uma de suas caracter√≠sticas distintivas, implica que ela pode ser apenas armazenada e recuperada, n√£o permitindo transforma√ß√µes ou categoriza√ß√µes.                                                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ Pense na informa√ß√£o como argila. Voc√™ n√£o s√≥ guarda argila (armazena), mas tamb√©m pode mold√°-la (transformar), pint√°-la (categorizar), ou envi√°-la para algu√©m (transmitir). A informa√ß√£o √© super flex√≠vel! üí° **Dica:** A CESPE adora limitar o alcance de conceitos amplos. "Apenas" √© uma palavra-chave para desconfiar. (Cap√≠tulo 1, p. 26)                                                                                                                                                                                                                                                                                                                                                                        |
| 12  | Um sistema de gerenciamento de banco de dados (SGBD) √© composto exclusivamente por um componente de armazenamento, sendo o componente de gerenciamento (com linguagens de consulta) uma funcionalidade opcional.                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Um SGBD √© como um bibliotec√°rio (gerenciamento) com sua biblioteca (armazenamento). Voc√™ precisa dos dois! O bibliotec√°rio te ajuda a achar os livros (consultar), organizar (descrever) e guardar (armazenar). Sem o "c√©rebro" (gerenciamento), seria s√≥ um monte de dados bagun√ßados. üí° **Dica:** "Exclusivamente" e "opcional" s√£o fortes indicadores de erro quando se trata de componentes essenciais. (Cap√≠tulo 1, p. 28)                                                                                                                                                                                                                                                                                       |
| 13  | No modelo relacional, um atributo pode conter m√∫ltiplos valores para uma √∫nica tupla, como uma lista de n√∫meros de telefone para um √∫nico empregado, visando a otimiza√ß√£o do espa√ßo.                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ Imagine uma planilha. Cada c√©lula (atributo de uma linha/tupla) guarda s√≥ UMA informa√ß√£o. Se o Jo√£o tem dois telefones, voc√™ n√£o coloca os dois na mesma c√©lula de "telefone". Isso quebra a regra da atomicidade, fundamental para a 1¬™ Forma Normal. üí° **Dica:** O modelo relacional cl√°ssico preza pela atomicidade dos dados em cada atributo. Listas dentro de um campo s√£o um "n√£o-n√£o". (Cap√≠tulo 1, p. 30, 32)                                                                                                                                                                                                                                                                                                |
| 14  | A propriedade de "Minimality" de uma chave de identifica√ß√£o significa que a chave deve conter o menor n√∫mero de caracteres poss√≠vel para identificar unicamente uma tupla.                                                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ "Minimality" (Minimalidade) de uma chave composta significa que voc√™ n√£o pode remover NENHUM atributo da combina√ß√£o de atributos sem perder a capacidade de identificar unicamente a tupla. N√£o se trata do tamanho (n√∫mero de caracteres) dos valores, mas da quantidade de atributos na chave. üí° **Dica:** Confundir "menor valor" com "menor conjunto de atributos" √© uma pegadinha. (Cap√≠tulo 1, p. 31-32)                                                                                                                                                                                                                                                                                                        |
| 15  | Bancos de dados NoSQL, como os orientados a grafos, utilizam exclusivamente a linguagem SQL para manipula√ß√£o e consulta de dados, mantendo a compatibilidade com sistemas legados.                                                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ "NoSQL" muitas vezes significa "Not Only SQL" (N√£o Apenas SQL), mas fundamentalmente, esses bancos usam modelos de dados e linguagens de consulta DIFERENTES do SQL tradicional. Bancos de grafos, por exemplo, usam linguagens como Cypher ou Gremlin, otimizadas para travessia de relacionamentos. üí° **Dica:** O pr√≥prio nome "NoSQL" sugere uma alternativa ao SQL. (Cap√≠tulo 1, p. 42, 45, 48)                                                                                                                                                                                                                                                                                                                   |
| 16  | O conceito de "Variety" (Variedade) em Big Data refere-se unicamente √† grande quantidade de diferentes fontes de dados, como sensores e redes sociais, n√£o abrangendo os formatos (estruturado, n√£o estruturado).                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ Variedade em Big Data √© um combo! Significa tanto as DIVERSAS FONTES (sensores, social, logs) quanto os DIVERSOS FORMATOS (texto, v√≠deo, √°udio, dados estruturados de bancos, JSON, XML). √â a "mistureba" toda. üí° **Dica:** A banca pode tentar restringir um conceito multifacetado. "Variedade" √© mais do que s√≥ de onde vem. (Cap√≠tulo 1, p. 39, 40)                                                                                                                                                                                                                                                                                                                                                               |
| 17  | A linguagem Cypher, utilizada em bancos de dados orientados a grafos, √© uma linguagem procedural, exigindo que o usu√°rio especifique passo a passo como navegar no grafo para encontrar os padr√µes desejados.                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ Cypher √© **declarativa**, assim como SQL. Voc√™ diz ao Cypher: "Encontre este PADR√ÉO de n√≥s e relacionamentos" (ex: `(p:Pessoa)-[:TRABALHA_EM]->(e:Empresa)`). Voc√™ n√£o diz "v√° para o n√≥ X, siga a aresta Y, depois vire √† esquerda...". üí° **Dica:** Assim como SQL, Cypher foca no "o qu√™", n√£o no "como". (Cap√≠tulo 1, p. 45)                                                                                                                                                                                                                                                                                                                                                                                       |
| 18  | No modelo Entidade-Relacionamento, um conjunto de entidades √© representado graficamente por um losango, enquanto um conjunto de relacionamentos √© representado por um ret√¢ngulo.                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ √â o contr√°rio! Pense assim: Entidades s√£o as "coisas" importantes (como caixas/ret√¢ngulos). Relacionamentos s√£o as "conex√µes" entre essas coisas (como diamantes/losangos que ligam as caixas). üí° **Dica:** Memorizar a representa√ß√£o gr√°fica b√°sica √© fundamental. Errar isso √© dar ponto de gra√ßa. (Cap√≠tulo 2, p. 65)                                                                                                                                                                                                                                                                                                                                                                                              |
| 19  | A cardinalidade de um relacionamento (ex: 1:N) descreve o n√∫mero m√°ximo de atributos que um conjunto de relacionamento pode possuir.                                                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ Cardinalidade (ou tipo de associa√ß√£o) diz quantos "caras" de um lado podem se relacionar com quantos "caras" do outro. Exemplo: Um departamento (1) pode ter Muitos (N) empregados. N√£o tem a ver com o n√∫mero de atributos do relacionamento em si. üí° **Dica:** Cardinalidade = Quantidade de inst√¢ncias relacionadas. (Cap√≠tulo 2, p. 71-72)                                                                                                                                                                                                                                                                                                                                                                        |
| 20  | Generaliza√ß√£o √© o processo de detalhar uma entidade gen√©rica em m√∫ltiplos subtipos, enquanto agrega√ß√£o √© o processo de simplificar m√∫ltiplas entidades em uma √∫nica superentidade.                                                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ Generaliza√ß√£o √© como dizer "Cachorro, Gato e P√°ssaro s√£o todos ANIMAIS" (subtipos para um supertipo). Agrega√ß√£o √© tratar um conjunto de partes como um todo, como um "CARRO" que √© composto por "Motor", "Rodas", "Chassi". A segunda parte da afirma√ß√£o est√° invertida. üí° **Dica:** Generaliza√ß√£o √© "√© um tipo de". Agrega√ß√£o √© "√© parte de". (Cap√≠tulo 2, p. 74, 75-76)                                                                                                                                                                                                                                                                                                                                             |
| 21  | Uma tabela que possui atributos com valores n√£o at√¥micos, como listas de hobbies para um empregado, est√°, por defini√ß√£o, na Segunda Forma Normal (2FN).                                                                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ Opa! Para estar na 1FN (Primeira Forma Normal), todos os atributos j√° devem ser at√¥micos (indivis√≠veis). Se tem lista dentro de um campo, nem na 1FN ela est√°! A 2FN trata de depend√™ncias parciais em chaves compostas e j√° pressup√µe a 1FN. üí° **Dica:** A hierarquia das Formas Normais √© cumulativa. Para estar na XFN, tem que estar nas anteriores. (Cap√≠tulo 2, p. 81)                                                                                                                                                                                                                                                                                                                                          |
| 22  | Ao mapear um modelo Entidade-Relacionamento para um modelo de grafo, cada conjunto de entidade se torna uma aresta e cada conjunto de relacionamento se torna um n√≥.                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ No mapeamento ER para Grafo, as "coisas" (Entidades) viram os pontos (N√≥s/V√©rtices). As "conex√µes" (Relacionamentos) viram as linhas que ligam os pontos (Arestas/Edges). üí° **Dica:** Entidade = N√≥; Relacionamento = Aresta. √â intuitivo se voc√™ pensar visualmente. (Cap√≠tulo 2, p. 66, 131-133)                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 23  | A propriedade de "Uniqueness" de uma chave de identifica√ß√£o em uma tabela relacional implica que os valores da chave devem ser √∫nicos, mas permite que a chave seja composta por um √∫nico atributo que pode ser nulo.                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ "Uniqueness" (Unicidade) significa que os valores da chave n√£o se repetem. Uma chave prim√°ria, que garante essa unicidade, **n√£o pode** conter valores nulos. Outras chaves candidatas √∫nicas (n√£o prim√°rias) poderiam, em alguns SGBDs, ter nulos se n√£o fossem restritas com `NOT NULL`. üí° **Dica:** Chave Prim√°ria = √önica E N√£o Nula. (Cap√≠tulo 1, p. 31; Cap√≠tulo 2, p. 109)                                                                                                                                                                                                                                                                                                                                     |
| 24  | A Terceira Forma Normal (3FN) visa eliminar redund√¢ncias causadas por depend√™ncias multivaloradas entre atributos n√£o chave.                                                                                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ A 3FN lida com **depend√™ncias transitivas** (um atributo n√£o chave dependendo de outro atributo n√£o chave, que por sua vez depende da chave). Depend√™ncias multivaloradas s√£o tratadas pela Quarta Forma Normal (4FN). üí° **Dica:** Associe: 1FN=Atomicidade, 2FN=Dep. Parcial, 3FN=Dep. Transitiva, 4FN=Dep. Multivalorada. Mnem√¥nico: "A Parada Transit√≥ria Multiplica". (Cap√≠tulo 2, p. 87, 90)                                                                                                                                                                                                                                                                                                                     |
| 25  | Na √°lgebra relacional, o operador de Proje√ß√£o (œÄ) √© utilizado para selecionar um subconjunto de tuplas de uma rela√ß√£o que satisfazem uma determinada condi√ß√£o.                                                                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ Pense na Proje√ß√£o (œÄ) como escolher quais COLUNAS voc√™ quer ver de uma tabela (como um projetor mostrando s√≥ parte da imagem). Para selecionar LINHAS (tuplas) baseadas em condi√ß√µes, usamos o operador de Sele√ß√£o (œÉ). üí° **Dica:** œÄ = Colunas (Proje√ß√£o Vertical); œÉ = Linhas (Sele√ß√£o Horizontal). (Cap√≠tulo 3, p. 162-163, 167-168)                                                                                                                                                                                                                                                                                                                                                                               |
| 26  | A linguagem QBE (Query by Example) √© mais poderosa que SQL, pois permite a defini√ß√£o de esquemas de banco de dados e o gerenciamento de permiss√µes de usu√°rios, funcionalidades ausentes no SQL padr√£o.                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ QBE √© focada em consultas e manipula√ß√µes simples de dados, usando exemplos visuais. SQL √© muito mais completa, incluindo DDL (para definir esquemas com `CREATE TABLE`), DCL (para permiss√µes com `GRANT`/`REVOKE`) e DML (para manipular dados). QBE √© limitada nesse aspecto. üí° **Dica:** SQL √© o "canivete su√≠√ßo" das linguagens de BD relacionais. QBE √© mais uma "ferramenta de consulta visual". (Cap√≠tulo 3, p. 180, 182)                                                                                                                                                                                                                                                                                      |
| 27  | O comando `INSERT INTO EMPLOYEE VALUES ('E20', 'Mahoney', 'Market Ave S', 'Canton', 'D6')` em SQL falhar√° se a tabela `EMPLOYEE` n√£o possuir uma coluna chamada `VALUES`.                                                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ `VALUES` n√£o √© o nome de uma coluna aqui, √© uma palavra-chave do SQL que indica que os valores a seguir devem ser inseridos na tabela `EMPLOYEE`, na ordem das colunas da tabela (ou na ordem especificada se as colunas fossem listadas ap√≥s `EMPLOYEE`). üí° **Dica:** Conhe√ßa as palavras-chave do SQL! `VALUES` introduz a lista de valores a serem inseridos. (Cap√≠tulo 3, p. 179)                                                                                                                                                                                                                                                                                                                                 |
| 28  | A cl√°usula `FROM` em uma instru√ß√£o SQL `SELECT` especifica as condi√ß√µes de filtragem para as tuplas, enquanto a cl√°usula `WHERE` lista as tabelas de origem dos dados.                                                                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ √â o inverso! `FROM` diz de ONDE v√™m os dados (quais tabelas). `WHERE` diz QUAIS dados voc√™ quer (as condi√ß√µes/filtros). Pense: "Pegue dados DE (`FROM`) tabelaX, ONDE (`WHERE`) a cidade √© 'Natal'". üí° **Dica:** `FROM` = Fonte; `WHERE` = Filtro. (Cap√≠tulo 3, p. 177)                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 29  | Em Cypher, o comando `MATCH (p:Product) RETURN p.price` retornar√° todos os produtos cujo pre√ßo seja igual a um valor espec√≠fico previamente definido na vari√°vel `p.price`.                                                                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ Este comando Cypher (`MATCH (p:Product) RETURN p.price`) significa: "Encontre todos os n√≥s rotulados como 'Product' (chame cada um de 'p') e, para cada um deles, retorne o valor de sua propriedade 'price'". Ele lista os pre√ßos de TODOS os produtos, n√£o filtra por um pre√ßo espec√≠fico. Para filtrar, usar√≠amos `WHERE p.price = valor`. üí° **Dica:** `MATCH` encontra padr√µes, `RETURN` projeta. `WHERE` filtra. (Cap√≠tulo 3, p. 186-187)                                                                                                                                                                                                                                                                        |
| 30  | O conceito de cursor em SQL embarcado permite que um programa processe m√∫ltiplas tuplas de uma tabela simultaneamente em uma √∫nica opera√ß√£o, otimizando o desempenho em rela√ß√£o ao processamento tupla-a-tupla.                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ Um cursor √© como um "dedo" que aponta para UMA tupla de cada vez dentro de um conjunto de resultados. Ele permite que linguagens de programa√ß√£o (que geralmente processam um item por vez) interajam com o resultado de uma query SQL (que √© um conjunto). Ele FACILITA o processamento tupla-a-tupla, n√£o o processamento de m√∫ltiplas tuplas simultaneamente. üí° **Dica:** Cursor = Ponte entre o mundo set-based do SQL e o mundo procedural das linguagens de programa√ß√£o. (Cap√≠tulo 3, p. 192)                                                                                                                                                                                                                    |
| 31  | A propriedade de Isolamento (I) do ACID garante que todas as opera√ß√µes de uma transa√ß√£o sejam conclu√≠das com sucesso; caso contr√°rio, nenhuma altera√ß√£o √© efetivada no banco de dados.                                                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ Isolamento (I) significa que transa√ß√µes concorrentes n√£o devem interferir umas nas outras, como se cada uma estivesse rodando sozinha. A propriedade que garante "tudo ou nada" √© a Atomicidade (A). üí° **Dica:** Isole cada propriedade do ACID: A=Tudo ou Nada; C=Consistente; I=Sozinha no Mundo; D=N√£o some. (Cap√≠tulo 4, p. 218)                                                                                                                                                                                                                                                                                                                                                                                  |
| 32  | O protocolo de Bloqueio de Duas Fases (2PL) estrito exige que todos os bloqueios de escrita sejam mantidos at√© o final da transa√ß√£o, mas permite que bloqueios de leitura sejam liberados durante a fase de encolhimento.                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ No 2PL Estrito (Strict 2PL), TODOS os bloqueios (de leitura e escrita) s√£o mantidos at√© que a transa√ß√£o seja comitada ou abortada. Isso evita leituras sujas e outros problemas. O 2PL comum permite liberar bloqueios na fase de encolhimento, mas o Estrito √© mais... estrito! üí° **Dica:** "Estrito" no 2PL significa segurar os bloqueios at√© o fim mesmo. (Cap√≠tulo 4, p. 224, embora o livro n√£o detalhe o "Estrito", o 2PL normal j√° tem fases de expans√£o e encolhimento). A ideia geral √© sobre quando se libera.                                                                                                                                                                                             |
| 33  | Em sistemas que seguem o teorema CAP, a escolha por garantir Consist√™ncia (C) e Toler√¢ncia a Parti√ß√µes (P) implica que a Disponibilidade (A) tamb√©m ser√° plenamente garantida, pois P cobre falhas de rede.                                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ O Teorema CAP diz que voc√™ s√≥ pode ter DOIS dos tr√™s. Se voc√™ escolhe C e P (muito comum em bancos distribu√≠dos que precisam de dados corretos mesmo com falhas de rede), voc√™ pode ter que sacrificar a Disponibilidade (A). Ex: se uma parte da rede cai, o sistema pode ficar indispon√≠vel para garantir consist√™ncia. üí° **Dica:** CAP = Escolha 2 de 3: C, A, P. (Cap√≠tulo 4, p. 233-234)                                                                                                                                                                                                                                                                                                                         |
| 34  | O modelo de consist√™ncia BASE (Basically Available, Soft state, Eventually consistent) √© prefer√≠vel ao ACID quando a prioridade m√°xima √© garantir a consist√™ncia imediata e forte dos dados em todas as r√©plicas.                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ BASE √© o oposto! Ele prioriza Disponibilidade (Basically Available) e aceita que os dados podem estar em um "estado suave" (Soft state), alcan√ßando a consist√™ncia "eventualmente" (Eventually consistent). ACID √© quem busca consist√™ncia forte e imediata. üí° **Dica:** ACID = Consist√™ncia Forte Agora! BASE = Dispon√≠vel Agora, Consistente Depois. (Cap√≠tulo 4, p. 233, 241-242)                                                                                                                                                                                                                                                                                                                                  |
| 35  | A serializabilidade de transa√ß√µes concorrentes √© alcan√ßada quando o grafo de preced√™ncia resultante n√£o cont√©m ciclos, indicando que as transa√ß√µes podem ser executadas em qualquer ordem aleat√≥ria.                                                                                                                                                                                                                                                                                                                                 | V        | üë®‚Äçüè´ Correto! Um grafo de preced√™ncia sem ciclos significa que existe uma ordem serial (uma atr√°s da outra) na qual as transa√ß√µes poderiam ter sido executadas para produzir o mesmo resultado. Isso √© a defini√ß√£o de serializabilidade. "Qualquer ordem aleat√≥ria" n√£o √© bem o termo, mas sim que *existe uma* ordem serial equivalente. üí° **Dica:** Ciclo no grafo de preced√™ncia = Problema de serializa√ß√£o! (Cap√≠tulo 4, p. 223)                                                                                                                                                                                                                                                                                       |
| 36  | M√©todos otimistas de controle de concorr√™ncia previnem conflitos bloqueando preventivamente os dados antes do in√≠cio da transa√ß√£o, garantindo que nenhum conflito ocorra durante a fase de valida√ß√£o.                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ M√©todos otimistas s√£o... otimistas! Eles assumem que conflitos s√£o raros. As transa√ß√µes rodam sem bloqueios e, S√ì NO FINAL, na fase de valida√ß√£o, o sistema verifica se houve conflito. Se houve, a transa√ß√£o √© abortada. M√©todos pessimistas √© que usam bloqueios preventivos. üí° **Dica:** Otimista = Tenta primeiro, verifica depois. Pessimista = Verifica primeiro, tenta depois. (Cap√≠tulo 4, p. 228-229)                                                                                                                                                                                                                                                                                                        |
| 37  | Dados semiestruturados, como XML ou JSON, seguem um esquema r√≠gido e predefinido, similar aos dados estruturados em bancos de dados relacionais, facilitando a valida√ß√£o e a consist√™ncia.                                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ Dados semiestruturados (como XML com DTD/Schema opcional, ou JSON) t√™m alguma estrutura (tags, aninhamento), mas s√£o mais flex√≠veis e menos r√≠gidos que o esquema de um BD relacional. O esquema pode n√£o existir, ou variar. üí° **Dica:** Estruturado = Tabela r√≠gida. Semiestruturado = Flex√≠vel com tags/chaves. N√£o estruturado = Texto livre, imagem. (Cap√≠tulo 5, p. 249)                                                                                                                                                                                                                                                                                                                                        |
| 38  | O uso de uma √Årvore B+ (B plus tree) para indexa√ß√£o em bancos de dados armazena os dados reais dos registros exclusivamente nos n√≥s internos da √°rvore, enquanto as folhas cont√™m apenas ponteiros.                                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ Na √Årvore B+ (B plus tree), √© o contr√°rio! Todos os dados (ou ponteiros para os dados) residem nas FOLHAS. Os n√≥s internos cont√™m apenas chaves de √≠ndice para guiar a busca at√© as folhas. Isso otimiza varreduras em faixa (range scans). üí° **Dica:** B+ Tree: Dados S√ì nas folhas! (Cap√≠tulo 5, p. 256, embora o livro mencione a B-Tree e o conceito de folha-orientada)                                                                                                                                                                                                                                                                                                                                          |
| 39  | O algoritmo de hashing consistente, usado em sistemas distribu√≠dos, garante que, ao adicionar ou remover um n√≥ do cluster, todos os dados precisem ser remapeados para manter a distribui√ß√£o uniforme.                                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ A grande vantagem do hashing consistente √© justamente o oposto! Ao adicionar/remover um n√≥, APENAS uma PEQUENA fra√ß√£o dos dados (aqueles que "deveriam" estar no novo n√≥ ou que estavam no n√≥ removido) precisa ser remapeada. A maioria dos dados permanece intocada nos outros n√≥s. üí° **Dica:** Hashing consistente minimiza o "estrago" da reorganiza√ß√£o. (Cap√≠tulo 5, p. 260-261)                                                                                                                                                                                                                                                                                                                                 |
| 40  | A fase "Map" do MapReduce √© respons√°vel por agregar os resultados intermedi√°rios de diferentes n√≥s, enquanto a fase "Reduce" distribui as sub-tarefas e extrai pares chave-valor.                                                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ Inverteu! **Map**: Pega os dados, quebra em pedacinhos (subtarefas), e "mapeia" cada pedacinho para um par chave-valor (extrai). **Reduce**: Pega todos os pedacinhos com a mesma chave e "reduz" (agrega, soma, conta) eles para um resultado final. üí° **Dica:** Map = Espalha e Transforma. Reduce = Junta e Agrega. (Cap√≠tulo 5, p. 277)                                                                                                                                                                                                                                                                                                                                                                           |
| 41  | Em uma arquitetura de SGBD em camadas, a camada mais baixa (Layer 5: Memory allocation) √© respons√°vel pela interface com o usu√°rio final, traduzindo consultas SQL em opera√ß√µes de √°lgebra relacional.                                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ A camada mais baixa (Layer 5) lida com a aloca√ß√£o f√≠sica de mem√≥ria, blocos de disco, coisas bem "hardware". A interface com o usu√°rio, tradu√ß√£o de SQL, etc., acontece nas camadas mais ALTAS (Layer 1: Set-oriented Interface). üí° **Dica:** Pense nas camadas como uma cebola: o usu√°rio est√° na casca (camada alta), o disco est√° no miolo (camada baixa). (Cap√≠tulo 5, p. 281, 283)                                                                                                                                                                                                                                                                                                                               |
| 42  | Um arquivo de grade (grid file) √© uma estrutura de dados multidimensional que suporta acesso sim√©trico por m√∫ltiplas chaves, mas exige um n√∫mero de acessos a disco proporcional ao n√∫mero de dimens√µes para cada consulta.                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ A beleza do grid file √© que ele garante, no m√°ximo, DOIS acessos a disco para uma consulta pontual (um para o √≠ndice da grade, outro para a p√°gina de dados), independentemente do n√∫mero de dimens√µes (dentro de limites pr√°ticos). üí° **Dica:** Grid file = R√°pido acesso multidimensional com poucos acessos a disco. (Cap√≠tulo 5, p. 262, 265)                                                                                                                                                                                                                                                                                                                                                                     |
| 43  | Bancos de dados federados armazenam todos os fragmentos de dados fisicamente em um √∫nico servidor centralizado, mas fornecem m√∫ltiplas vis√µes l√≥gicas para diferentes grupos de usu√°rios.                                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ Bancos federados s√£o sobre dados **distribu√≠dos**! Os fragmentos est√£o em computadores DIFERENTES, mas o sistema te d√° a ilus√£o (vis√£o l√≥gica √∫nica) de que est√° tudo junto. O oposto do que a quest√£o diz. üí° **Dica:** Federado = Fisicamente Separado, Logicamente Unido. (Cap√≠tulo 6, p. 295)                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 44  | Em um banco de dados temporal, o "tempo de transa√ß√£o" refere-se ao per√≠odo em que uma informa√ß√£o √© considerada v√°lida no mundo real, enquanto o "tempo de validade" registra quando a informa√ß√£o foi fisicamente alterada no banco.                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ Invertido! **Tempo de Validade** (Valid Time): Quando o fato √© VERDADEIRO no mundo real (Ex: Sal√°rio do Jo√£o foi R$5000 de Jan/2023 a Dez/2023). **Tempo de Transa√ß√£o** (Transaction Time): Quando o banco de dados REGISTROU essa informa√ß√£o. üí° **Dica:** Validade = Realidade. Transa√ß√£o = Registro no BD. (Cap√≠tulo 6, p. 300)                                                                                                                                                                                                                                                                                                                                                                                     |
| 45  | Um esquema floco de neve (snowflake schema) em modelagem multidimensional √© uma forma simplificada do esquema estrela, onde todas as tabelas de dimens√£o s√£o desnormalizadas e fundidas com a tabela de fatos.                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ Um esquema floco de neve √© MAIS normalizado que um estrela. Nele, as tabelas de dimens√£o podem ser decompostas em outras tabelas de dimens√£o menores (como os "bracinhos" de um floco de neve saindo dos bra√ßos principais). O esquema estrela tem uma tabela de fatos central e tabelas de dimens√£o diretamente ligadas a ela. üí° **Dica:** Estrela = Simples e direto. Floco de Neve = Mais bracinhos, mais normalizado. (Cap√≠tulo 6, p. 306, 308)                                                                                                                                                                                                                                                                   |
| 46  | O principal objetivo de um Data Warehouse (DWH) √© suportar transa√ß√µes operacionais de alta frequ√™ncia (OLTP), garantindo a escrita r√°pida e a modifica√ß√£o constante dos dados para refletir o estado atual do neg√≥cio.                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ Um DWH √© para AN√ÅLISE (OLAP - Online Analytical Processing), n√£o para transa√ß√µes do dia-a-dia (OLTP). Ele guarda dados hist√≥ricos, √© otimizado para leitura e agrega√ß√£o, e os dados geralmente n√£o s√£o modificados ap√≥s carregados ("read-only"). üí° **Dica:** DWH = Olhar para o passado para entender o presente e prever o futuro (an√°lise). BD Operacional = Fazer as coisas agora (transa√ß√µes). (Cap√≠tulo 6, p. 309-310)                                                                                                                                                                                                                                                                                          |
| 47  | Em bancos de dados objeto-relacionais, a encapsula√ß√£o de dados impede que os m√©todos (opera√ß√µes) definidos para um tipo de objeto possam ser herdados por seus subtipos.                                                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ A heran√ßa √© uma das grandes vantagens da orienta√ß√£o a objetos! Subtipos HERDAM tanto a estrutura (atributos) quanto o comportamento (m√©todos) de seus supertipos. Encapsula√ß√£o protege o estado interno do objeto, mas n√£o impede a heran√ßa de sua interface e comportamento. üí° **Dica:** Heran√ßa √© fundamental em OO. (Cap√≠tulo 6, p. 318)                                                                                                                                                                                                                                                                                                                                                                           |
| 48  | Bancos de dados dedutivos (ou de conhecimento) armazenam apenas fatos explicitamente inseridos, sendo incapazes de derivar novas informa√ß√µes ou fatos atrav√©s de regras l√≥gicas.                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ A ess√™ncia de um banco de dados dedutivo √© justamente sua capacidade de INFERIR novos fatos a partir de fatos existentes e REGRAS! Se ele s√≥ guardasse fatos, seria um banco de dados comum. üí° **Dica:** Dedutivo = Fatos + Regras para Descobrir Mais Coisas. (Cap√≠tulo 6, p. 321)                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 49  | A l√≥gica fuzzy aplicada a bancos de dados (Fuzzy Databases) permite o armazenamento de dados com m√∫ltiplos valores de verdade simultaneamente, mas n√£o suporta consultas com termos vagos como "aproximadamente" ou "alto".                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ A l√≥gica fuzzy √© toda sobre lidar com vagueza e imprecis√£o! Uma de suas for√ßas √© permitir consultas com termos lingu√≠sticos como "sal√°rio ALTO" ou "idade APROXIMADAMENTE 30". Ela associa graus de pertencimento, n√£o apenas verdadeiro/falso. üí° **Dica:** Fuzzy = Vago, Impreciso, Aproximado. (Cap√≠tulo 6, p. 326, 330-331)                                                                                                                                                                                                                                                                                                                                                                                        |
| 50  | O Mapeamento Objeto-Relacional (ORM) √© uma t√©cnica que converte automaticamente classes de linguagens orientadas a objetos em estruturas de bancos de dados NoSQL do tipo grafo, para melhor representar relacionamentos.                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ ORM tipicamente mapeia classes de linguagens OO para tabelas em bancos de dados **RELACIONAIS** (SQL). O "R" em ORM vem de Relacional. Embora existam mapeadores para NoSQL (√†s vezes chamados ODMs - Object Document Mappers, etc.), o ORM cl√°ssico √© para o mundo SQL. üí° **Dica:** ORM = Objeto PARA Relacional. (Cap√≠tulo 6, p. 318)                                                                                                                                                                                                                                                                                                                                                                               |
| 51  | Todos os bancos de dados NoSQL, por defini√ß√£o, eliminam completamente o conceito de esquema, o que significa que n√£o h√° como definir tipos de dados ou estruturas, nem mesmo implicitamente.                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ Muitos NoSQL s√£o "schema-less" ou "schema-flexible", mas n√£o todos eliminam o esquema completamente. Bancos de Grafos t√™m um esquema de tipos de n√≥s e arestas (mesmo que impl√≠cito). Column-family stores t√™m fam√≠lias de colunas como um tipo de esquema. O n√≠vel de rigidez do esquema varia muito. üí° **Dica:** NoSQL √© um universo diverso. "Todos" e "Completamente" s√£o generaliza√ß√µes perigosas. (Cap√≠tulo 7, p. 344, 350, 353, 364)                                                                                                                                                                                                                                                                           |
| 52  | Bancos de dados chave-valor (Key-Value Stores) s√£o ideais para armazenar dados com relacionamentos complexos e realizar consultas que envolvem m√∫ltiplas jun√ß√µes entre diferentes chaves.                                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ Key-Value stores s√£o super simples: voc√™ tem uma chave e um valor associado. S√£o √≥timos para buscas r√°pidas por chave. Mas para relacionamentos complexos e jun√ß√µes, eles s√£o bem ruins. Bancos de Grafos ou Relacionais s√£o melhores para isso. üí° **Dica:** Chave-Valor = Dicion√°rio Simples. (Cap√≠tulo 7, p. 345-346)                                                                                                                                                                                                                                                                                                                                                                                               |
| 53  | Em bancos de dados orientados a documentos, cada documento armazenado deve obrigatoriamente aderir a um esquema XML global definido para todo o banco, garantindo a interoperabilidade.                                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ Document stores (como MongoDB que usa BSON/JSON, ou CouchDB que usa JSON) s√£o geralmente schema-flexible. Cada documento pode ter sua pr√≥pria estrutura. Embora possam armazenar dados que *poderiam* ser XML, n√£o h√° obrigatoriedade de um esquema XML global. üí° **Dica:** Documento = Estrutura flex√≠vel por documento. (Cap√≠tulo 7, p. 353)                                                                                                                                                                                                                                                                                                                                                                        |
| 54  | A principal vantagem dos bancos de dados orientados a colunas (Column-Family Stores) sobre os bancos relacionais tradicionais √© a otimiza√ß√£o para opera√ß√µes de escrita intensiva, devido √† sua organiza√ß√£o por linha completa.                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ Column-family stores s√£o otimizados para LEITURA de subconjuntos de colunas e para cargas de trabalho anal√≠ticas onde voc√™ n√£o precisa de todas as colunas de uma linha. Eles armazenam dados por coluna (ou fam√≠lia de colunas), n√£o por linha completa. Bancos relacionais tradicionais s√£o row-stores. üí° **Dica:** Column-store = Bom para ler poucas colunas de muitas linhas. (Cap√≠tulo 7, p. 349-350)                                                                                                                                                                                                                                                                                                           |
| 55  | A persist√™ncia poliglota (polyglot persistence) recomenda o uso de um √∫nico tipo de banco de dados NoSQL para todas as partes de uma aplica√ß√£o complexa, a fim de simplificar a arquitetura e o desenvolvimento.                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Persist√™ncia Poliglota √© sobre usar o BANCO CERTO para a TAREFA CERTA. Significa que uma aplica√ß√£o pode usar V√ÅRIOS tipos de bancos (um relacional para transa√ß√µes, um de grafos para social, um chave-valor para cache, etc.) aproveitando o melhor de cada um. üí° **Dica:** Poliglota = Fala v√°rias l√≠nguas (usa v√°rios BDs). (Cap√≠tulo 7, p. 344)                                                                                                                                                                                                                                                                                                                                                                   |
| 56  | Bancos de dados orientados a grafos, como o Neo4j, garantem a integridade referencial implicitamente atrav√©s da pr√≥pria estrutura de n√≥s e arestas, mas n√£o suportam indexa√ß√£o para otimizar buscas por propriedades.                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ Eles garantem integridade referencial (uma aresta sempre conecta dois n√≥s existentes), sim! E eles SUPORTAM indexa√ß√£o em propriedades de n√≥s e arestas para acelerar buscas, assim como bancos relacionais usam √≠ndices. üí° **Dica:** Grafos s√£o sobre relacionamentos, mas performance ainda importa, ent√£o √≠ndices s√£o bem-vindos! (Cap√≠tulo 7, p. 364, 366)                                                                                                                                                                                                                                                                                                                                                         |
| 57  | O modelo Bigtable do Google, que influenciou os column-family stores, define uma tabela como um mapa denso, onde cada combina√ß√£o de linha e coluna deve obrigatoriamente possuir um valor.                                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ O Bigtable √© um mapa **ESPARSO** (sparse). Isso significa que muitas combina√ß√µes de linha e coluna podem N√ÉO ter valor, e nada √© armazenado para elas, economizando espa√ßo. Se fosse denso, seria muito ineficiente. üí° **Dica:** Esparso = Muitos "buracos" permitidos. Denso = Tudo preenchido. (Cap√≠tulo 7, p. 349)                                                                                                                                                                                                                                                                                                                                                                                                 |
| 58  | Em um banco de dados chave-valor distribu√≠do utilizando sharding, a remo√ß√£o de um shard (n√≥) exige a redistribui√ß√£o completa de todas as chaves por todos os shards restantes para manter o balanceamento.                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ Com hashing consistente (comum em sharding), a remo√ß√£o de um shard afeta principalmente as chaves que estavam naquele shard e suas "vizinhas" no anel de hash. A maioria das outras chaves nos outros shards n√£o precisa ser movida. O impacto √© minimizado. üí° **Dica:** Sharding inteligente (com hashing consistente) reduz o "caos" da reorganiza√ß√£o. (Cap√≠tulo 7, p. 346-347, similar ao conceito do Cap. 5)                                                                                                                                                                                                                                                                                                      |
| 59  | A atomicidade em uma transa√ß√£o ACID garante que os dados modificados pela transa√ß√£o sejam permanentemente armazenados e sobrevivam a falhas do sistema.                                                                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ Atomicidade √© o "tudo ou nada": ou a transa√ß√£o inteira acontece, ou nada dela acontece. A propriedade que garante que os dados, uma vez comitados, s√£o permanentes e sobrevivem a falhas √© a Durabilidade (D). üí° **Dica:** A = All or Nothing. D = Doesn't Disappear. (Cap√≠tulo 4, p. 218)                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 60  | A principal fun√ß√£o do operador `JOIN` em SQL √© filtrar colunas espec√≠ficas de uma √∫nica tabela, de forma similar ao operador de proje√ß√£o da √°lgebra relacional.                                                                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ O `JOIN` serve para COMBINAR linhas de DUAS OU MAIS tabelas com base em colunas relacionadas. Filtrar colunas de uma √∫nica tabela √© feito com a cl√°usula `SELECT nome_coluna` (proje√ß√£o). üí° **Dica:** `JOIN` = Juntar tabelas. `SELECT colunas` = Escolher colunas. (Cap√≠tulo 3, p. 170, 172; √Ålgebra: p. 162-163)                                                                                                                                                                                                                                                                                                                                                                                                    |
| 61  | A distin√ß√£o fundamental entre um "schema" e "data" em um banco de dados relacional √© que o schema descreve a estrutura e as restri√ß√µes dos dados (metadados), enquanto os dados s√£o as inst√¢ncias reais que preenchem essa estrutura.                                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ Exato! Pense no schema como a planta baixa de uma casa üè† (onde ficam os c√¥modos, que tipo de c√¥modo √©, quantas portas e janelas). Os dados s√£o os m√≥veis e as pessoas üõãÔ∏èüßç dentro da casa. O schema define o "molde", os dados s√£o o "recheio". üí° **Dica:** Metadados = Dados sobre os dados. Schema √© o metadado principal. (Cap√≠tulo 1, p. 38)                                                                                                                                                                                                                                                                                                                                                                    |
| 62  | A independ√™ncia de dados f√≠sica, proporcionada por SGBDs, permite que altera√ß√µes na forma como os dados s√£o armazenados fisicamente (ex: mudan√ßa de disco, tipo de indexa√ß√£o) n√£o exijam modifica√ß√µes nas aplica√ß√µes que os acessam.                                                                                                                                                                                                                                                                                                 | V        | üë®‚Äçüè´ Isso mesmo! √â como se voc√™ mudasse o encanamento da sua casa üõ†Ô∏è. Desde que a √°gua continue saindo da torneira da mesma forma (interface l√≥gica), voc√™ (a aplica√ß√£o) n√£o precisa se preocupar com os detalhes da mudan√ßa interna. O SGBD faz essa m√°gica de abstra√ß√£o. üí° **Dica:** Independ√™ncia f√≠sica = "N√£o me importo como est√° guardado, s√≥ me d√™ o dado!". (Cap√≠tulo 1, p. 38)                                                                                                                                                                                                                                                                                                                                  |
| 63  | A principal motiva√ß√£o para o surgimento de bancos de dados NoSQL foi a necessidade de garantir maior consist√™ncia transacional (ACID) em aplica√ß√µes web de larga escala, em detrimento da escalabilidade horizontal.                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ Na verdade, foi o contr√°rio! Muitos NoSQL surgiram para oferecer MELHOR ESCALABILIDADE HORIZONTAL e ALTA DISPONIBILIDADE para aplica√ß√µes web massivas, muitas vezes relaxando as garantias ACID estritas em favor do modelo BASE (Eventually Consistent). üí° **Dica:** NoSQL frequentemente troca consist√™ncia forte por escalabilidade/disponibilidade. (Cap√≠tulo 1, p. 28, 38, 48, 50)                                                                                                                                                                                                                                                                                                                               |
| 64  | A "Veracity" (Veracidade) em Big Data, um dos "Vs" adicionais, refere-se √† import√¢ncia de garantir que os dados sejam sempre 100% precisos e livres de qualquer ambiguidade antes de serem processados.                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ Veracidade em Big Data reconhece que os dados podem ser bagun√ßados, incertos, ruidosos, e com qualidade vari√°vel üò¨. O desafio √© lidar com essa incerteza, limpar o que for poss√≠vel e entender o impacto da qualidade dos dados nas an√°lises. N√£o √© sobre ter dados perfeitos, mas sobre gerenciar a imperfei√ß√£o. üí° **Dica:** Veracidade = Qu√£o confi√°vel/bagun√ßado √© o dado? (Cap√≠tulo 1, p. 41)                                                                                                                                                                                                                                                                                                                    |
| 65  | A organiza√ß√£o de gerenciamento de dados em uma empresa, envolvendo arquitetura, governan√ßa, tecnologia e utiliza√ß√£o de dados, √© crucial para transformar dados brutos em ativos de informa√ß√£o estrat√©gicos.                                                                                                                                                                                                                                                                                                                          | V        | üë®‚Äçüè´ Perfeito! Ter uma boa gest√£o de dados √© como ter um bom chef e uma cozinha organizada üßë‚Äçüç≥. Voc√™ pega ingredientes brutos (dados) e, com as ferramentas e processos certos (arquitetura, governan√ßa, tecnologia), cria pratos deliciosos e valiosos (informa√ß√£o estrat√©gica, insights). üí° **Dica:** Dados bem gerenciados = Poder de decis√£o. (Cap√≠tulo 1, p. 52-54)                                                                                                                                                                                                                                                                                                                                                 |
| 66  | A normaliza√ß√£o de um banco de dados relacional, at√© a Terceira Forma Normal (3FN), visa primariamente otimizar o desempenho das consultas, mesmo que isso introduza um alto grau de redund√¢ncia de dados.                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ O objetivo principal da normaliza√ß√£o (especialmente at√© 3FN/BCNF) √© REDUZIR A REDUND√ÇNCIA de dados e evitar ANOMALIAS de inser√ß√£o, atualiza√ß√£o e dele√ß√£o, garantindo a integridade. Isso pode, √†s vezes, levar a mais jun√ß√µes em consultas, o que *poderia* impactar o desempenho. Otimiza√ß√£o de consulta √© outra etapa. üí° **Dica:** Normaliza√ß√£o = Menos redund√¢ncia, mais integridade. (Cap√≠tulo 2, p. 78)                                                                                                                                                                                                                                                                                                          |
| 67  | Uma depend√™ncia funcional A ‚Üí B em uma rela√ß√£o R significa que para cada valor √∫nico de A, existe um, e somente um, valor de B associado, e A deve ser obrigatoriamente uma chave candidata da rela√ß√£o R.                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ A primeira parte est√° correta: A ‚Üí B significa que A determina B (cada A tem um √∫nico B). Por√©m, A N√ÉO precisa ser uma chave candidata. Pode ser qualquer atributo ou conjunto de atributos. Se A *fosse* uma chave candidata, ent√£o todos os outros atributos dependeriam funcionalmente dela. üí° **Dica:** A seta da depend√™ncia funcional (‚Üí) significa "determina". O determinante (lado esquerdo) n√£o precisa ser chave. (Cap√≠tulo 2, p. 84)                                                                                                                                                                                                                                                                      |
| 68  | A Quinta Forma Normal (5FN), tamb√©m conhecida como Project-Join Normal Form (PJNF), lida com a reconstru√ß√£o sem perdas de uma tabela a partir de m√∫ltiplas proje√ß√µes, garantindo que n√£o surjam tuplas esp√∫rias ap√≥s as jun√ß√µes.                                                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Exatamente! A 5FN √© mais "esot√©rica" e trata de depend√™ncias de jun√ß√£o (join dependencies). Ela garante que se voc√™ quebrar uma tabela em v√°rias partes (proje√ß√µes) e depois junt√°-las de volta, voc√™ obtenha EXATAMENTE a tabela original, sem criar linhas "fantasmas" (esp√∫rias). üí° **Dica:** 5FN = Jun√ß√£o sem perdas e sem fantasmas. (Cap√≠tulo 2, p. 91, 93)                                                                                                                                                                                                                                                                                                                                                     |
| 69  | Ao mapear um relacionamento de cardinalidade Muitos-para-Muitos (N:M) de um modelo ER para um modelo relacional, a regra R3 (network-like relationship sets) exige a cria√ß√£o de uma tabela de jun√ß√£o (associativa) separada.                                                                                                                                                                                                                                                                                                         | V        | üë®‚Äçüè´ Correto! Um relacionamento N:M (complexo-complexo) n√£o pode ser representado diretamente em tabelas relacionais sem criar redund√¢ncia ou anomalias. Por isso, criamos uma terceira tabela (tabela de jun√ß√£o ou associativa) que cont√©m as chaves prim√°rias das duas tabelas originais como chaves estrangeiras. üí° **Dica:** N:M = Tabela no meio! (Cap√≠tulo 2, p. 99)                                                                                                                                                                                                                                                                                                                                                 |
| 70  | A integridade referencial em bancos de dados relacionais, garantida por chaves estrangeiras, assegura que o valor de uma chave estrangeira em uma tabela sempre corresponda a um valor de chave prim√°ria existente na tabela referenciada.                                                                                                                                                                                                                                                                                           | V        | üë®‚Äçüè´ Perfeito! √â como garantir que todo "endere√ßo" (chave estrangeira) em uma lista de correspond√™ncias realmente aponte para uma "casa" (chave prim√°ria) que existe. Se a casa n√£o existe, a carta n√£o pode ser enviada para l√°. üí° **Dica:** Chave estrangeira = Ponteiro para uma chave prim√°ria v√°lida. (Cap√≠tulo 2, p. 109)                                                                                                                                                                                                                                                                                                                                                                                            |
| 71  | Em um modelo de grafo, a an√°lise de centralidade de "betweenness" (intermedia√ß√£o) de um n√≥ mede o n√∫mero de conex√µes diretas que este n√≥ possui, sendo um indicador de sua popularidade imediata na rede.                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ Centralidade de "betweenness" mede quantas vezes um n√≥ est√° no CAMINHO MAIS CURTO entre outros dois n√≥s na rede üö∂‚Äç‚ôÇÔ∏è--üî¥--üö∂‚Äç‚ôÄÔ∏è. √â sobre ser um "conector" ou "ponte". O n√∫mero de conex√µes diretas √© a centralidade de "degree" (grau). üí° **Dica:** Degree = Popularidade direta. Betweenness = Import√¢ncia como intermedi√°rio. (Cap√≠tulo 2, p. 124)                                                                                                                                                                                                                                                                                                                                                                |
| 72  | O algoritmo de Dijkstra √© utilizado para encontrar o ciclo Euleriano em um grafo ponderado, garantindo que cada aresta seja visitada exatamente uma vez com o menor custo total.                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ O algoritmo de Dijkstra encontra o CAMINHO MAIS CURTO üó∫Ô∏è entre um n√≥ de origem e todos os outros n√≥s em um grafo ponderado. Ciclos Eulerianos (visitar cada aresta uma vez) s√£o outra classe de problema (relacionado ao problema das Pontes de K√∂nigsberg). üí° **Dica:** Dijkstra = Caminho mais curto. Euler = Todas as arestas uma vez. (Cap√≠tulo 2, p. 114-115)                                                                                                                                                                                                                                                                                                                                                   |
| 73  | Uma linguagem de banco de dados √© considerada "relacionalmente completa" se ela consegue expressar, no m√≠nimo, as opera√ß√µes de uni√£o, diferen√ßa, produto cartesiano, proje√ß√£o e sele√ß√£o da √°lgebra relacional.                                                                                                                                                                                                                                                                                                                       | V        | üë®‚Äçüè´ Isso mesmo! Essas cinco opera√ß√µes formam o "kit b√°sico" da √°lgebra relacional. Se uma linguagem de consulta consegue fazer pelo menos isso, ela tem o poder expressivo fundamental para manipular dados relacionais. Outras opera√ß√µes (como interse√ß√£o e jun√ß√£o) podem ser derivadas dessas. üí° **Dica:** Lembre dos 5 magn√≠ficos da completude relacional. (Cap√≠tulo 3, p. 175)                                                                                                                                                                                                                                                                                                                                       |
| 74  | A cl√°usula `GROUP BY` em SQL √© utilizada exclusivamente para ordenar o resultado de uma consulta, de forma similar √† cl√°usula `ORDER BY`, mas com foco em atributos num√©ricos.                                                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ `GROUP BY` serve para AGRUPAR linhas que t√™m os mesmos valores em uma ou mais colunas, para que voc√™ possa aplicar fun√ß√µes de agrega√ß√£o (como `COUNT()`, `SUM()`, `AVG()`) a cada grupo. `ORDER BY` √© quem ordena o resultado final. üí° **Dica:** `GROUP BY` = Formar times. `ORDER BY` = Colocar na fila. (Cap√≠tulo 3, n√£o explicitamente detalhado, mas impl√≠cito no uso de fun√ß√µes agregadas que geralmente acompanham `GROUP BY`; SQL geral)                                                                                                                                                                                                                                                                       |
| 75  | A utiliza√ß√£o de Common Table Expressions (CTEs) em SQL, introduzidas com o `WITH` recursivo, permite a defini√ß√£o de consultas recursivas, como a travessia de hierarquias ou grafos, de forma mais leg√≠vel e eficiente que subconsultas correlacionadas complexas.                                                                                                                                                                                                                                                                   | V        | üë®‚Äçüè´ Sim! CTEs, especialmente as recursivas, s√£o uma ferramenta poderosa para lidar com estruturas hier√°rquicas (ex: organogramas, listas de materiais) ou caminhos em grafos. Elas quebram problemas complexos em partes menores e mais gerenci√°veis, e a recurs√£o permite "andar" pela estrutura. üí° **Dica:** CTE recursiva = Navegando em √°rvores e grafos com SQL. (Cap√≠tulo 3, p. 185)                                                                                                                                                                                                                                                                                                                                |
| 76  | O padr√£o JDBC (Java Database Connectivity) define uma API espec√≠fica para cada fabricante de banco de dados SQL, exigindo que o desenvolvedor Java utilize bibliotecas distintas e c√≥digo adaptado para cada SGBD.                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ O JDBC define uma API **UNIFICADA** (um conjunto padr√£o de classes e interfaces Java) para acessar bancos de dados. O desenvolvedor usa essa API padr√£o. A "m√°gica" da conex√£o com um SGBD espec√≠fico (MySQL, Oracle, etc.) √© feita pelo DRIVER JDBC daquele fabricante, que implementa essa API padr√£o. üí° **Dica:** JDBC = Uma interface Java para (quase) todos os BDs SQL. (Cap√≠tulo 3, p. 194)                                                                                                                                                                                                                                                                                                                    |
| 77  | Stored Procedures e Stored Functions em SQL s√£o blocos de c√≥digo SQL que s√£o compilados e armazenados no cliente, sendo executados localmente pela aplica√ß√£o para reduzir a carga no servidor de banco de dados.                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Stored Procedures/Functions s√£o armazenadas NO SERVIDOR de banco de dados! üè¶ Elas s√£o executadas l√°, o que pode reduzir o tr√°fego de rede (envia-se s√≥ a chamada, n√£o o c√≥digo todo) e permitir o reuso de l√≥gica de neg√≥cios complexa diretamente no BD. üí° **Dica:** "Stored" = Armazenado no servidor. (Cap√≠tulo 3, p. 193)                                                                                                                                                                                                                                                                                                                                                                                        |
| 78  | A presen√ßa de valores NULL em uma coluna utilizada em uma condi√ß√£o da cl√°usula `WHERE` (ex: `coluna = 10`) far√° com que as linhas onde `coluna` √© NULL sejam inclu√≠das no resultado se a condi√ß√£o for negada (ex: `NOT (coluna = 10)`).                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ L√≥gica de tr√™s valores (TRUE, FALSE, UNKNOWN)! NULL n√£o √© igual a nada, nem diferente de nada. `NULL = 10` √© UNKNOWN. `NOT (UNKNOWN)` tamb√©m √© UNKNOWN. Linhas com UNKNOWN na condi√ß√£o `WHERE` s√£o geralmente exclu√≠das, a menos que voc√™ use `IS NULL` ou `IS NOT NULL`. üí° **Dica:** NULL √© um buraco negro para compara√ß√µes diretas. Use `IS NULL` / `IS NOT NULL`. (Cap√≠tulo 3, p. 197-199)                                                                                                                                                                                                                                                                                                                        |
| 79  | Em um sistema de banco de dados que adota o n√≠vel de isolamento SERIALIZABLE, o fen√¥meno de "leitura fantasma" (phantom read) pode ocorrer, onde uma transa√ß√£o rel√™ dados e encontra linhas adicionais que foram inseridas por outra transa√ß√£o comitada.                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ O n√≠vel SERIALIZABLE √© o mais forte e foi projetado para PREVENIR todos os fen√¥menos de concorr√™ncia, incluindo leituras fantasmas, leituras n√£o repet√≠veis e leituras sujas. Ele garante que as transa√ß√µes se comportem como se fossem executadas serialmente. Leituras fantasmas podem ocorrer em n√≠veis mais baixos, como REPEATABLE READ. üí° **Dica:** SERIALIZABLE = Sem surpresas, sem fantasmas! (Cap√≠tulo 4, p. 219)                                                                                                                                                                                                                                                                                           |
| 80  | O Two-Phase Locking (2PL) garante a serializabilidade, mas n√£o previne deadlocks (impasses), que podem ocorrer quando duas ou more transa√ß√µes se bloqueiam mutuamente esperando por recursos.                                                                                                                                                                                                                                                                                                                                        | V        | üë®‚Äçüè´ Correto. O 2PL √© √≥timo para garantir a serializabilidade (a ordem correta das coisas). No entanto, ele n√£o √© imune a deadlocks. Se a Transa√ß√£o A bloqueia o Recurso X e espera pelo Y, e a Transa√ß√£o B bloqueia o Y e espera pelo X, elas ficam num abra√ßo mortal! Íª¥ÏïàÎã§ SGBDs t√™m mecanismos para detectar e resolver deadlocks (geralmente abortando uma das transa√ß√µes). üí° **Dica:** 2PL = Serializ√°vel, mas cuidado com o abra√ßo do deadlock! (Cap√≠tulo 4, p. 224, 226)                                                                                                                                                                                                                                             |
| 81  | A t√©cnica de "timestamp ordering" para controle de concorr√™ncia atribui um timestamp √∫nico a cada transa√ß√£o e garante a serializabilidade ao processar opera√ß√µes conflitantes de acordo com a ordem dos timestamps, prevenindo deadlocks.                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Isso mesmo! Com timestamps, cada transa√ß√£o "sabe sua idade". Se uma transa√ß√£o mais nova tenta acessar um dado de forma que conflitaria com uma mais velha que j√° o acessou, a mais nova pode ser abortada e reiniciada (ou esperar). Como n√£o h√° espera m√∫tua por bloqueios, deadlocks s√£o prevenidos. üí° **Dica:** Timestamp = Sem espera, sem deadlock (mas pode ter rollback). (Cap√≠tulo 4, p. 228)                                                                                                                                                                                                                                                                                                                 |
| 82  | A principal diferen√ßa entre checkpoints baseados em comando e checkpoints baseados em evento √© que os primeiros s√£o iniciados pela aplica√ß√£o, enquanto os segundos s√£o disparados automaticamente pelo SGBD em intervalos fixos de tempo.                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ Checkpoints baseados em comando s√£o, de fato, iniciados pela aplica√ß√£o (ou DBA). Checkpoints baseados em evento s√£o disparados por ocorr√™ncias espec√≠ficas no sistema (ex: log cheio, n√∫mero X de transa√ß√µes), n√£o necessariamente em intervalos fixos de tempo (isso seria mais um checkpoint baseado em tempo). O livro menciona "comandos na aplica√ß√£o ou certos eventos do sistema". üí° **Dica:** A trigger do checkpoint pode variar. (Cap√≠tulo 4, p. 231)                                                                                                                                                                                                                                                        |
| 83  | Em um cen√°rio de consist√™ncia por quorum (W+R > N) em sistemas distribu√≠dos, √© garantido que uma opera√ß√£o de leitura sempre acessar√° a vers√£o mais recente de um dado, mesmo que algumas r√©plicas estejam desatualizadas.                                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Sim! Se a soma do n√∫mero de r√©plicas que precisam confirmar uma escrita (W) com o n√∫mero de r√©plicas que precisam ser lidas para uma leitura bem-sucedida (R) for maior que o n√∫mero total de r√©plicas (N), ent√£o os conjuntos de escrita e leitura DEVEM se sobrepor em pelo menos uma r√©plica. Isso garante que a leitura veja pelo menos uma c√≥pia que participou da escrita mais recente (ou a pr√≥pria escrita mais recente). üí° **Dica:** W+R > N = Leitura e escrita se encontram! (Cap√≠tulo 4, p. 236-237)                                                                                                                                                                                                      |
| 84  | Rel√≥gios vetoriais (Vector Clocks) s√£o usados em sistemas distribu√≠dos para sincronizar o tempo absoluto entre diferentes n√≥s, permitindo determinar a ordem cronol√≥gica exata de todos os eventos na rede.                                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ Rel√≥gios vetoriais n√£o medem o tempo absoluto (como um rel√≥gio de parede ‚è∞). Eles ajudam a determinar a ORDEM CAUSAL PARCIAL entre eventos. Eles podem dizer se o evento A *poderia* ter causado o evento B, ou se s√£o concorrentes, mas n√£o d√£o a hora exata. Cada processo mant√©m um vetor de contadores l√≥gicos. üí° **Dica:** Vector Clock = Causa e Efeito, n√£o Hora Certa. (Cap√≠tulo 4, p. 237)                                                                                                                                                                                                                                                                                                                   |
| 85  | A otimiza√ß√£o alg√©brica de consultas relacionais busca reordenar as opera√ß√µes da √°lgebra relacional (ex: empurrar sele√ß√µes para baixo na √°rvore de consulta) para reduzir o tamanho dos resultados intermedi√°rios e o custo computacional.                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Exatamente! √â como planejar uma receita üßë‚Äçüç≥: voc√™ quer fazer os passos que reduzem mais o volume de ingredientes (sele√ß√µes, proje√ß√µes) o mais cedo poss√≠vel, antes de misturar tudo (jun√ß√µes, que s√£o caras). Isso torna o processo todo mais eficiente. üí° **Dica:** Otimiza√ß√£o alg√©brica = Fazer menos trabalho pesado. (Cap√≠tulo 5, p. 270, 272)                                                                                                                                                                                                                                                                                                                                                                  |
| 86  | O custo de uma opera√ß√£o de jun√ß√£o aninhada (nested loop join) entre duas tabelas R e S, sem √≠ndices, √© linear em rela√ß√£o ao n√∫mero de tuplas de R mais o n√∫mero de tuplas de S (n+m).                                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ Sem √≠ndices, uma jun√ß√£o aninhada compara CADA tupla de R com CADA tupla de S. Se R tem 'n' tuplas e S tem 'm' tuplas, o custo √© da ordem de n * m (quadr√°tico), n√£o n + m (linear). √â como verificar cada pessoa de uma sala com cada pessoa de outra sala. üí° **Dica:** Nested loop sem √≠ndice = For√ßa bruta, custo alto (n*m). (Cap√≠tulo 5, p. 273)                                                                                                                                                                                                                                                                                                                                                                  |
| 87  | A t√©cnica de "consistent hashing" √© projetada para garantir que, em um sistema distribu√≠do, todos os n√≥s da rede sempre contenham uma r√©plica completa de todos os objetos de dados, eliminando a necessidade de sharding.                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ Consistent hashing √© usado justamente para DISTRIBUIR (shard) os dados entre os n√≥s de forma eficiente e minimizar o remapeamento quando n√≥s entram ou saem. Ele N√ÉO implica que todos os n√≥s tenham tudo. Ele ajuda a decidir QUAL n√≥ guarda QUAL parte dos dados. üí° **Dica:** Consistent hashing = Distribui√ß√£o inteligente, n√£o replica√ß√£o total. (Cap√≠tulo 5, p. 259)                                                                                                                                                                                                                                                                                                                                             |
| 88  | Na arquitetura de SGBD em camadas, a "Layer 3: Storage and access structures" √© respons√°vel pela aloca√ß√£o de blocos f√≠sicos no meio de armazenamento e pelo gerenciamento de arquivos do sistema operacional.                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ A Camada 3 lida com a implementa√ß√£o de registros f√≠sicos e caminhos de acesso em P√ÅGINAS (ex: √°rvores B, hashing em p√°ginas). A aloca√ß√£o de blocos f√≠sicos e gerenciamento de arquivos √© mais abaixo, na Camada 5 (Memory allocation) e Camada 4 (Page assignment). üí° **Dica:** Pense na hierarquia: Usu√°rio -> SQL -> Registros L√≥gicos -> Registros em P√°ginas -> P√°ginas em Blocos -> Blocos em Disco. (Cap√≠tulo 5, p. 282-283)                                                                                                                                                                                                                                                                                    |
| 89  | O paradigma REST (Representational State Transfer) para servi√ßos web exige que todas as intera√ß√µes entre cliente e servidor mantenham um estado de sess√£o compartilhado para otimizar o desempenho.                                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ Uma caracter√≠stica fundamental do REST √© ser **STATELESS** (sem estado). Cada requisi√ß√£o do cliente para o servidor deve conter toda a informa√ß√£o necess√°ria para o servidor entend√™-la, sem depender de um contexto de sess√£o armazenado no servidor. Isso melhora a escalabilidade. üí° **Dica:** REST = Sem mem√≥ria de sess√£o no servidor. (Cap√≠tulo 5, p. 286)                                                                                                                                                                                                                                                                                                                                                      |
| 90  | Em um Data Stream, a ordena√ß√£o cronol√≥gica dos registros √© opcional e geralmente determinada pela aplica√ß√£o cliente, n√£o sendo uma caracter√≠stica inerente ao fluxo de dados em si.                                                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ A ordena√ß√£o cronol√≥gica (geralmente com timestamps) √© uma caracter√≠stica FUNDAMENTAL de um Data Stream. Os dados fluem continuamente e a ordem em que chegam (ou s√£o marcados com tempo) √© crucial para muitas an√°lises. üí° **Dica:** Stream = Rio de dados ordenados no tempo. (Cap√≠tulo 5, p. 249)                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 91  | A fragmenta√ß√£o vertical em bancos de dados distribu√≠dos consiste em dividir as tuplas de uma tabela em subconjuntos armazenados em diferentes n√≥s, mantendo todas as colunas em cada fragmento.                                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ Fragmenta√ß√£o vertical √© sobre dividir as COLUNAS de uma tabela. Voc√™ pega algumas colunas e a chave prim√°ria e coloca em um fragmento, e outras colunas com a chave prim√°ria em outro. Dividir as LINHAS (tuplas) mantendo todas as colunas √© fragmenta√ß√£o HORIZONTAL. üí° **Dica:** Vertical = Corte nas colunas (V). Horizontal = Corte nas linhas (H). (Cap√≠tulo 6, p. 297)                                                                                                                                                                                                                                                                                                                                          |
| 92  | A linguagem TSQL2, uma extens√£o do SQL para bancos de dados temporais, introduz constru√ß√µes para consultar dados baseando-se no "tempo de validade" e no "tempo de transa√ß√£o", permitindo reconstruir estados passados do banco.                                                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Sim, TSQL2 (e outros padr√µes temporais) adicionam essa capacidade de "viajar no tempo" üï∞Ô∏è ao SQL, permitindo consultas que consideram quando um dado era v√°lido no mundo real e quando ele foi registrado/alterado no banco. Isso √© essencial para auditoria, versionamento, etc. üí° **Dica:** Banco Temporal = Hist√≥rico completo, n√£o s√≥ o "agora". (Cap√≠tulo 6, p. 333, embora o livro mencione TSQL2 brevemente, o conceito de consultar tempo de validade/transa√ß√£o √© central, p. 300, 302-303)                                                                                                                                                                                                                  |
| 93  | Em um Data Warehouse, os "Data Marts" s√£o geralmente c√≥pias completas e redundantes do Core DWH, servindo apenas como backups para fins de recupera√ß√£o de desastres.                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ Data Marts s√£o subconjuntos do Data Warehouse, focados em √°reas de neg√≥cio espec√≠ficas (ex: Vendas, Marketing, RH) üéØ. Eles cont√™m dados agregados e sumarizados do Core DWH, otimizados para as an√°lises daquele departamento. N√£o s√£o backups completos. üí° **Dica:** Data Mart = Mini-DWH departamental. (Cap√≠tulo 6, p. 311-312)                                                                                                                                                                                                                                                                                                                                                                                   |
| 94  | A utiliza√ß√£o de "surrogates" (chaves substitutas) em bancos de dados objeto-relacionais ajuda a manter a integridade referencial e a estabilidade das refer√™ncias, mesmo quando os valores de chaves naturais dos objetos mudam.                                                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Perfeito! Uma surrogate key √© um identificador artificial (geralmente um n√∫mero sequencial) que n√£o tem significado de neg√≥cio. Se a "chave natural" (ex: CPF, nome do produto) mudar, a surrogate key permanece a mesma, e todas as refer√™ncias a ela continuam v√°lidas. Isso desacopla a identidade do objeto de seus atributos mut√°veis. üí° **Dica:** Surrogate = ID interno est√°vel. (Cap√≠tulo 6, p. 315)                                                                                                                                                                                                                                                                                                          |
| 95  | A principal limita√ß√£o dos bancos de dados relacionais cl√°ssicos que motivou o desenvolvimento de bancos objeto-relacionais e orientados a objetos √© a sua incapacidade de armazenar dados textuais longos ou bin√°rios.                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ Bancos relacionais podem armazenar dados textuais longos (CLOBs) e bin√°rios (BLOBs) h√° muito tempo. A motiva√ß√£o principal para ORDBMS e OODBMS foi melhor modelar objetos complexos do mundo real, com seus comportamentos (m√©todos) e relacionamentos intrincados (heran√ßa, agrega√ß√£o), o que o modelo relacional puro faz de forma menos direta (impedance mismatch). üí° **Dica:** ORDBMS/OODBMS = Melhor encaixe com programa√ß√£o OO e objetos complexos. (Cap√≠tulo 6, p. 315-316)                                                                                                                                                                                                                                   |
| 96  | A infer√™ncia recursiva em um banco de dados dedutivo, como a determina√ß√£o da rela√ß√£o "√©_ancestral_de", pode ser sempre calculada com um n√∫mero fixo e predeterminado de opera√ß√µes de jun√ß√£o da √°lgebra relacional.                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ A beleza (e complexidade) da recurs√£o √© que o n√∫mero de "passos" (jun√ß√µes, uni√µes) para calcular um fechamento transitivo (como "√© ancestral de") depende do PR√ìPRIO DADO. Se a "√°rvore geneal√≥gica" √© profunda, mais passos s√£o necess√°rios. N√£o √© um n√∫mero fixo. √Ålgebra relacional pura n√£o lida bem com isso; linguagens dedutivas (como Datalog) estendem-na. üí° **Dica:** Recurs√£o = O n√∫mero de voltas depende do caminho. (Cap√≠tulo 6, p. 324)                                                                                                                                                                                                                                                                |
| 97  | A "index-free adjacency" em bancos de dados orientados a grafos significa que a travessia de um n√≥ para seus vizinhos diretos tem um custo computacional que √© largamente independente do tamanho total do grafo, mas dependente do n√∫mero de vizinhos.                                                                                                                                                                                                                                                                              | V        | üë®‚Äçüè´ Exato! Em um banco de grafos, cada n√≥ "sabe" quem s√£o seus vizinhos diretos (como se tivesse uma lista de endere√ßos deles). Para ir de A para B (se B √© vizinho de A), voc√™ n√£o precisa procurar em um √≠ndice global. O custo √© O(grau do n√≥), n√£o O(tamanho do grafo). üí° **Dica:** Adjac√™ncia sem √≠ndice = Vizinhos na discagem r√°pida. (Cap√≠tulo 7, p. 366)                                                                                                                                                                                                                                                                                                                                                         |
| 98  | Document stores como CouchDB utilizam o protocolo MapReduce para consultas agregadas. A fun√ß√£o `map` √© executada uma vez para todo o conjunto de dados, enquanto a fun√ß√£o `reduce` √© aplicada iterativamente a cada documento individualmente.                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ A fun√ß√£o `map` √© aplicada a CADA DOCUMENTO individualmente (ou a um subconjunto, dependendo da consulta). Ela emite pares chave-valor. A fun√ß√£o `reduce` (que √© opcional) ent√£o pega os valores AGRUPADOS PELA MESMA CHAVE (emitidos por v√°rios `map`s) e os combina. üí° **Dica:** Map = Para cada um. Reduce = Para cada grupo de chaves iguais. (Cap√≠tulo 7, p. 355-356)                                                                                                                                                                                                                                                                                                                                             |
| 99  | A linguagem XQuery, usada para consultar documentos XML, √© puramente navegacional e n√£o permite a constru√ß√£o de novas estruturas XML como resultado de uma consulta.                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ XQuery √© poderosa! Ela n√£o s√≥ navega (como XPath), mas tamb√©m pode TRANSFORMAR e CONSTRUIR novos documentos ou fragmentos XML. Voc√™ pode selecionar partes, reorganiz√°-las, adicionar novos elementos, etc., tudo dentro da consulta. üí° **Dica:** XQuery = XPath para achar + XML para construir. (Cap√≠tulo 7, p. 360)                                                                                                                                                                                                                                                                                                                                                                                                |
| 100 | A principal motiva√ß√£o para o desenvolvimento de bancos de dados XML nativos foi a necessidade de armazenar dados XML de forma mais eficiente e consult√°-los com linguagens espec√≠ficas como XQuery, superando limita√ß√µes de mape√°-los para estruturas relacionais.                                                                                                                                                                                                                                                                   | V        | üë®‚Äçüè´ Sim! Embora bancos relacionais possam armazenar XML (ex: em colunas XMLType), mapear estruturas XML complexas e hier√°rquicas para tabelas relacionais pode ser complicado e ineficiente (o "shredding"). Bancos XML nativos s√£o projetados para entender e otimizar o armazenamento e a consulta de XML em seu formato "natural". üí° **Dica:** XML Nativo = XML se sentindo em casa. (Cap√≠tulo 7, p. 361)                                                                                                                                                                                                                                                                                                              |
| 101 | Em column-family stores como Bigtable, o timestamp associado a cada c√©lula de dados serve primariamente para ordena√ß√£o dos resultados da consulta, n√£o tendo rela√ß√£o com versionamento ou hist√≥rico de dados.                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ O timestamp no Bigtable (e similares) √© crucial para VERSIONAMENTO! Ele permite que m√∫ltiplas vers√µes de um valor para uma mesma c√©lula (linha, coluna) sejam armazenadas, cada uma com seu timestamp. Consultas podem ent√£o pedir a vers√£o mais recente, ou uma vers√£o de um tempo espec√≠fico. üí° **Dica:** Timestamp em Column-Family = M√°quina do tempo para seus dados. (Cap√≠tulo 7, p. 350)                                                                                                                                                                                                                                                                                                                       |
| 102 | A escolha entre diferentes modelos NoSQL (chave-valor, documento, coluna, grafo) para uma aplica√ß√£o depende primariamente do volume de dados a ser armazenado, sendo modelos mais complexos como grafos sempre prefer√≠veis para grandes volumes.                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ A escolha do modelo NoSQL depende da ESTRUTURA DOS DADOS, dos PADR√ïES DE ACESSO e dos REQUISITOS da aplica√ß√£o, n√£o s√≥ do volume. Grafos s√£o √≥timos para dados interconectados, mas podem ser overkill (e menos perform√°ticos para certas tarefas) do que um simples chave-valor para caching, mesmo com grandes volumes. üí° **Dica:** N√£o existe "bala de prata" NoSQL. Escolha a ferramenta certa para o trabalho. (Cap√≠tulo 7, p. 344 e discuss√µes dos modelos)                                                                                                                                                                                                                                                      |
| 103 | A aus√™ncia de um esquema r√≠gido em muitos bancos NoSQL (schema-less ou schema-on-read) transfere a responsabilidade pela interpreta√ß√£o e valida√ß√£o da estrutura dos dados do SGBD para a aplica√ß√£o cliente.                                                                                                                                                                                                                                                                                                                          | V        | üë®‚Äçüè´ Exatamente. Se o banco n√£o imp√µe um esquema na escrita (schema-on-write, como nos relacionais), ent√£o quando a aplica√ß√£o l√™ os dados (schema-on-read), ela precisa "saber" o que esperar ou como lidar com varia√ß√µes na estrutura. A flexibilidade tem esse "custo" de responsabilidade na aplica√ß√£o. üí° **Dica:** Schema-less = "Se vira a√≠, aplica√ß√£o!". (Cap√≠tulo 7, p. 345, 353)                                                                                                                                                                                                                                                                                                                                   |
| 104 | A replica√ß√£o de dados em bancos de dados NoSQL distribu√≠dos √© utilizada exclusivamente para fins de backup e recupera√ß√£o de desastres, n√£o contribuindo para a melhoria da disponibilidade ou do desempenho de leitura.                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ A replica√ß√£o em NoSQL √© multifuncional! Al√©m de backup, ela √© CRUCIAL para ALTA DISPONIBILIDADE (se um n√≥ cai, outros t√™m os dados) e para ESCALAR LEITURAS (requisi√ß√µes de leitura podem ser distribu√≠das entre as r√©plicas, melhorando o desempenho). üí° **Dica:** R√©plicas = Mais seguran√ßa, mais disponibilidade, leituras mais r√°pidas. (Cap√≠tulo 7, p. 347, 368 - clustering e replica√ß√£o no Redis)                                                                                                                                                                                                                                                                                                              |
| 105 | O teorema CAP implica que um banco de dados NoSQL que prioriza Alta Disponibilidade (A) e Toler√¢ncia a Parti√ß√µes (P) deve, obrigatoriamente, sacrificar completamente a Consist√™ncia (C), operando sempre com dados potencialmente inconsistentes.                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ N√£o "completamente"! Ele pode operar com CONSIST√äNCIA EVENTUAL (BASE). Os dados se tornar√£o consistentes "eventualmente", mas pode haver um atraso. N√£o √© um abandono total da consist√™ncia, mas um relaxamento da consist√™ncia forte e imediata do ACID. üí° **Dica:** AP no CAP = Provavelmente consist√™ncia eventual, n√£o caos total. (Cap√≠tulo 4, p. 233-234; Cap√≠tulo 7, p. 344)                                                                                                                                                                                                                                                                                                                                   |
| 106 | Bancos de dados orientados a grafos s√£o particularmente adequados para modelar e consultar dados onde os relacionamentos entre as entidades s√£o t√£o ou mais importantes que as pr√≥prias entidades.                                                                                                                                                                                                                                                                                                                                   | V        | üë®‚Äçüè´ Perfeito! Se a sua pergunta √© "Quem est√° conectado com quem, e como?", um banco de grafos brilha ‚ú®. Redes sociais, sistemas de recomenda√ß√£o, detec√ß√£o de fraude, onde as conex√µes s√£o a chave, s√£o casos de uso ideais. üí° **Dica:** Grafos = Foco nos relacionamentos. (Cap√≠tulo 7, p. 364, 366)                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 107 | A linguagem de consulta GraphQL, embora utilize conceitos de grafos, √© uma alternativa ao SQL para bancos de dados relacionais, n√£o sendo projetada para interagir com bancos de dados NoSQL nativos de grafos.                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ GraphQL √© uma linguagem de consulta para APIs, frequentemente usada como uma camada sobre diversos backends, que PODEM incluir bancos de grafos, mas tamb√©m relacionais, NoSQL diversos, ou microsservi√ßos. Ela permite que o cliente pe√ßa exatamente os dados que precisa, numa estrutura de grafo, mas n√£o √© uma linguagem de consulta *direta* para um banco de grafos nativo como Cypher √© para Neo4j. O livro menciona GraphQL em He e Singh (2010) como "baseada em √°lgebra de grafos e igualmente poderosa que √°lgebra relacional" (Cap√≠tulo 3, p. 212). A afirma√ß√£o √© sutilmente falsa ao dizer que N√ÉO √© projetada para interagir com BDs de grafos, pois ela *pode* ser uma camada sobre eles.               |
| 108 | A complexidade do sharding (fragmenta√ß√£o) em bancos de dados orientados a grafos √© significativamente menor do que em bancos chave-valor, devido √† natureza intrinsecamente conectada dos dados em grafos.                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ √â o contr√°rio! Sharding de grafos √© MUITO MAIS COMPLEXO ü§Ø. Justamente porque os dados s√£o interconectados, dividir um grafo em peda√ßos que fiquem em m√°quinas diferentes, minimizando as "arestas cortadas" (relacionamentos entre shards), √© um problem√£o (NP-completo). Em chave-valor, as chaves s√£o independentes, facilitando a divis√£o. üí° **Dica:** Sharding de grafo = Quebra-cabe√ßa dif√≠cil. (Cap√≠tulo 7, p. 366-367)                                                                                                                                                                                                                                                                                        |
| 109 | Document stores que utilizam JSON como formato de documento permitem o aninhamento de objetos e arrays dentro de um documento, possibilitando a representa√ß√£o de estruturas de dados hier√°rquicas complexas em um √∫nico registro.                                                                                                                                                                                                                                                                                                    | V        | üë®‚Äçüè´ Sim! Essa √© uma grande for√ßa do JSON (e dos bancos de documento que o usam). Voc√™ pode ter um documento "Cliente" que dentro dele tem um objeto "Endere√ßo" e um array de "Pedidos", cada pedido com seus itens. Tudo junto, bonitinho, sem precisar de m√∫ltiplas tabelas e joins para buscar. üí° **Dica:** JSON em Document Store = Ninhos de dados dentro de ninhos. (Cap√≠tulo 7, p. 353)                                                                                                                                                                                                                                                                                                                             |
| 110 | Apesar da flexibilidade de esquema, os bancos de dados NoSQL geralmente oferecem mecanismos de seguran√ßa de acesso e autoriza√ß√£o de usu√°rios t√£o robustos e granulares quanto os encontrados em sistemas SQL tradicionais (GRANT/REVOKE).                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ Geralmente, n√£o. Muitos sistemas NoSQL t√™m modelos de seguran√ßa mais simples, focados em autentica√ß√£o no n√≠vel do banco ou da cole√ß√£o/fam√≠lia de colunas, mas n√£o com a granularidade de permiss√µes por tabela, coluna e opera√ß√£o que o `GRANT`/`REVOKE` do SQL oferece. A seguran√ßa muitas vezes √© delegada para camadas da aplica√ß√£o. üí° **Dica:** NoSQL = Seguran√ßa pode ser mais "simplificada" (ou um desafio extra). (Cap√≠tulo 3, p. 209, comparando com Cypher; Cap√≠tulo 7 em geral)                                                                                                                                                                                                                            |
| 111 | Bancos de dados NoSQL surgiram como uma alternativa aos bancos relacionais, oferecendo diferentes modelos de dados para lidar com desafios como grandes volumes de dados (Big Data) e necessidade de alta escalabilidade.                                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Exato! Pense nos bancos relacionais como canivetes su√≠√ßos üá®üá≠, √≥timos para muitas coisas. Mas para tarefas muito espec√≠ficas ou gigantescas (como lidar com o dil√∫vio de dados da internet), √†s vezes voc√™ precisa de uma ferramenta especializada. NoSQL trouxe essas ferramentas, cada uma boa para um tipo de problema. üí° **Dica:** NoSQL = Novas ferramentas para novos desafios. (Cap√≠tulo 7, p. 343)                                                                                                                                                                                                                                                                                                           |
| 112 | A propriedade de "schema-less" ou "schema-flexible" comum em muitos bancos NoSQL significa que os dados podem ser inseridos sem uma estrutura predefinida r√≠gida, permitindo que a estrutura evolua com o tempo ou varie entre os registros.                                                                                                                                                                                                                                                                                         | V        | üë®‚Äçüè´ Isso mesmo! √â como ter uma gaveta m√°gica ü™Ñ onde voc√™ pode guardar coisas de formatos diferentes sem ter que definir divis√≥rias fixas antes. Se hoje voc√™ guarda uma bola ‚öΩ, amanh√£ um livro üìñ, a gaveta se adapta. Nos relacionais, voc√™ precisa definir as "divis√≥rias" (colunas e tipos) antes. üí° **Dica:** Schema-less = Flexibilidade na estrutura. (Cap√≠tulo 7, p. 344, 345)                                                                                                                                                                                                                                                                                                                                   |
| 113 | Todos os bancos de dados NoSQL s√£o projetados para abandonar completamente o conceito de chaves para identificar dados, utilizando apenas buscas por conte√∫do completo para recupera√ß√£o de informa√ß√µes.                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ De jeito nenhum! üôÖ‚Äç‚ôÇÔ∏è Muitos NoSQL usam chaves extensivamente. Bancos chave-valor, por exemplo, s√£o *baseados* em chaves! Bancos de documento usam IDs de documento (chaves). O que eles podem abandonar ou flexibilizar √© o esquema relacional tradicional e a linguagem SQL. üí° **Dica:** Chaves s√£o amigas da organiza√ß√£o, mesmo no mundo NoSQL. (Cap√≠tulo 7, p. 344, 345)                                                                                                                                                                                                                                                                                                                                         |
| 114 | A escalabilidade horizontal (scale-out) √© uma caracter√≠stica frequentemente buscada em sistemas NoSQL, onde o desempenho e a capacidade s√£o aumentados pela adi√ß√£o de mais m√°quinas (n√≥s) ao cluster.                                                                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ Perfeito! Imagine que sua lojinha est√° bombando üìà. Em vez de comprar um balc√£o gigante e super caro (escalabilidade vertical/scale-up), voc√™ abre v√°rias lojinhas menores e interligadas (scale-out). Muitos NoSQL s√£o feitos para isso. üí° **Dica:** Scale-out = Mais m√°quinas, mais poder distribu√≠do. (Cap√≠tulo 7, p. 344)                                                                                                                                                                                                                                                                                                                                                                                         |
| 115 | O modelo de consist√™ncia ACID √© o padr√£o predominante em todos os tipos de bancos de dados NoSQL, garantindo transa√ß√µes at√¥micas, consistentes, isoladas e dur√°veis em qualquer cen√°rio.                                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ Muitos NoSQL (n√£o todos, mas muitos) relaxam as garantias ACID em favor do modelo BASE (Basically Available, Soft state, Eventually consistent) para ganhar em disponibilidade e toler√¢ncia a parti√ß√µes. ACID √© mais comum nos relacionais. üí° **Dica:** NoSQL frequentemente troca ACID forte por outros "superpoderes" como escalabilidade. (Cap√≠tulo 7, p. 344; Revis√£o Cap. 4)                                                                                                                                                                                                                                                                                                                                     |
| 116 | Bancos de dados Chave-Valor (Key-Value Stores) s√£o otimizados para consultas complexas que envolvem jun√ß√µes entre m√∫ltiplos valores ou buscas baseadas em intervalos de chaves.                                                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ Bancos chave-valor s√£o como um dicion√°rio super r√°pido: voc√™ d√° a palavra (chave) e ele te d√° o significado (valor). Simples e direto! Para consultas com muitas jun√ß√µes ou buscas por faixas complexas, eles n√£o s√£o a melhor pedida. üí° **Dica:** Chave-Valor = Buscas simples e r√°pidas por chave. (Cap√≠tulo 7, p. 345-346)                                                                                                                                                                                                                                                                                                                                                                                         |
| 117 | Em um banco de dados orientado a documentos (Document Store), um "documento" √© tipicamente uma cole√ß√£o de pares chave-valor, onde os valores podem ser simples ou estruturas aninhadas, como outros objetos ou listas.                                                                                                                                                                                                                                                                                                               | V        | üë®‚Äçüè´ Exatamente! Pense num documento JSON ou BSON. Voc√™ tem "campos" (chaves) e "valores". E esses valores podem ser desde um simples n√∫mero ou texto, at√© outro objeto inteiro (com seus pr√≥prios campos e valores) ou uma lista de coisas. √â como um formul√°rio bem flex√≠vel. üí° **Dica:** Documento = Estrutura aninhada e flex√≠vel. (Cap√≠tulo 7, p. 353)                                                                                                                                                                                                                                                                                                                                                                |
| 118 | A principal vantagem dos bancos de dados orientados a colunas (Column-Family Stores) √© sua capacidade de armazenar dados de forma desnormalizada, replicando a mesma informa√ß√£o em m√∫ltiplas colunas para acelerar a escrita.                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ Eles s√£o bons para leituras anal√≠ticas onde voc√™ acessa poucas colunas de muitas linhas. A organiza√ß√£o √© por coluna (ou fam√≠lia de colunas), o que torna eficiente buscar s√≥ as colunas de interesse. A replica√ß√£o de dados dentro de fam√≠lias n√£o √© o foco principal para acelerar escrita, mas sim otimizar leitura. üí° **Dica:** Column-Family = √ìtimo para pegar fatias verticais de dados. (Cap√≠tulo 7, p. 349-350)                                                                                                                                                                                                                                                                                               |
| 119 | Bancos de dados orientados a grafos (Graph Databases) s√£o especialmente adequados para modelar e consultar dados com muitos relacionamentos complexos e interconectados entre as entidades.                                                                                                                                                                                                                                                                                                                                          | V        | üë®‚Äçüè´ Sim! Se o seu problema parece uma teia de aranha üï∏Ô∏è (quem conhece quem, o que influencia o qu√™, qual o caminho mais curto), um banco de grafos √© seu amigo. Eles s√£o feitos para "passear" por esses relacionamentos de forma eficiente. üí° **Dica:** Grafo = Relacionamentos em primeiro lugar. (Cap√≠tulo 7, p. 364, 366)                                                                                                                                                                                                                                                                                                                                                                                            |
| 120 | "Persist√™ncia Poliglota" refere-se √† capacidade de um √∫nico banco de dados NoSQL suportar nativamente m√∫ltiplas linguagens de programa√ß√£o (como Java, Python, Ruby) para interagir com seus dados.                                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ Persist√™ncia Poliglota √© sobre usar **V√ÅRIOS TIPOS DE BANCOS DE DADOS** (ex: relacional + chave-valor + grafo) em uma mesma aplica√ß√£o, escolhendo o melhor banco para cada tipo de dado ou tarefa. N√£o √© sobre um √∫nico banco suportar v√°rias linguagens (a maioria dos BDs faz isso via drivers). üí° **Dica:** Poliglota (BDs) = Usar a ferramenta certa para cada parte do trabalho. (Cap√≠tulo 7, p. 344)                                                                                                                                                                                                                                                                                                            |
| 121 | Redis √© um exemplo popular de banco de dados chave-valor em mem√≥ria, frequentemente usado para caching, gerenciamento de sess√µes e como message broker, devido √† sua alta performance.                                                                                                                                                                                                                                                                                                                                               | V        | üë®‚Äçüè´ Correto! Redis √© o "Flash" ‚ö° dos bancos chave-valor. Por rodar em mem√≥ria, √© super r√°pido. Caching (guardar dados usados frequentemente para acesso r√°pido) e sess√µes de usu√°rio s√£o usos cl√°ssicos. üí° **Dica:** Redis = Velocidade em mem√≥ria. (Cap√≠tulo 7, men√ß√£o impl√≠cita no contexto de chave-valor e in-memory, p. 346; Redis especificamente, p. 368)                                                                                                                                                                                                                                                                                                                                                          |
| 122 | MongoDB, um banco de dados orientado a documentos, armazena dados em um formato bin√°rio chamado BSON (Binary JSON), que √© uma representa√ß√£o serializada de documentos JSON, oferecendo suporte a mais tipos de dados que o JSON puro.                                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ Isso mesmo! Pense no BSON como um "JSON turbinado" üí™. Ele √© bin√°rio (mais eficiente para o banco processar e armazenar) e suporta tipos de dados adicionais que o JSON textual n√£o tem (como datas de forma nativa, dados bin√°rios). üí° **Dica:** MongoDB + BSON = JSON com superpoderes. (Cap√≠tulo 7, p. 353 - JSON √© mencionado, BSON √© o formato interno do MongoDB)                                                                                                                                                                                                                                                                                                                                               |
| 123 | Cassandra, um banco de dados column-family, foi projetado com base nos princ√≠pios do DynamoDB da Amazon e do Bigtable do Google, visando alta disponibilidade e escalabilidade massiva sem um ponto √∫nico de falha.                                                                                                                                                                                                                                                                                                                  | V        | üë®‚Äçüè´ Perfeito! Cassandra pegou o melhor de dois mundos ü§ù: a arquitetura distribu√≠da e sem mestre (masterless) do DynamoDB e o modelo de dados column-family do Bigtable. O resultado √© um sistema robusto, altamente escal√°vel e resiliente a falhas. üí° **Dica:** Cassandra = Bigtable encontra DynamoDB. (Cap√≠tulo 7, p. 349 Bigtable; DynamoDB √© um sistema similar que influenciou Cassandra)                                                                                                                                                                                                                                                                                                                          |
| 124 | Neo4j, um banco de dados orientado a grafos, utiliza a linguagem Gremlin como sua principal interface de consulta para definir e atravessar os relacionamentos entre os n√≥s.                                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ Neo4j usa primariamente a linguagem **Cypher** para consultas. Cypher √© uma linguagem declarativa inspirada em SQL, mas com sintaxe para descrever padr√µes de grafos. Gremlin √© outra linguagem popular para travessia de grafos, usada por outros bancos de grafos (como Apache TinkerPop). üí° **Dica:** Neo4j = Cypher. (Cap√≠tulo 7, p. 364; Revis√£o Cap. 1, p. 45)                                                                                                                                                                                                                                                                                                                                                  |
| 125 | Em bancos de dados NoSQL, o sharding (fragmenta√ß√£o horizontal) √© a t√©cnica de dividir os dados em m√∫ltiplos n√≥s, e a replica√ß√£o √© a t√©cnica de criar c√≥pias desses shards em outros n√≥s para redund√¢ncia e disponibilidade.                                                                                                                                                                                                                                                                                                          | V        | üë®‚Äçüè´ Exatamente! Sharding √© como cortar uma pizza üçï em fatias (cada fatia/shard vai para um amigo/n√≥). Replica√ß√£o √© fazer c√≥pias dessas fatias e dar para outros amigos tamb√©m, caso o primeiro amigo suma com a fatia original (disponibilidade) ou para dividir o trabalho de servir (escalabilidade de leitura). üí° **Dica:** Sharding = Dividir. Replica√ß√£o = Copiar. (Cap√≠tulo 7, p. 346-347)                                                                                                                                                                                                                                                                                                                         |
| 126 | Bancos de dados XML nativos armazenam documentos XML como grandes strings de texto (BLOBs) em tabelas relacionais, utilizando fun√ß√µes SQL estendidas para parsear e consultar o conte√∫do XML.                                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ Bancos XML **nativos** s√£o projetados para entender a estrutura hier√°rquica do XML intimamente. Eles n√£o apenas guardam como um "text√£o". Eles podem indexar elementos internos, usar XQuery/XPath eficientemente. Armazenar como BLOB em relacional √© uma forma de "simular" suporte a XML, n√£o um BD XML nativo. üí° **Dica:** Nativo XML = Entende XML de verdade. (Cap√≠tulo 7, p. 361-362)                                                                                                                                                                                                                                                                                                                          |
| 127 | CouchDB, um banco de dados orientado a documentos, utiliza MapReduce para criar views (√≠ndices secund√°rios), onde a fun√ß√£o `map` emite pares chave-valor e a fun√ß√£o `reduce` (opcional) pode agregar esses valores.                                                                                                                                                                                                                                                                                                                  | V        | üë®‚Äçüè´ Correto! √â assim que CouchDB permite consultas eficientes al√©m da busca pela chave prim√°ria do documento. As views s√£o pr√©-calculadas (ou calculadas sob demanda e cacheadas) e funcionam como √≠ndices. üí° **Dica:** CouchDB Views = MapReduce para indexar. (Cap√≠tulo 7, p. 355-356, 368)                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 128 | Todos os bancos de dados NoSQL column-family seguem estritamente o modelo Bigtable, com tr√™s dimens√µes fixas (row:string, column:string, time:int64) e dados armazenados como strings.                                                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ O Bigtable √© um modelo influente, mas nem todos os column-family stores o seguem *estritamente* √† risca. Alguns podem ter varia√ß√µes no n√∫mero de dimens√µes "impl√≠citas", nos tipos de dados que podem ser armazenados nas c√©lulas, ou na forma como os timestamps s√£o tratados. O conceito geral √© similar, mas os detalhes podem variar. üí° **Dica:** Modelo √© inspira√ß√£o, n√£o lei imut√°vel. (Cap√≠tulo 7, p. 349-350)                                                                                                                                                                                                                                                                                                 |
| 129 | A "index-free adjacency" nos bancos de grafos elimina completamente a necessidade de qualquer tipo de √≠ndice, tornando todas as buscas, incluindo por propriedades de n√≥s ou arestas, igualmente eficientes.                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ "Index-free adjacency" √© espec√≠fica para a TRAVESSIA de um n√≥ para seus VIZINHOS DIRETOS. Para buscar n√≥s ou arestas por suas PROPRIEDADES (ex: "encontre todas as pessoas com nome 'Jo√£o'"), bancos de grafos ainda usam e precisam de √≠ndices (como √°rvores B) nessas propriedades para serem eficientes, assim como bancos relacionais. üí° **Dica:** Vizinhos r√°pidos = OK. Buscar por valor de propriedade = Precisa de √≠ndice. (Cap√≠tulo 7, p. 366)                                                                                                                                                                                                                                                               |
| 130 | A consist√™ncia eventual (eventual consistency) em sistemas NoSQL garante que, ap√≥s uma escrita, todas as r√©plicas dos dados se tornar√£o consistentes imediatamente, dentro de um intervalo de tempo m√°ximo predefinido e garantido.                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ "Eventualmente" significa que as r√©plicas *ir√£o* se tornar consistentes, mas n√£o h√° uma garantia de tempo *imediato* ou um limite m√°ximo estrito e garantido para todos os cen√°rios. O tempo pode variar dependendo da carga da rede, dist√¢ncia, etc. √â uma garantia mais fraca que a consist√™ncia forte. üí° **Dica:** Eventual = Vai acontecer, mas tenha paci√™ncia. (Cap√≠tulo 4, p. 233; Cap. 7, p. 355)                                                                                                                                                                                                                                                                                                             |
| 131 | Bancos de dados chave-valor s√£o frequentemente escolhidos para casos de uso que exigem consultas ad-hoc complexas com m√∫ltiplas condi√ß√µes de filtro e agrega√ß√µes sobre os valores armazenados.                                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ Chave-valor brilha na simplicidade e velocidade de busca por chave: "Me d√™ o valor para esta chave". Para consultas ad-hoc complexas com muitos filtros e agrega√ß√µes, modelos como documento, column-family ou at√© mesmo SQL s√£o geralmente mais adequados e expressivos. üí° **Dica:** Chave-valor = Simples √© r√°pido. (Cap√≠tulo 7, p. 345-346)                                                                                                                                                                                                                                                                                                                                                                        |
| 132 | A flexibilidade de esquema dos bancos de dados de documento pode levar a desafios na manuten√ß√£o e evolu√ß√£o da aplica√ß√£o se a estrutura dos documentos divergir muito ao longo do tempo sem um controle adequado.                                                                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Com certeza! Se cada desenvolvedor come√ßa a guardar dados no documento do jeito que quer, sem um m√≠nimo de padr√£o ou versionamento, a aplica√ß√£o que l√™ esses documentos pode virar um pesadelo üßü para dar manuten√ß√£o ou evoluir, pois ela ter√° que lidar com in√∫meras estruturas diferentes. üí° **Dica:** Flexibilidade √© bom, mas "com grandes poderes v√™m grandes responsabilidades" (de gerenciar a estrutura). (Cap√≠tulo 7, p. 353, 355)                                                                                                                                                                                                                                                                          |
| 133 | Bancos de dados Column-Family s√£o uma boa escolha para sistemas OLTP (Online Transaction Processing) que envolvem muitas escritas pequenas e leituras de linhas inteiras de dados com frequ√™ncia.                                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ Column-families s√£o mais otimizados para cargas de trabalho OLAP (Online Analytical Processing) ou cen√°rios onde voc√™ l√™ um subconjunto de colunas de muitas linhas. Para OLTP com muitas escritas e leituras de linhas inteiras, bancos de dados relacionais (row-stores) ou alguns NoSQL como chave-valor/documento podem ser mais eficientes. üí° **Dica:** Column-family = Pense anal√≠tico, leia colunas espec√≠ficas. (Cap√≠tulo 7, p. 349-350)                                                                                                                                                                                                                                                                      |
| 134 | A principal desvantagem dos bancos de dados orientados a grafos √© a dificuldade em representar e consultar dados que n√£o possuem relacionamentos expl√≠citos, como cole√ß√µes de itens independentes.                                                                                                                                                                                                                                                                                                                                   | V        | üë®‚Äçüè´ Se os seus dados s√£o s√≥ uma lista de coisas que n√£o se conectam muito (ex: um cat√°logo de produtos sem recomenda√ß√µes ou rela√ß√µes sociais), um banco de grafos pode ser um exagero. Ele √© feito para brilhar quando as conex√µes s√£o importantes. Para dados isolados, um chave-valor ou documento pode ser mais simples e eficiente. üí° **Dica:** Se n√£o tem teia, n√£o precisa do Homem-Aranha (banco de grafos). (Cap√≠tulo 7, p. 364, 366)                                                                                                                                                                                                                                                                             |
| 135 | A decis√£o de usar um banco de dados NoSQL em vez de um relacional deve considerar trade-offs como a poss√≠vel perda de consist√™ncia forte (ACID) em troca de maior escalabilidade, disponibilidade ou flexibilidade de esquema.                                                                                                                                                                                                                                                                                                       | V        | üë®‚Äçüè´ Esse √© o cerne da quest√£o! N√£o existe almo√ßo gr√°tis üçΩÔ∏è. NoSQL oferece vantagens incr√≠veis em algumas √°reas, mas muitas vezes isso vem ao custo de relaxar algumas garantias que os bancos relacionais oferecem por padr√£o. √â uma escolha de engenharia baseada nos requisitos da aplica√ß√£o. üí° **Dica:** NoSQL vs SQL = Uma balan√ßa de pr√≥s e contras. (Cap√≠tulo 7, p. 343-344)                                                                                                                                                                                                                                                                                                                                       |
| 136 | O formato JSON (JavaScript Object Notation) √© ideal para representar dados em bancos de documento devido √† sua legibilidade humana, facilidade de parsing por m√°quinas e suporte nativo a estruturas de dados complexas e aninhadas.                                                                                                                                                                                                                                                                                                 | V        | üë®‚Äçüè´ Sim! JSON acertou na mosca üéØ: √© f√°cil para n√≥s humanos lermos e escrevermos, e f√°cil para as m√°quinas processarem. O aninhamento de objetos e arrays permite modelar dados do mundo real de forma bem natural dentro de um √∫nico "documento". üí° **Dica:** JSON = Simples, flex√≠vel e poderoso para documentos. (Cap√≠tulo 7, p. 353)                                                                                                                                                                                                                                                                                                                                                                                  |
| 137 | Todos os bancos de dados NoSQL utilizam APIs RESTful como √∫nica forma de intera√ß√£o, eliminando a necessidade de drivers ou bibliotecas espec√≠ficas da linguagem de programa√ß√£o.                                                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ Embora APIs RESTful sejam comuns, especialmente para bancos de documento ou servi√ßos na nuvem, muitos NoSQL tamb√©m oferecem drivers nativos para diversas linguagens de programa√ß√£o. Esses drivers podem ser mais perform√°ticos ou oferecer uma interface mais rica do que uma API HTTP gen√©rica. üí° **Dica:** Formas de acesso podem variar. (Cap√≠tulo 7, p. 344 - "Easy access is provided via an API")                                                                                                                                                                                                                                                                                                              |
| 138 | A denormaliza√ß√£o controlada √© uma t√©cnica comum em alguns sistemas NoSQL (como column-family ou documento) para otimizar leituras, duplicando dados para evitar jun√ß√µes custosas, mesmo que isso aumente a complexidade das escritas.                                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ Exato! Nos relacionais, a gente normaliza para evitar redund√¢ncia. Em alguns NoSQL, para ganhar velocidade na leitura, a gente faz o oposto (denormaliza) e junta dados que seriam separados, mesmo que isso signifique repetir informa√ß√£o. A escrita fica mais chata (tem que atualizar em v√°rios lugares), mas a leitura voa! üöÄ üí° **Dica:** Denormalizar em NoSQL = Pagar na escrita para ganhar na leitura. (Impl√≠cito nos modelos que evitam joins, como documento e column-family - Cap. 7)                                                                                                                                                                                                                     |
| 139 | A aus√™ncia de transa√ß√µes ACID globais abrangendo m√∫ltiplos shards em muitos sistemas NoSQL distribu√≠dos simplifica o desenvolvimento de aplica√ß√µes que requerem consist√™ncia forte em todas as opera√ß√µes.                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ A aus√™ncia de transa√ß√µes ACID globais *complica* o desenvolvimento se voc√™ precisa de consist√™ncia forte entre shards! O desenvolvedor precisa lidar com consist√™ncia eventual, implementar sagas, ou usar padr√µes de compensa√ß√£o. Se fosse simples, n√£o seria um dos maiores desafios em sistemas distribu√≠dos. üí° **Dica:** Sem ACID global = Desenvolvedor, se prepare para mais trabalho de consist√™ncia. (Cap√≠tulo 7, p. 344; Revis√£o Cap. 4)                                                                                                                                                                                                                                                                     |
| 140 | O CAP Theorem afirma que √© poss√≠vel construir um sistema distribu√≠do que seja simultaneamente 100% Consistente, 100% Dispon√≠vel e 100% Tolerante a Parti√ß√µes, desde que se utilize hardware suficientemente poderoso.                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ O CAP Theorem diz o oposto: voc√™ N√ÉO PODE ter os tr√™s ao mesmo tempo em um sistema distribu√≠do, n√£o importa o qu√£o bom seja seu hardware. Voc√™ sempre ter√° que fazer um trade-off e escolher no m√°ximo dois, ou aceitar limita√ß√µes em um deles quando uma parti√ß√£o de rede ocorre. üí° **Dica:** CAP = Escolha dolorosa, n√£o solu√ß√£o m√°gica. (Cap√≠tulo 4, p. 233-234)                                                                                                                                                                                                                                                                                                                                                   |
| 141 | Bancos de dados em mem√≥ria (In-Memory Databases), como Redis ou Memcached, s√£o adequados apenas para armazenamento tempor√°rio (cache), n√£o podendo ser usados como bancos de dados prim√°rios devido √† volatilidade da RAM.                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ Embora sejam excelentes para cache, muitos IMDBs modernos oferecem mecanismos de persist√™ncia (ex: snapshots no disco, logs de escrita) que permitem us√°-los como bancos prim√°rios para certas cargas de trabalho que exigem lat√™ncia ultrabaixa. A volatilidade √© gerenciada. üí° **Dica:** IMDBs evolu√≠ram e podem ser mais do que s√≥ cache. (Cap√≠tulo 7, p. 346)                                                                                                                                                                                                                                                                                                                                                     |
| 142 | O conceito de "locality groups" em column-family stores permite agrupar fam√≠lias de colunas que s√£o frequentemente acessadas juntas no mesmo servidor f√≠sico, otimizando o desempenho de leitura ao reduzir a movimenta√ß√£o de dados pela rede.                                                                                                                                                                                                                                                                                       | V        | üë®‚Äçüè´ Isso mesmo! √â como organizar sua despensa  pantry: voc√™ coloca os ingredientes que usa juntos na mesma prateleira para n√£o ter que ficar andando pela cozinha toda. Agrupar fam√≠lias de colunas acessadas juntas no mesmo n√≥ economiza tempo de rede e I/O. üí° **Dica:** Locality groups = Vizinhos de dados ficam juntos. (Cap√≠tulo 7, p. 350)                                                                                                                                                                                                                                                                                                                                                                        |
| 143 | A "eventual consistency" √© um modelo mais forte de consist√™ncia que o "strong consistency", pois garante que todas as atualiza√ß√µes sejam propagadas para todas as r√©plicas em um tempo previs√≠vel e determin√≠stico.                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ "Strong consistency" √© o mais forte: todas as leituras veem a escrita mais recente. "Eventual consistency" √© mais fraco: as r√©plicas *eventualmente* ficar√£o consistentes, mas h√° uma janela onde leituras podem retornar dados desatualizados. N√£o h√° garantia de tempo determin√≠stico. üí° **Dica:** Forte = Agora! Eventual = Depois, talvez. (Cap√≠tulo 4, p. 233, 236)                                                                                                                                                                                                                                                                                                                                              |
| 144 | Bancos de dados NoSQL s√£o inerentemente mais seguros que bancos de dados SQL devido √† aus√™ncia de uma linguagem de consulta padronizada como SQL, o que dificulta ataques de inje√ß√£o.                                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ A aus√™ncia de SQL elimina *SQL injection*, mas n√£o torna os NoSQL inerentemente mais seguros. Eles podem ter outras vulnerabilidades (ex: inje√ß√£o NoSQL se a API n√£o for bem sanitizada, problemas de configura√ß√£o, controle de acesso mais fraco). A seguran√ßa depende da implementa√ß√£o, configura√ß√£o e pr√°ticas. üí° **Dica:** Seguran√ßa √© um desafio em qualquer sistema, SQL ou NoSQL. (Cap√≠tulo 3, p. 209-211 sobre SQL Injection; seguran√ßa em NoSQL √© um tema amplo n√£o coberto em detalhes, mas a aus√™ncia de SQL n√£o √© garantia total)                                                                                                                                                                         |
| 145 | A escolha de um banco de dados NoSQL para uma aplica√ß√£o deve ser primariamente guiada pela popularidade e pela quantidade de documenta√ß√£o dispon√≠vel para o banco, em detrimento da adequa√ß√£o do modelo de dados aos requisitos.                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Popularidade e documenta√ß√£o s√£o importantes, mas o fator PRIMORDIAL √© a **adequa√ß√£o do modelo de dados e das caracter√≠sticas do banco (consist√™ncia, escalabilidade) aos requisitos da SUA aplica√ß√£o**. Usar um banco de grafos popular para um simples cache chave-valor pode ser um erro. üí° **Dica:** O problema dita a ferramenta, n√£o o contr√°rio. (Discuss√£o geral sobre NoSQL, Cap. 7)                                                                                                                                                                                                                                                                                                                          |
| 146 | O modelo de dados do Apache HBase √© diretamente baseado no Bigtable do Google, sendo um column-family store distribu√≠do que roda sobre o HDFS (Hadoop Distributed File System).                                                                                                                                                                                                                                                                                                                                                      | V        | üë®‚Äçüè´ Correto! HBase √© o "filho espiritual" do Bigtable no ecossistema Hadoop. Ele implementa o mesmo modelo de dados column-family e √© projetado para escalabilidade massiva, usando o HDFS para armazenamento persistente e distribu√≠do. üí° **Dica:** HBase = Bigtable no Hadoop. (Cap√≠tulo 7, p. 349 Bigtable; HBase √© uma implementa√ß√£o conhecida)                                                                                                                                                                                                                                                                                                                                                                       |
| 147 | Em bancos de dados orientados a documentos, a aus√™ncia de jun√ß√µes no n√≠vel do servidor obriga que todos os dados relacionados a uma entidade principal sejam sempre embutidos (embedded) dentro de um √∫nico documento.                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ Embora o embedding seja comum e eficiente para dados fortemente acoplados, n√£o √© a √∫nica op√ß√£o. Voc√™ PODE ter refer√™ncias (como IDs de outros documentos) e fazer "jun√ß√µes" no lado da APLICA√á√ÉO, buscando os documentos relacionados em consultas separadas. A escolha entre embutir e referenciar √© um trade-off. üí° **Dica:** Documentos podem "conversar" via IDs, mas a aplica√ß√£o faz a ponte. (Cap√≠tulo 7, p. 353)                                                                                                                                                                                                                                                                                               |
| 148 | O Apache Giraph √© uma plataforma para processamento de grafos em larga escala que utiliza o paradigma MapReduce para executar algoritmos de grafos de forma distribu√≠da.                                                                                                                                                                                                                                                                                                                                                             | V        | üë®‚Äçüè´ Sim! Giraph √© inspirado no Pregel do Google e permite que algoritmos de grafos iterativos (onde os n√≥s "conversam" com seus vizinhos em superpassos) sejam executados em clusters grandes, usando o MapReduce (ou similar, como Tez/Spark) como motor de execu√ß√£o subjacente. üí° **Dica:** Giraph = Pensando em grafos, executando com MapReduce. (N√£o diretamente no livro, mas um exemplo de processamento de grafos em larga escala, relevante para o contexto NoSQL/Big Data)                                                                                                                                                                                                                                      |
| 149 | A principal diferen√ßa entre um banco de dados em mem√≥ria (IMDB) e um cache tradicional √© que o IMDB sempre garante durabilidade ACID completa, enquanto o cache √© puramente vol√°til.                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ Um cache √© tipicamente vol√°til e usado para acelerar leituras de um armazenamento persistente. Um IMDB *pode* ser o armazenamento prim√°rio e *pode* oferecer durabilidade (com persist√™ncia no disco) e garantias ACID, embora nem todos o fa√ßam com a mesma for√ßa de um BD relacional tradicional. A linha pode ser t√™nue, mas um IMDB pode ser mais que um cache. üí° **Dica:** IMDB = Banco r√°pido, pode ser persistente. Cache = C√≥pia r√°pida e vol√°til. (Cap√≠tulo 7, p. 346)                                                                                                                                                                                                                                       |
| 150 | A "escalabilidade el√°stica" em sistemas NoSQL na nuvem refere-se √† capacidade do sistema de adicionar ou remover recursos computacionais (n√≥s, capacidade) automaticamente ou sob demanda, adaptando-se √† carga de trabalho.                                                                                                                                                                                                                                                                                                         | V        | üë®‚Äçüè´ Exatamente! √â como um el√°stico üßò: ele estica quando voc√™ precisa de mais (picos de uso) e encolhe quando a demanda diminui, pagando apenas pelo que usa. Muitas plataformas de nuvem oferecem isso para seus servi√ßos NoSQL. üí° **Dica:** El√°stico = Adapta-se √† demanda. (Conceito geral de nuvem e escalabilidade, relevante para NoSQL - n√£o espec√≠fico do livro, mas contextual).                                                                                                                                                                                                                                                                                                                                 |
| 151 | Sistemas NoSQL que implementam consist√™ncia por quorum com W+R > N sempre evitam a necessidade de rel√≥gios vetoriais, pois a sobreposi√ß√£o de leituras e escritas garante a identifica√ß√£o da vers√£o mais recente.                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Mesmo com W+R > N, uma leitura pode acessar m√∫ltiplas r√©plicas que participaram de escritas diferentes (mas todas v√°lidas dentro do quorum de escrita). Se essas escritas foram concorrentes ou muito pr√≥ximas no tempo, pode haver m√∫ltiplas "vers√µes mais recentes" vistas pela leitura. Rel√≥gios vetoriais (ou outros mecanismos de resolu√ß√£o de conflitos) ainda podem ser necess√°rios para que o cliente determine a ordem causal ou escolha uma vers√£o. A sobreposi√ß√£o garante que voc√™ veja *algo* recente, mas pode n√£o ser trivial qual √© *o mais* recente globalmente sem ajuda. üí° **Dica:** Quorum ajuda, mas conflitos de escrita concorrente ainda podem precisar de resolu√ß√£o. (Cap√≠tulo 4, p. 236-237) |
| 152 | A aus√™ncia de uma linguagem de consulta padronizada como SQL em muitos sistemas NoSQL pode aumentar a depend√™ncia do fornecedor (vendor lock-in), pois migrar de um NoSQL para outro pode exigir reescrever grande parte da l√≥gica de acesso a dados.                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ Infelizmente, sim. Se cada NoSQL fala sua pr√≥pria "l√≠ngua" (API ou linguagem de consulta), mudar de um para outro pode ser como mudar de pa√≠s e ter que aprender um idioma totalmente novo. Com SQL, a portabilidade entre bancos relacionais √© (teoricamente) maior. üí° **Dica:** NoSQL = Mais liberdade, mas pode prender mais. (Discuss√£o geral sobre a diversidade de NoSQL, Cap. 7)                                                                                                                                                                                                                                                                                                                               |
| 153 | Bancos de dados de s√©ries temporais (Time Series Databases) s√£o um tipo especializado de NoSQL otimizado para ingerir, armazenar e consultar grandes volumes de dados que s√£o indexados pelo tempo, como m√©tricas de sensores ou dados financeiros.                                                                                                                                                                                                                                                                                  | V        | üë®‚Äçüè´ Correto! Eles s√£o feitos sob medida para dados que chegam em alta velocidade e onde o tempo √© a dimens√£o principal. Pense em monitoramento de sistemas, IoT, mercado financeiro. Eles t√™m otimiza√ß√µes para compress√£o, agrega√ß√µes temporais e consultas baseadas em janelas de tempo. üí° **Dica:** Time Series DB = Dados com carimbo de tempo em alta performance. (N√£o √© um dos 4 core NoSQL do livro, mas um tipo importante e crescente)                                                                                                                                                                                                                                                                           |
| 154 | A replica√ß√£o ass√≠ncrona em sistemas NoSQL, onde as escritas s√£o confirmadas ao cliente antes de serem propagadas para todas as r√©plicas, melhora a lat√™ncia de escrita, mas aumenta a janela de potencial perda de dados em caso de falha do n√≥ prim√°rio.                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ √â um trade-off cl√°ssico! Se o prim√°rio diz "OK, escrevi!" antes de todas as c√≥pias confirmarem, a escrita √© r√°pida. Mas se ele falhar logo depois, antes das c√≥pias receberem, essa escrita pode se perder. Replica√ß√£o s√≠ncrona √© mais lenta na escrita, mas mais segura. üí° **Dica:** Ass√≠ncrono = R√°pido mas arriscado. S√≠ncrono = Lento mas seguro. (Conceito geral de replica√ß√£o, relevante para NoSQL)                                                                                                                                                                                                                                                                                                            |
| 155 | Todos os bancos de dados NoSQL s√£o de c√≥digo aberto (open-source), sendo esta uma caracter√≠stica definidora do movimento NoSQL, em contraste com os SGBDs relacionais predominantemente comerciais.                                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ Embora o movimento NoSQL tenha sido fortemente impulsionado pela comunidade open-source e muitos NoSQL populares sejam open-source (MongoDB, Cassandra, Redis), existem tamb√©m solu√ß√µes NoSQL comerciais e propriet√°rias. N√£o √© uma caracter√≠stica *definidora* que *todos* sejam open-source. üí° **Dica:** Open-source √© comum em NoSQL, mas n√£o exclusivo. (Cap√≠tulo 7, p. 343, 368 - Redis √© open source, mas o livro cita "muitos deles open source" n√£o todos)                                                                                                                                                                                                                                                    |
| 156 | A "imutabilidade" dos dados, um conceito aplicado em alguns sistemas de dados (n√£o exclusivamente NoSQL), significa que uma vez que um registro de dados √© escrito, ele nunca √© modificado; atualiza√ß√µes criam novas vers√µes do registro.                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Isso mesmo! √â como escrever com caneta permanente üñäÔ∏è. Se voc√™ erra, n√£o apaga; voc√™ risca e escreve de novo ao lado (uma nova vers√£o). Isso √© √≥timo para auditoria, hist√≥rico e simplifica algumas l√≥gicas de concorr√™ncia. Datomic √© um exemplo de banco que usa esse princ√≠pio. üí° **Dica:** Imut√°vel = Sem borracha, s√≥ vers√µes novas. (Conceito avan√ßado, n√£o espec√≠fico do livro, mas relevante para arquiteturas de dados modernas)                                                                                                                                                                                                                                                                             |
| 157 | Bancos de dados "multi-modelo" s√£o uma tend√™ncia emergente onde um √∫nico SGBD oferece suporte nativo a m√∫ltiplos modelos de dados NoSQL (ex: documento e grafo) e, √†s vezes, tamb√©m relacional, dentro da mesma plataforma.                                                                                                                                                                                                                                                                                                          | V        | üë®‚Äçüè´ Sim, √© uma tentativa de ter o "melhor de v√°rios mundos" üåê. Em vez de ter N bancos diferentes, um banco multi-modelo tenta oferecer flexibilidade para diferentes tipos de dados e consultas sob o mesmo cap√¥. ArangoDB e OrientDB s√£o exemplos. üí° **Dica:** Multi-modelo = Um banco, v√°rias "personalidades". (Tend√™ncia, n√£o coberta no livro, mas evolu√ß√£o natural do NoSQL)                                                                                                                                                                                                                                                                                                                                       |
| 158 | O uso de APIs baseadas em gRPC (Google Remote Procedure Call) para intera√ß√£o com bancos de dados NoSQL est√° se tornando mais comum devido √† sua performance superior e suporte a streaming bidirecional em compara√ß√£o com APIs REST/HTTP1.1.                                                                                                                                                                                                                                                                                         | V        | üë®‚Äçüè´ gRPC usa HTTP/2 e Protocol Buffers, o que geralmente resulta em menor lat√™ncia, menor uso de banda e funcionalidades mais ricas (como streaming bidirecional) comparado ao REST tradicional sobre HTTP/1.1 com JSON. Muitos sistemas distribu√≠dos modernos est√£o adotando gRPC. üí° **Dica:** gRPC = Comunica√ß√£o mais r√°pida e eficiente para microsservi√ßos e BDs. (Tecnologia de API, n√£o espec√≠fica do livro, mas relevante para o ecossistema)                                                                                                                                                                                                                                                                      |
| 159 | A complexidade de gerenciar um cluster NoSQL distribu√≠do (provisionamento, monitoramento, balanceamento, backups) √© inerentemente menor do que gerenciar um √∫nico servidor de banco de dados relacional.                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ Gerenciar um cluster distribu√≠do √© um bicho de sete cabe√ßas üêâ! Voc√™ tem m√∫ltiplos n√≥s para cuidar, a rede entre eles, consist√™ncia, falhas parciais... √â significativamente MAIS complexo do que um √∫nico servidor SQL, embora ferramentas e servi√ßos de nuvem ajudem a abstrair parte dessa complexidade. üí° **Dica:** Distribu√≠do = Mais poder, mas mais dor de cabe√ßa para gerenciar. (Impl√≠cito na discuss√£o de sistemas distribu√≠dos em NoSQL, Cap. 7)                                                                                                                                                                                                                                                           |
| 160 | A "disponibilidade" no teorema CAP refere-se √† garantia de que cada requisi√ß√£o feita a um n√≥ n√£o falho do sistema distribu√≠do receber√° uma resposta (n√£o necessariamente com os dados mais recentes), sem timeouts indefinidos.                                                                                                                                                                                                                                                                                                      | V        | üë®‚Äçüè´ Exatamente! Disponibilidade significa que o sistema est√° "de p√©" e respondendo üëç. Ele n√£o travou ou ficou mudo. A resposta pode n√£o ter o dado 100% mais atualizado (se a consist√™ncia foi sacrificada em favor da disponibilidade durante uma parti√ß√£o), mas ele responde. üí° **Dica:** Disponibilidade = Al√¥, tem algu√©m a√≠? Sim! (Cap√≠tulo 4, p. 233)                                                                                                                                                                                                                                                                                                                                                              |
| 161 | A informa√ß√£o, para ser √∫til, deve sempre existir em um meio f√≠sico fixo, como papel impresso, sendo imposs√≠vel sua representa√ß√£o ou transmiss√£o por meios digitais independentes de localiza√ß√£o.                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Pense na m√∫sica üé∂. Antigamente, era s√≥ no disco de vinil (meio f√≠sico). Hoje, ela est√° no seu celular, no streaming (digital, independente de onde voc√™ est√°). A informa√ß√£o √© assim, pode ser f√≠sica ou digital, e a digital viaja f√°cil! üí° **Dica:** "Sempre" e "imposs√≠vel" s√£o palavras muito fortes. A informa√ß√£o √© bem mais flex√≠vel. (Cap√≠tulo 1, p. 26)                                                                                                                                                                                                                                                                                                                                                       |
| 162 | O "Original" da informa√ß√£o digital √© facilmente distingu√≠vel de suas c√≥pias, e cada c√≥pia subsequente geralmente perde qualidade, de forma similar a uma fotoc√≥pia de uma fotoc√≥pia.                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ No mundo digital, uma c√≥pia √© PERFEITA! ‚ú® Se voc√™ copia um arquivo de m√∫sica, a c√≥pia √© id√™ntica ao original, sem perda de qualidade. Diferente de fotoc√≥pias que v√£o ficando ruins. O conceito de "original √∫nico e superior" √© mais do mundo f√≠sico. üí° **Dica:** Digital = C√≥pia perfeita, sem degradar. (Cap√≠tulo 1, p. 26)                                                                                                                                                                                                                                                                                                                                                                                        |
| 163 | Um sistema de informa√ß√£o computadorizado √© composto unicamente por um banco de dados e pelo software que permite ao usu√°rio interagir com ele, n√£o necessitando de componentes como redes de comunica√ß√£o.                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ Um sistema de informa√ß√£o moderno √© mais que s√≥ o banco e o programa na sua m√°quina. Pense no seu app de banco üì±: ele precisa do banco de dados do banco, do app no seu celular, E da internet (rede de comunica√ß√£o) para tudo funcionar junto! üí° **Dica:** Sistemas de informa√ß√£o hoje s√£o conectados. (Cap√≠tulo 1, p. 27-28, Fig. 1.1)                                                                                                                                                                                                                                                                                                                                                                              |
| 164 | Em um banco de dados relacional, cada linha de uma tabela √© chamada de "atributo" e cada coluna √© chamada de "tupla".                                                                                                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ √â o contr√°rio! Imagine uma planilha: cada LINHA √© um registro completo de algo (ex: dados de um aluno), isso √© a **tupla** (ou registro). Cada COLUNA descreve uma caracter√≠stica (ex: Nome, Matr√≠cula, Nota), isso √© o **atributo** (ou campo). üí° **Dica:** Linha = Tupla/Registro; Coluna = Atributo/Campo. (Cap√≠tulo 1, p. 30-31)                                                                                                                                                                                                                                                                                                                                                                                  |
| 165 | A chave prim√°ria de uma tabela relacional pode conter valores duplicados, desde que cada tupla tamb√©m possua um atributo de "timestamp" √∫nico para diferenci√°-las.                                                                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ A chave prim√°ria tem uma regra de ouro: ser √öNICA! üîë Ela √© o RG da linha na tabela, n√£o pode ter duas linhas com o mesmo RG. Um timestamp pode ajudar a versionar, mas n√£o substitui a unicidade da chave prim√°ria para identificar a linha *atual*. üí° **Dica:** Chave Prim√°ria = Identificador exclusivo, sem repeti√ß√£o. (Cap√≠tulo 1, p. 30, 32)                                                                                                                                                                                                                                                                                                                                                                    |
| 166 | A linguagem SQL (Structured Query Language) foi projetada para ser usada exclusivamente por programadores experientes, sendo inadequada para usu√°rios finais ou analistas de dados realizarem consultas simples.                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ SQL √© poderosa, mas sua sintaxe b√°sica (SELECT, FROM, WHERE) √© relativamente simples e leg√≠vel, parecida com ingl√™s. Muitos analistas e at√© usu√°rios com algum treino conseguem fazer consultas para extrair informa√ß√µes. N√£o √© s√≥ para "gurus" da programa√ß√£o. üí° **Dica:** SQL pode ser simples para o simples, e complexo para o complexo. (Cap√≠tulo 1, p. 33-34, 36)                                                                                                                                                                                                                                                                                                                                               |
| 167 | Big Data se refere apenas ao volume de dados, ou seja, qualquer conjunto de dados que exceda 1 Terabyte √© considerado Big Data, independentemente de sua variedade ou velocidade de gera√ß√£o.                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ Big Data √© mais que s√≥ "muito dado"! S√£o os 3 Vs (pelo menos): **Volume** (muito dado, sim), **Variedade** (tipos diferentes: texto, v√≠deo, sensores) e **Velocidade** (dados chegando super r√°pido). Um arquivo grande e est√°tico pode n√£o ser Big Data se n√£o tiver os outros Vs. üí° **Dica:** Big Data = 3 Vs (Volume, Velocidade, Variedade). (Cap√≠tulo 1, p. 39)                                                                                                                                                                                                                                                                                                                                                  |
| 168 | Em um grafo de propriedades (Property Graph), as arestas (relacionamentos) servem apenas para indicar uma conex√£o entre dois n√≥s, n√£o podendo elas mesmas conter atributos ou propriedades.                                                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ As arestas em um grafo de propriedades s√£o espertinhas! ü§ì Elas n√£o s√≥ conectam dois n√≥s, mas tamb√©m podem ter suas pr√≥prias etiquetas (tipo de relacionamento) e propriedades (ex: "desde quando s√£o amigos?", "qual o peso da conex√£o?"). üí° **Dica:** Em Property Graphs, tanto n√≥s quanto arestas podem ter "RG" e "caracter√≠sticas". (Cap√≠tulo 1, p. 42)                                                                                                                                                                                                                                                                                                                                                          |
| 169 | A principal fun√ß√£o dos "Data Architects" em uma organiza√ß√£o √© instalar e configurar os servidores de banco de dados, garantindo seu funcionamento cont√≠nuo e realizando backups.                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Data Architects s√£o os "engenheiros civis" dos dados üèóÔ∏è. Eles planejam a ESTRUTURA GERAL dos dados da empresa (como os dados se conectam, quais s√£o importantes, como ser√£o modelados). Quem instala servidores e faz backup s√£o os Database Specialists/Administrators (DBAs). üí° **Dica:** Arquiteto de Dados = Pensa na planta. DBA = Constr√≥i e mant√©m a casa. (Cap√≠tulo 1, p. 54)                                                                                                                                                                                                                                                                                                                                |
| 170 | Um modelo de dados serve apenas como uma documenta√ß√£o est√°tica, n√£o tendo influ√™ncia direta no design ou na implementa√ß√£o de um banco de dados real.                                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ O modelo de dados √© o MAPA üó∫Ô∏è para construir o banco de dados! Ele define quais dados guardar e como eles se relacionam. Sem um bom modelo, voc√™ constr√≥i um banco de dados bagun√ßado e dif√≠cil de usar. Ele √© fundamental para o design. üí° **Dica:** Modelo de Dados = Projeto do Banco de Dados. (Cap√≠tulo 2, p. 63)                                                                                                                                                                                                                                                                                                                                                                                               |
| 171 | No modelo Entidade-Relacionamento (ER), um "atributo" √© uma inst√¢ncia espec√≠fica de um conjunto de entidades, como "o cliente Jo√£o Silva".                                                                                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ Um atributo √© uma CARACTER√çSTICA de uma entidade. Ex: para a entidade "Cliente", os atributos podem ser "Nome", "CPF", "Endere√ßo". "O cliente Jo√£o Silva" √© uma INST√ÇNCIA (ou ocorr√™ncia) da entidade "Cliente". üí° **Dica:** Entidade = A Coisa. Atributo = Caracter√≠stica da Coisa. Inst√¢ncia = Exemplo da Coisa. (Cap√≠tulo 2, p. 68)                                                                                                                                                                                                                                                                                                                                                                                |
| 172 | Um relacionamento do tipo "1 para 1" (1:1) entre duas entidades A e B significa que cada inst√¢ncia de A pode estar relacionada a m√∫ltiplas inst√¢ncias de B, e cada inst√¢ncia de B pode estar relacionada a m√∫ltiplas inst√¢ncias de A.                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ "1 para 1" significa que uma inst√¢ncia de A se relaciona com NO M√ÅXIMO UMA de B, e uma de B com NO M√ÅXIMO UMA de A. Ex: Um marido (1) tem uma esposa (1) (em um modelo monog√¢mico). M√∫ltiplas para m√∫ltiplas √© "N para M" (N:M). üí° **Dica:** Os n√∫meros na cardinalidade indicam o m√°ximo de relacionamentos por inst√¢ncia. (Cap√≠tulo 2, p. 71-73, Fig. 2.5)                                                                                                                                                                                                                                                                                                                                                          |
| 173 | A "Generaliza√ß√£o" no modelo ER √© o processo de combinar v√°rios conjuntos de entidades distintas em um √∫nico conjunto de relacionamento complexo.                                                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Generaliza√ß√£o √© criar uma entidade "guarda-chuva" ‚òÇÔ∏è para tipos mais espec√≠ficos. Ex: "Carro", "Moto", "Caminh√£o" s√£o tipos de "Ve√≠culo". "Ve√≠culo" √© a generaliza√ß√£o. N√£o √© sobre combinar em um relacionamento. üí° **Dica:** Generaliza√ß√£o = "√â um tipo de..." (Carro √â UM TIPO DE Ve√≠culo). (Cap√≠tulo 2, p. 74)                                                                                                                                                                                                                                                                                                                                                                                                     |
| 174 | A Primeira Forma Normal (1FN) exige que todos os atributos n√£o chave sejam totalmente dependentes da chave prim√°ria completa.                                                                                                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ A 1FN √© mais simples: ela s√≥ quer que cada "c√©lula" da sua tabela tenha UM √öNICO VALOR (at√¥mico), sem listas ou grupos repetidos dentro de um campo. A depend√™ncia total da chave √© requisito da SEGUNDA Forma Normal (2FN). üí° **Dica:** 1FN = Sem bagun√ßa multivalorada nos campos. (Cap√≠tulo 2, p. 81)                                                                                                                                                                                                                                                                                                                                                                                                              |
| 175 | Anomalias de inser√ß√£o ocorrem quando a exclus√£o de uma tupla leva √† perda n√£o intencional de outras informa√ß√µes que s√≥ existiam naquela tupla.                                                                                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ Isso descreve uma anomalia de EXCLUS√ÉO. Anomalia de INSER√á√ÉO √© quando voc√™ n√£o consegue adicionar um novo dado porque falta alguma outra informa√ß√£o obrigat√≥ria (geralmente parte da chave). Ex: n√£o poder cadastrar um novo departamento se ele ainda n√£o tem nenhum funcion√°rio (e funcion√°rio √© parte da chave de alguma tabela mal modelada). üí° **Dica:** Pense no nome: Inser√ß√£o = problema ao inserir. Exclus√£o = problema ao excluir. (Cap√≠tulo 2, p. 79)                                                                                                                                                                                                                                                      |
| 176 | O principal objetivo da cria√ß√£o de um diagrama de Voronoi em teoria de grafos √© encontrar o caminho mais longo entre dois pontos quaisquer em um plano Euclidiano.                                                                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ Diagramas de Voronoi s√£o sobre PROXIMIDADE! üó∫Ô∏è Eles dividem um plano em regi√µes, onde cada regi√£o cont√©m todos os pontos que est√£o MAIS PERTO de um "ponto semente" espec√≠fico do que de qualquer outro. √â para achar o "vizinho mais pr√≥ximo". üí° **Dica:** Voronoi = Quem est√° mais perto de quem? (Cap√≠tulo 2, p. 121)                                                                                                                                                                                                                                                                                                                                                                                             |
| 177 | Em uma representa√ß√£o de grafo por matriz de adjac√™ncia, o valor '1' na c√©lula (i, j) indica que n√£o existe uma aresta entre o v√©rtice i e o v√©rtice j.                                                                                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ Na matriz de adjac√™ncia mais comum para grafos n√£o ponderados, '1' na c√©lula (i, j) significa que EXISTE SIM uma aresta do v√©rtice i para o v√©rtice j. '0' significaria aus√™ncia de aresta. üí° **Dica:** Matriz de Adjac√™ncia: 1 = Conectado, 0 = Desconectado (geralmente). (Cap√≠tulo 2, p. 127, Fig. 2.29)                                                                                                                                                                                                                                                                                                                                                                                                           |
| 178 | A √Ålgebra Relacional √© uma linguagem de consulta gr√°fica, onde as opera√ß√µes s√£o representadas por √≠cones e diagramas interativos, similar ao QBE (Query by Example).                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ A √Ålgebra Relacional √© uma linguagem FORMAL, MATEM√ÅTICA üìê, com operadores simb√≥licos (como œÄ para proje√ß√£o, œÉ para sele√ß√£o, ‚ãà para jun√ß√£o). QBE √© que usa uma abordagem gr√°fica baseada em exemplos. üí° **Dica:** √Ålgebra Relacional = Teoria e s√≠mbolos. QBE = Visual e exemplos. (Cap√≠tulo 3, p. 161-163, 175, 180)                                                                                                                                                                                                                                                                                                                                                                                                 |
| 179 | Duas rela√ß√µes R e S s√£o consideradas "union-compat√≠veis" se possu√≠rem o mesmo n√∫mero de tuplas (linhas), mesmo que os tipos de dados de seus atributos correspondentes sejam diferentes.                                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ Para serem "union-compat√≠veis" (e poderem ser unidas, intersectadas ou subtra√≠das), as rela√ß√µes precisam ter o MESMO N√öMERO DE ATRIBUTOS (colunas) E os TIPOS DE DADOS dos atributos correspondentes devem ser COMPAT√çVEIS (ex: n√∫mero com n√∫mero, texto com texto). O n√∫mero de tuplas n√£o importa para essa defini√ß√£o. üí° **Dica:** Union-compat√≠vel = Mesma "forma" de colunas. (Cap√≠tulo 3, p. 164)                                                                                                                                                                                                                                                                                                                |
| 180 | O operador de Produto Cartesiano (√ó) na √°lgebra relacional s√≥ pode ser aplicado entre duas rela√ß√µes que compartilhem pelo menos um atributo em comum para realizar a combina√ß√£o.                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ O Produto Cartesiano √© o "mistureba total" üå™Ô∏è! Ele combina CADA tupla da primeira rela√ß√£o com CADA tupla da segunda, formando todas as combina√ß√µes poss√≠veis. As rela√ß√µes N√ÉO precisam ter atributos em comum. A Jun√ß√£o (Join) √© que geralmente usa atributos comuns. üí° **Dica:** Produto Cartesiano = Todos com todos, sem crit√©rio. (Cap√≠tulo 3, p. 161-162, 167)                                                                                                                                                                                                                                                                                                                                                  |
| 181 | Em SQL, a cl√°usula `SELECT *` retorna apenas a primeira e a √∫ltima coluna de todas as tabelas especificadas na cl√°usula `FROM`.                                                                                                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ O asterisco `*` em `SELECT *` √© um curinga que significa "TODAS AS COLUNAS" da(s) tabela(s) listada(s) no `FROM`. üí° **Dica:** `*` = Tudo, todas as colunas. (Cap√≠tulo 3, p. 178)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 182 | O comando `UPDATE EMPLOYEE SET City = 'Natal'` em SQL ir√° adicionar uma nova coluna chamada "City" √† tabela `EMPLOYEE` e preench√™-la com o valor 'Natal' para todas as linhas.                                                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ `UPDATE` serve para MODIFICAR dados EXISTENTES. Esse comando tentaria mudar o valor da coluna `City` (que j√° deve existir) para 'Natal' EM TODAS AS LINHAS da tabela `EMPLOYEE` (porque n√£o tem `WHERE` para filtrar). Para adicionar coluna, usa-se `ALTER TABLE ADD COLUMN`. üí° **Dica:** `UPDATE` = Muda valores. `ALTER TABLE` = Muda estrutura. (Cap√≠tulo 3, p. 179)                                                                                                                                                                                                                                                                                                                                              |
| 183 | Stored Functions em SQL s√£o blocos de c√≥digo que realizam uma tarefa, mas, diferentemente de Stored Procedures, n√£o podem retornar nenhum valor para quem as chamou.                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ √â o contr√°rio! Stored **Functions** (Fun√ß√µes Armazenadas) s√£o projetadas para realizar um c√°lculo e OBRIGATORIAMENTE RETORNAR UM VALOR (ex: uma fun√ß√£o que calcula a idade de algu√©m). Stored Procedures podem ou n√£o retornar valores (via par√¢metros de sa√≠da). üí° **Dica:** Fun√ß√£o = Retorna um valor. Procedimento = Faz uma a√ß√£o (pode ou n√£o ter sa√≠da). (Cap√≠tulo 3, p. 193)                                                                                                                                                                                                                                                                                                                                    |
| 184 | Um valor `NULL` em um banco de dados significa o mesmo que o valor zero para campos num√©ricos ou uma string vazia ("") para campos de texto.                                                                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ `NULL` √© especial! Significa "valor ausente", "desconhecido" ou "n√£o aplic√°vel" ü§î. Zero √© um n√∫mero espec√≠fico, e uma string vazia √© um texto espec√≠fico (sem caracteres). `NULL` n√£o √© nenhum dos dois. üí° **Dica:** `NULL` n√£o √© zero nem vazio, √© a aus√™ncia de valor. (Cap√≠tulo 3, p. 197)                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 185 | Uma transa√ß√£o em um banco de dados √© uma √∫nica opera√ß√£o de leitura, como `SELECT * FROM Clientes`.                                                                                                                                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ Uma transa√ß√£o √© uma SEQU√äNCIA de UMA OU MAIS opera√ß√µes (leitura, escrita, atualiza√ß√£o) que s√£o tratadas como uma UNIDADE L√ìGICA de trabalho. Ou todas as opera√ß√µes da sequ√™ncia s√£o bem-sucedidas (commit), ou nenhuma delas √© (rollback). Um simples `SELECT` pode ser uma transa√ß√£o, mas transa√ß√µes geralmente envolvem modifica√ß√µes. üí° **Dica:** Transa√ß√£o = Pacote de trabalho "tudo ou nada". (Cap√≠tulo 4, p. 218)                                                                                                                                                                                                                                                                                               |
| 186 | A propriedade de Consist√™ncia (C) do ACID garante que uma transa√ß√£o s√≥ pode levar o banco de dados de um estado inv√°lido para outro estado inv√°lido, nunca para um estado v√°lido.                                                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ A Consist√™ncia (C) garante o oposto: se o banco de dados estava em um estado V√ÅLIDO (onde todas as regras e restri√ß√µes s√£o respeitadas) antes da transa√ß√£o, ele estar√° em um estado V√ÅLIDO depois que a transa√ß√£o for conclu√≠da (comitada). A transa√ß√£o preserva a validade. üí° **Dica:** C de ACID = Coer√™ncia, Corre√ß√£o. (Cap√≠tulo 4, p. 218)                                                                                                                                                                                                                                                                                                                                                                        |
| 187 | O protocolo de Bloqueio de Duas Fases (2PL) permite que uma transa√ß√£o adquira novos bloqueios em qualquer ponto de sua execu√ß√£o, mesmo ap√≥s j√° ter liberado alguns bloqueios.                                                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ O 2PL tem duas fases distintas: uma FASE DE CRESCIMENTO (onde s√≥ se adquire bloqueios) e uma FASE DE ENCOLHIMENTO (onde s√≥ se libera bloqueios). Uma vez que uma transa√ß√£o libera seu primeiro bloqueio, ela entra na fase de encolhimento e n√£o pode mais adquirir novos bloqueios. üí° **Dica:** 2PL: Primeiro pega tudo, depois solta tudo (ou em partes), mas n√£o pega mais depois de soltar. (Cap√≠tulo 4, p. 224)                                                                                                                                                                                                                                                                                                  |
| 188 | O Teorema CAP (Consist√™ncia, Disponibilidade, Toler√¢ncia a Parti√ß√µes) aplica-se apenas a bancos de dados relacionais centralizados, n√£o tendo relev√¢ncia para sistemas NoSQL distribu√≠dos.                                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ O Teorema CAP √© FUNDAMENTAL justamente para sistemas DISTRIBU√çDOS, incluindo a maioria dos NoSQL! Ele descreve os trade-offs inerentes a ter dados espalhados em v√°rias m√°quinas que podem falhar ou ter a comunica√ß√£o interrompida. üí° **Dica:** CAP = Dilema dos sistemas distribu√≠dos. (Cap√≠tulo 4, p. 233)                                                                                                                                                                                                                                                                                                                                                                                                         |
| 189 | Em um log de transa√ß√µes, o "before image" de um objeto modificado refere-se ao estado do objeto ap√≥s a modifica√ß√£o ter sido aplicada pela transa√ß√£o.                                                                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ "Before image" (imagem anterior) √© o valor do objeto ANTES da modifica√ß√£o. √â guardado no log para que, se a transa√ß√£o precisar ser desfeita (rollback), o sistema saiba qual era o valor original para restaurar. "After image" seria o valor depois. üí° **Dica:** Before = Antes. After = Depois. (Cap√≠tulo 4, p. 231)                                                                                                                                                                                                                                                                                                                                                                                                |
| 190 | A principal fun√ß√£o do comando `ROLLBACK` em SQL √© confirmar permanentemente todas as altera√ß√µes feitas por uma transa√ß√£o no banco de dados.                                                                                                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ `ROLLBACK` faz o oposto! Ele DESFAZ todas as altera√ß√µes feitas pela transa√ß√£o desde o √∫ltimo `COMMIT` (ou desde o in√≠cio da transa√ß√£o, se n√£o houve commit). Para confirmar permanentemente, usa-se `COMMIT`. üí° **Dica:** `ROLLBACK` = Ctrl+Z para a transa√ß√£o. `COMMIT` = Salvar. (Cap√≠tulo 4, p. 219)                                                                                                                                                                                                                                                                                                                                                                                                               |
| 191 | A serializabilidade de transa√ß√µes garante que transa√ß√µes concorrentes sempre ser√£o executadas em uma ordem estritamente sequencial, uma ap√≥s a outra, sem qualquer tipo de paralelismo.                                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ Serializabilidade garante que o RESULTADO FINAL seja o MESMO COMO SE elas tivessem sido executadas serialmente. Elas PODEM rodar em paralelo, intercalando suas opera√ß√µes, desde que o SGBD use mecanismos (como bloqueios) para que o resultado seja equivalente a alguma ordem serial. üí° **Dica:** Serializ√°vel = Parece serial, mas pode ser paralelo por baixo dos panos. (Cap√≠tulo 4, p. 220)                                                                                                                                                                                                                                                                                                                    |
| 192 | Dados estruturados s√£o aqueles que n√£o possuem nenhuma organiza√ß√£o ou formato predefinido, como arquivos de √°udio ou v√≠deo.                                                                                                                                                                                                                                                                                                                                                                                                          | F        | üë®‚Äçüè´ Dados estruturados s√£o altamente organizados, geralmente em tabelas com linhas e colunas e tipos de dados bem definidos (como em bancos relacionais). √Åudio e v√≠deo s√£o exemplos de dados N√ÉO ESTRUTURADOS. üí° **Dica:** Estruturado = Planilha organizada. N√£o Estruturado = Arquivo de m√∫sica "solto". (Cap√≠tulo 5, p. 248-249)                                                                                                                                                                                                                                                                                                                                                                                      |
| 193 | Um √≠ndice em um banco de dados serve para armazenar c√≥pias completas de todas as tabelas, acelerando as consultas ao evitar o acesso ao disco r√≠gido.                                                                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ Um √≠ndice √© como o √≠ndice de um livro üìö: ele n√£o tem o livro todo, s√≥ os T√ìPICOS PRINCIPAIS (valores da coluna indexada) e ONDE ACH√Å-LOS (ponteiros para as linhas da tabela). Ele ajuda a encontrar os dados mais r√°pido, mas n√£o √© uma c√≥pia da tabela toda. üí° **Dica:** √çndice = Mapa r√°pido para os dados, n√£o os dados em si. (Cap√≠tulo 5, p. 252)                                                                                                                                                                                                                                                                                                                                                              |
| 194 | O m√©todo de hashing por divis√£o calcula o endere√ßo de um registro somando os valores ASCII de todos os caracteres da chave e dividindo pelo n√∫mero total de p√°ginas dispon√≠veis.                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ O m√©todo de hashing por divis√£o geralmente trata a chave como um n√∫mero e calcula o RESTO da divis√£o desse n√∫mero por um n√∫mero primo (p). O resto √© o endere√ßo da p√°gina. `H(k) = k mod p`. A soma de valores ASCII √© outra t√©cnica de hashing, mas n√£o a "divis√£o" cl√°ssica. üí° **Dica:** Hashing por Divis√£o = Resto da divis√£o por um primo. (Cap√≠tulo 5, p. 257)                                                                                                                                                                                                                                                                                                                                                  |
| 195 | O principal objetivo do algoritmo MapReduce √© executar transa√ß√µes ACID de forma distribu√≠da em um cluster de computadores.                                                                                                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ MapReduce √© para PROCESSAMENTO PARALELO DE GRANDES VOLUMES DE DADOS (geralmente para an√°lise, como contar palavras em muitos documentos). Ele n√£o √© focado em transa√ß√µes ACID. Ele quebra um problem√£o em pedacinhos (Map) e depois junta os resultados (Reduce). üí° **Dica:** MapReduce = Dividir para conquistar (an√°lise de dados). (Cap√≠tulo 5, p. 277)                                                                                                                                                                                                                                                                                                                                                            |
| 196 | Na arquitetura em camadas de um SGBD, a camada mais alta √© respons√°vel pela intera√ß√£o direta com o hardware de armazenamento, gerenciando a leitura e escrita de blocos no disco.                                                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ A camada mais alta (Layer 1: Set-oriented Interface) lida com a interface do usu√°rio, recebe comandos SQL, etc. A intera√ß√£o com o hardware de armazenamento (blocos de disco) √© feita pela camada MAIS BAIXA (Layer 5: Memory allocation). üí° **Dica:** Camadas: Usu√°rio em cima, Hardware embaixo. (Cap√≠tulo 5, p. 281-283)                                                                                                                                                                                                                                                                                                                                                                                           |
| 197 | Um "data stream" (fluxo de dados) √© caracterizado por armazenar um conjunto finito e est√°tico de registros que s√£o processados em lote (batch) uma √∫nica vez.                                                                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ Um data stream √© um FLUXO CONT√çNUO e potencialmente infinito de dados chegando ao longo do tempo (ex: dados de sensores, tweets). Eles s√£o processados "em tempo real" ou em pequenas janelas, n√£o como um lote est√°tico. üí° **Dica:** Stream = Rio que n√£o para de correr. Batch = Lagoa parada. (Cap√≠tulo 5, p. 249)                                                                                                                                                                                                                                                                                                                                                                                                 |
| 198 | Um banco de dados federado exige que todos os fragmentos de dados distribu√≠dos sejam fisicamente replicados em cada n√≥ da federa√ß√£o para garantir a consist√™ncia.                                                                                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ Em um banco federado, os fragmentos podem estar em n√≥s diferentes SEM serem necessariamente replicados em todos os outros. A ideia √© acessar dados onde eles est√£o, sob uma vis√£o unificada. Replica√ß√£o √© uma t√©cnica que *pode* ser usada, mas n√£o √© uma exig√™ncia definidora de federa√ß√£o. üí° **Dica:** Federado = Acessa onde est√°. (Cap√≠tulo 6, p. 295)                                                                                                                                                                                                                                                                                                                                                            |
| 199 | O "tempo de validade" em um banco de dados temporal registra o momento exato em que uma transa√ß√£o foi confirmada (commit) no banco de dados.                                                                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ Isso descreve o "tempo de TRANSA√á√ÉO". O "tempo de VALIDADE" √© quando a informa√ß√£o era/√©/ser√° VERDADEIRA no MUNDO REAL. Ex: O funcion√°rio Jo√£o foi promovido em 01/Mar√ßo (tempo de validade), mas isso s√≥ foi registrado no BD dia 05/Mar√ßo (tempo de transa√ß√£o). üí° **Dica:** Validade = Realidade. Transa√ß√£o = Registro no BD. (Cap√≠tulo 6, p. 300)                                                                                                                                                                                                                                                                                                                                                                   |
| 200 | Em um esquema estrela (star schema) de modelagem multidimensional, a tabela central √© chamada de tabela de dimens√£o, e as tabelas ao redor s√£o chamadas de tabelas de fatos.                                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ √â o contr√°rio! A tabela grandona no CENTRO √© a tabela de FATOS (com as m√©tricas, os n√∫meros que voc√™ quer analisar, ex: Vendas, Quantidade). As tabelas ao REDOR, ligadas a ela, s√£o as tabelas de DIMENS√ÉO (descrevem os fatos, ex: Tempo, Produto, Cliente). üí° **Dica:** Estrela: Fato no centro, Dimens√µes como pontas. (Cap√≠tulo 6, p. 306)                                                                                                                                                                                                                                                                                                                                                                       |
| 201 | Um Data Warehouse √© projetado primariamente para suportar as opera√ß√µes do dia-a-dia de uma empresa, como processamento de pedidos e faturamento, com dados sempre atualizados em tempo real.                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ Data Warehouse √© para AN√ÅLISE e tomada de decis√£o! üìä Ele guarda dados HIST√ìRICOS, consolidados de v√°rias fontes, e √© otimizado para consultas complexas, n√£o para as transa√ß√µes r√°pidas do dia-a-dia (isso √© papel dos sistemas OLTP). üí° **Dica:** DWH = Olhar para tr√°s para decidir o futuro. OLTP = Fazer as coisas agora. (Cap√≠tulo 6, p. 309-310)                                                                                                                                                                                                                                                                                                                                                               |
| 202 | O Mapeamento Objeto-Relacional (ORM) permite que aplica√ß√µes Java utilizem diretamente tabelas SQL como se fossem classes Java, sem nenhuma camada de tradu√ß√£o ou mapeamento entre os modelos.                                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ O ORM √© justamente a CAMADA DE TRADU√á√ÉO! üîÑ Ele faz a "m√°gica" de mapear as classes e objetos Java para as tabelas e linhas do banco relacional (e vice-versa). Ele tenta esconder as diferen√ßas (o "impedance mismatch") entre o mundo OO e o mundo relacional. üí° **Dica:** ORM = Tradutor entre Objetos e Tabelas. (Cap√≠tulo 6, p. 318)                                                                                                                                                                                                                                                                                                                                                                             |
| 203 | Um banco de dados de conhecimento (ou dedutivo) armazena apenas regras l√≥gicas, sendo incapaz de armazenar fatos concretos ou dados observados.                                                                                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ Um banco de conhecimento armazena tanto FATOS (ex: "S√≥crates √© humano") quanto REGRAS (ex: "Todo humano √© mortal"). A partir disso, ele pode DEDUZIR novos fatos (ex: "S√≥crates √© mortal"). Precisa dos dois! üí° **Dica:** BD Conhecimento = Fatos + Regras = Novas Descobertas. (Cap√≠tulo 6, p. 321)                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 204 | A principal caracter√≠stica de um banco de dados fuzzy √© sua capacidade de armazenar dados com 100% de certeza e precis√£o, eliminando qualquer forma de ambiguidade ou vagueza.                                                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ Fuzzy √© o oposto! üå´Ô∏è √â sobre lidar com IMPRECIS√ÉO, VAGUEZA, INCERTEZA. Permite graus de verdade (ex: "esta pessoa √© *meio* alta", em vez de s√≥ "alta" ou "n√£o alta"). üí° **Dica:** Fuzzy = Abra√ßando a incerteza do mundo real. (Cap√≠tulo 6, p. 326)                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 205 | A principal raz√£o para a popularidade dos bancos de dados NoSQL √© a sua estrita ader√™ncia ao modelo relacional e √† linguagem SQL, oferecendo melhor desempenho para consultas relacionais tradicionais.                                                                                                                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ NoSQL se popularizou justamente por oferecer ALTERNATIVAS ao modelo relacional e ao SQL, para cen√°rios onde estes n√£o eram ideais (ex: Big Data, esquemas flex√≠veis, alta escalabilidade horizontal). Eles usam outros modelos de dados (chave-valor, documento, grafo, etc.). üí° **Dica:** NoSQL = "N√£o (s√≥) SQL", buscando outras solu√ß√µes. (Cap√≠tulo 7, p. 343)                                                                                                                                                                                                                                                                                                                                                     |
| 206 | Em um banco de dados chave-valor, cada "valor" armazenado deve ser obrigatoriamente uma string de texto simples, n√£o sendo poss√≠vel armazenar estruturas complexas como JSON ou objetos serializados.                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ O "valor" em um banco chave-valor pode ser praticamente QUALQUER COISA: uma string, um n√∫mero, um objeto JSON, uma imagem, um v√≠deo, um objeto serializado da sua linguagem de programa√ß√£o... O banco trata como um "blob" de dados associado √† chave. üí° **Dica:** Chave-Valor: Chave simples, Valor pode ser complexo. (Cap√≠tulo 7, p. 345)                                                                                                                                                                                                                                                                                                                                                                          |
| 207 | Bancos de dados orientados a documentos sempre exigem que cada documento siga um esquema r√≠gido (como um DTD ou XSD para XML), garantindo que todos os documentos tenham exatamente os mesmos campos e tipos de dados.                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ A beleza dos bancos de documento √© a FLEXIBILIDADE de esquema! ü§∏ Cada documento pode ter sua pr√≥pria estrutura. Um pode ter o campo "email", outro n√£o. Um pode ter "tags" como uma lista, outro como uma string. O esquema √© impl√≠cito ou validado pela aplica√ß√£o. üí° **Dica:** Documento = Cada um no seu quadrado (ou c√≠rculo, ou tri√¢ngulo...). (Cap√≠tulo 7, p. 353)                                                                                                                                                                                                                                                                                                                                              |
| 208 | A principal fun√ß√£o de um banco de dados orientado a colunas √© armazenar cada linha completa da tabela em uma √∫nica unidade de disco, otimizando opera√ß√µes que necessitam de todos os atributos de um registro simultaneamente.                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ Bancos orientados a COLUNAS (ou fam√≠lias de colunas) armazenam os dados de CADA COLUNA juntos. Se voc√™ quer s√≥ as colunas A e B de 1 milh√£o de linhas, ele l√™ s√≥ essas colunas, o que √© muito eficiente. Bancos orientados a LINHAS (row-stores, como os relacionais tradicionais) guardam a linha toda junta. üí° **Dica:** Column-Store = Pega s√≥ as colunas que interessam. (Cap√≠tulo 7, p. 349)                                                                                                                                                                                                                                                                                                                     |
| 209 | A "index-free adjacency" em bancos de grafos significa que, para encontrar os vizinhos de um n√≥, o banco de dados precisa primeiro consultar um √≠ndice global de todas as arestas, similar a uma jun√ß√£o em SQL.                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ "Index-free adjacency" significa que cada n√≥ "conhece" seus vizinhos DIRETAMENTE, como se tivesse um ponteiro para eles. N√£o precisa de um √≠ndice global para achar os vizinhos imediatos. A travessia √© muito r√°pida. üí° **Dica:** Index-free adjacency = Vizinhos na discagem r√°pida, sem lista telef√¥nica. (Cap√≠tulo 7, p. 366)                                                                                                                                                                                                                                                                                                                                                                                     |
| 210 | Todos os bancos de dados NoSQL s√£o projetados para serem executados exclusivamente em um √∫nico servidor, n√£o oferecendo suporte para distribui√ß√£o ou clustering.                                                                                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Muitos NoSQL foram criados JUSTAMENTE para serem DISTRIBU√çDOS e rodarem em CLUSTERS de m√°quinas, para lidar com Big Data e alta disponibilidade! Cassandra, HBase, MongoDB, Redis (cluster mode) s√£o exemplos. üí° **Dica:** NoSQL frequentemente rima com Distribu√≠do. (Cap√≠tulo 7, p. 344, 346-347)                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 211 | Embora a informa√ß√£o digital possa ser facilmente copiada sem perda de qualidade, a sua representa√ß√£o √© estritamente limitada a formatos textuais, n√£o sendo poss√≠vel representar sons ou imagens digitalmente.                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ A primeira parte est√° cert√≠ssima: c√≥pias digitais s√£o perfeitas! üëç Mas, pense nos seus arquivos MP3 üéµ ou fotos JPEG üñºÔ∏è. Eles s√£o representa√ß√µes digitais de som e imagem! A informa√ß√£o digital √© super vers√°til e pode representar quase tudo. üí° **Dica:** A banca acertou no come√ßo, mas errou feio no final. Digital n√£o √© s√≥ texto! (Cap√≠tulo 1, p. 26, 39 Fig. 1.7)                                                                                                                                                                                                                                                                                                                                            |
| 212 | Um sistema de gerenciamento de banco de dados (SGBD) oferece linguagens para consulta e manipula√ß√£o de dados, mas a defini√ß√£o da estrutura dos dados (schema) deve ser sempre realizada por ferramentas externas, n√£o pelo pr√≥prio SGBD.                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ Um SGBD √© um pacote completo! Ele realmente oferece linguagens como SQL para consultar (SELECT) e manipular (INSERT, UPDATE, DELETE). MAS, o pr√≥prio SGBD tamb√©m tem comandos para DEFINIR A ESTRUTURA (como `CREATE TABLE` em SQL). Voc√™ n√£o precisa (geralmente) de outra ferramenta s√≥ para isso. üí° **Dica:** SGBD faz tudo: define, guarda e mexe nos dados. (Cap√≠tulo 1, p. 28, 37-38)                                                                                                                                                                                                                                                                                                                           |
| 213 | No modelo relacional, uma tabela √© um conjunto de tuplas (linhas) com atributos (colunas) bem definidos, sendo que a ordem f√≠sica das tuplas armazenadas no disco √© crucial para a corretude das consultas SQL.                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ Perfeito na primeira parte: tabela √© um conjunto de tuplas e atributos! üéØ Por√©m, a ordem f√≠sica das tuplas no disco √© IRRELEVANTE para a l√≥gica do modelo relacional e para a corretude do SQL. O SGBD pode organizar como quiser internamente. Se voc√™ quiser uma ordem espec√≠fica no resultado, voc√™ usa `ORDER BY`. üí° **Dica:** Modelo relacional = L√≥gica > F√≠sico. (Cap√≠tulo 1, p. 32)                                                                                                                                                                                                                                                                                                                          |
| 214 | Um conjunto de entidades no Modelo ER representa um grupo de objetos do mundo real com caracter√≠sticas comuns, e cada entidade √© unicamente identificada por um atributo multivalorado obrigat√≥rio.                                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ A primeira parte est√° √≥tima: conjunto de entidades agrupa objetos similares (ex: "Alunos"). üëç Mas a identifica√ß√£o √∫nica (chave prim√°ria) deve ser por um atributo (ou combina√ß√£o) com VALOR √öNICO e AT√îMICO para cada entidade, n√£o multivalorado. Um atributo multivalorado (ex: "telefones") n√£o serve como chave prim√°ria. üí° **Dica:** Chave = √önica e Simples (at√¥mica), n√£o uma lista. (Cap√≠tulo 2, p. 68; Revis√£o Cap. 1 p. 30-32)                                                                                                                                                                                                                                                                             |
| 215 | A cardinalidade de um relacionamento descreve quantos atributos podem existir no conjunto de relacionamento, sendo que um relacionamento "1 para N" sempre ter√° N atributos descritivos.                                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ Cardinalidade (ex: 1:N) diz quantas INST√ÇNCIAS de uma entidade podem se relacionar com inst√¢ncias de outra. Um relacionamento 1:N (um pai, N filhos) N√ÉO significa que o relacionamento ter√° N atributos. O relacionamento pode ter seus pr√≥prios atributos (ex: "data_de_inicio_do_relacionamento"), mas a quantidade n√£o √© ditada pela cardinalidade das entidades. üí° **Dica:** Cardinalidade = Quantos se ligam. Atributos do relacionamento = Caracter√≠sticas da liga√ß√£o. (Cap√≠tulo 2, p. 70-73)                                                                                                                                                                                                                  |
| 216 | A √Ålgebra Relacional fornece operadores formais como Sele√ß√£o (œÉ) para filtrar tuplas e Proje√ß√£o (œÄ) para selecionar atributos, sendo que o operador de Jun√ß√£o (‚ãà) √© usado para dividir uma tabela em duas menores.                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ Sele√ß√£o e Proje√ß√£o est√£o corret√≠ssimos! S√£o fundamentais. üëç Mas a Jun√ß√£o (‚ãà) serve para COMBINAR informa√ß√µes de duas (ou mais) tabelas com base em colunas relacionadas, formando uma tabela maior (ou com mais colunas). Para dividir, pensar√≠amos em proje√ß√µes ou outras t√©cnicas. üí° **Dica:** Jun√ß√£o = Juntar, n√£o separar. (Cap√≠tulo 3, p. 161-163, 170)                                                                                                                                                                                                                                                                                                                                                         |
| 217 | Em SQL, o comando `CREATE TABLE` √© utilizado para definir a estrutura de uma nova tabela com seus atributos e tipos de dados, e ap√≥s a cria√ß√£o, o comando `DROP TABLE` √© usado para adicionar novas tuplas a essa tabela.                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ `CREATE TABLE` est√° perfeito para definir a estrutura! üèóÔ∏è Mas `DROP TABLE` √© para DESTRUIR a tabela inteira (estrutura e dados!). Para adicionar novas tuplas (linhas), usamos o comando `INSERT INTO`. üí° **Dica:** `CREATE` = Nasce. `DROP` = Morre. `INSERT` = Popula. (Cap√≠tulo 3, p. 178-179)                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 218 | O princ√≠pio ACID para transa√ß√µes inclui a Atomicidade, que garante que ou todas as opera√ß√µes da transa√ß√£o ocorram ou nenhuma ocorra, e a Durabilidade, que assegura que o banco de dados possa ser revertido para qualquer estado anterior √† transa√ß√£o a qualquer momento.                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ Atomicidade (tudo ou nada) est√° correta! üëç Durabilidade (D) significa que, uma vez que uma transa√ß√£o √© COMITADA (confirmada), suas altera√ß√µes s√£o PERMANENTES e sobrevivem a falhas. Reverter para estados anteriores √© mais a fun√ß√£o do `ROLLBACK` (para a transa√ß√£o atual) ou de mecanismos de backup/recovery para pontos no tempo. üí° **Dica:** Durabilidade = Comitou, ficou! (Cap√≠tulo 4, p. 218-219)                                                                                                                                                                                                                                                                                                           |
| 219 | Bancos de dados chave-valor armazenam dados como pares de uma chave √∫nica e um valor associado, sendo que a "chave" deve ser sempre um n√∫mero inteiro sequencial gerado automaticamente pelo sistema.                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ A primeira parte √© a defini√ß√£o exata de um banco chave-valor! üëç Mas a chave pode ser MUITAS COISAS: uma string (mais comum), um n√∫mero, um UUID... N√£o precisa ser um inteiro sequencial gerado pelo sistema. A aplica√ß√£o geralmente define a chave de forma significativa para ela. üí° **Dica:** Chave em KV Store = Flex√≠vel, geralmente string. (Cap√≠tulo 7, p. 345)                                                                                                                                                                                                                                                                                                                                               |
| 220 | Bancos de dados orientados a documentos, como MongoDB, armazenam dados em documentos flex√≠veis (ex: JSON/BSON), permitindo que cada documento tenha uma estrutura diferente, e todos eles devem obrigatoriamente conter um campo "timestamp" para versionamento.                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ A flexibilidade de esquema e o uso de formatos como JSON/BSON s√£o caracter√≠sticas centrais! üëç No entanto, um campo "timestamp" para versionamento N√ÉO √© obrigat√≥rio em todos os documentos ou em todos os bancos de documento. Alguns podem ter campos como `_rev` (revis√£o), ou o versionamento pode ser gerenciado de outras formas, ou nem ser usado. üí° **Dica:** Flexibilidade de documento n√£o implica campos obrigat√≥rios universais. (Cap√≠tulo 7, p. 353-354)                                                                                                                                                                                                                                                 |
| 221 | A informa√ß√£o digital √© caracterizada pela sua capacidade de ser processada e combinada livremente, mas sua validade (qualidade) √© sempre absoluta e invari√°vel, n√£o dependendo de contexto ou fonte.                                                                                                                                                                                                                                                                                                                                 | F        | üë®‚Äçüè´ A primeira parte √© verdade: informa√ß√£o digital √© super male√°vel! üëç Mas a qualidade e validade da informa√ß√£o podem variar MUITO. Pense em not√≠cias falsas vs. artigos cient√≠ficos. A fonte e o contexto s√£o cruciais para determinar a "Vagueza" (qualidade/validade) da informa√ß√£o. üí° **Dica:** Nem tudo que reluz (digitalmente) √© ouro. Qualidade importa! (Cap√≠tulo 1, p. 26)                                                                                                                                                                                                                                                                                                                                     |
| 222 | Um Sistema de Gerenciamento de Banco de Dados (SGBD) permite descrever, armazenar e consultar dados de forma independente da aplica√ß√£o, sendo que a linguagem SQL √© utilizada exclusivamente para descrever a estrutura (schema).                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ A independ√™ncia da aplica√ß√£o √© um ponto chave dos SGBDs! üëç Por√©m, SQL √© uma linguagem poderosa e multifacetada: ela √© usada para DEFINIR a estrutura (DDL - `CREATE TABLE`), MANIPULAR os dados (DML - `INSERT`, `SELECT`, `UPDATE`, `DELETE`) e CONTROLAR o acesso (DCL - `GRANT`, `REVOKE`). N√£o √© s√≥ para o schema. üí° **Dica:** SQL √© o "faz-tudo" nos bancos relacionais. (Cap√≠tulo 1, p. 28, 33-34, 37-38)                                                                                                                                                                                                                                                                                                      |
| 223 | No modelo relacional, a propriedade de "Uniqueness" de uma chave de identifica√ß√£o garante que cada valor da chave identifique uma √∫nica tupla, e essa chave deve ser sempre um atributo num√©rico gerado artificialmente pelo sistema.                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ A unicidade da chave √© fundamental, cert√≠ssimo! üëç Mas a chave pode ser composta por atributos "naturais" do mundo real (ex: CPF, placa de carro) e n√£o precisa ser num√©rica nem gerada artificialmente, embora chaves artificiais (surrogates) sejam comuns por boas raz√µes. üí° **Dica:** Chave pode ser natural ou artificial, o importante √© ser √∫nica (e m√≠nima). (Cap√≠tulo 1, p. 31-32)                                                                                                                                                                                                                                                                                                                           |
| 224 | Big Data √© caracterizado por Volume, Velocidade e Variedade, sendo que "Velocidade" se refere √† rapidez com que o SGBD consegue executar consultas complexas, independentemente da taxa de chegada dos dados.                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ Os 3 Vs est√£o corretos! üëç Mas "Velocidade" em Big Data se refere principalmente √† TAXA com que os dados s√£o GERADOS e precisam ser PROCESSADOS (pense em streaming de dados de sensores, redes sociais). A velocidade de consulta √© uma consequ√™ncia desejada do processamento, mas n√£o a defini√ß√£o prim√°ria do V de Velocidade. üí° **Dica:** V de Velocidade = Qu√£o r√°pido os dados chegam e precisam ser tratados. (Cap√≠tulo 1, p. 39-40)                                                                                                                                                                                                                                                                           |
| 225 | Um grafo de propriedades consiste em n√≥s (objetos) e arestas direcionadas (relacionamentos), onde cada n√≥ deve obrigatoriamente ter pelo menos uma propriedade do tipo string para sua identifica√ß√£o.                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ A estrutura de n√≥s e arestas direcionadas com propriedades √© a ess√™ncia! üëç Mas um n√≥ PODE ter propriedades de v√°rios tipos (string, n√∫mero, booleano, data) e n√£o √© obrigat√≥rio que tenha uma propriedade espec√≠fica ou que seja string para identifica√ß√£o (a identidade do n√≥ √© inerente). üí° **Dica:** Propriedades em grafos s√£o flex√≠veis em tipo e quantidade. (Cap√≠tulo 1, p. 42)                                                                                                                                                                                                                                                                                                                               |
| 226 | Data Management abrange a arquitetura e governan√ßa dos dados, mas a tecnologia de banco de dados (SQL, NoSQL) e a utiliza√ß√£o anal√≠tica dos dados s√£o responsabilidades de √°reas completamente separadas e n√£o integradas.                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ Arquitetura e governan√ßa s√£o pilares, sim! üëç Mas a tecnologia (os SGBDs) e a utiliza√ß√£o (analytics, BI) s√£o PARTES INTEGRAIS do Data Management. √â um ciclo: voc√™ define a arquitetura, governa, usa a tecnologia para armazenar/processar, e utiliza para gerar valor. Tudo junto! üí° **Dica:** Data Management √© um esfor√ßo coordenado. (Cap√≠tulo 1, p. 52-53, Fig. 1.12)                                                                                                                                                                                                                                                                                                                                           |
| 227 | A modelagem de dados inicia-se com a an√°lise dos requisitos para definir entidades e relacionamentos, sendo que, no modelo ER, os atributos s√£o sempre representados por losangos conectados √†s entidades.                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ A an√°lise de requisitos para ER √© o come√ßo certo! üëç Mas no diagrama ER mais comum, atributos s√£o representados por OVAIS ü•ö ligados √†s entidades (ret√¢ngulos) ou relacionamentos (losangos). Losangos s√£o para os relacionamentos. üí° **Dica:** Ret√¢ngulo=Entidade, Losango=Relacionamento, Oval=Atributo. (Cap√≠tulo 2, p. 65 Fig. 2.1, p. 68-70)                                                                                                                                                                                                                                                                                                                                                                     |
| 228 | Uma associa√ß√£o de tipo "mc" (m√∫ltipla-condicional) de uma entidade ES1 para ES2 significa que cada entidade em ES1 se relaciona com zero, uma ou v√°rias entidades em ES2, e obrigatoriamente todas as entidades de ES2 devem participar do relacionamento.                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ A primeira parte descreve bem o "mc": zero, uma ou v√°rias (opcional e m√∫ltiplo). üëç Mas a segunda parte est√° errada. A cardinalidade "mc" de ES1 para ES2 n√£o imp√µe nenhuma obriga√ß√£o sobre ES2. A participa√ß√£o de ES2 seria definida pela cardinalidade no sentido oposto (de ES2 para ES1). üí° **Dica:** Cardinalidade √© direcional. O "mc" se refere √† perspectiva de ES1. (Cap√≠tulo 2, p. 71-72)                                                                                                                                                                                                                                                                                                                   |
| 229 | A Generaliza√ß√£o no modelo ER, onde "Carro" √© um tipo de "Ve√≠culo", implica que a entidade "Carro" herda os atributos de "Ve√≠culo", mas "Carro" n√£o pode ter atributos pr√≥prios, apenas os herdados.                                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ A heran√ßa de atributos do supertipo ("Ve√≠culo") para o subtipo ("Carro") √© correta! üëç Mas o subtipo ("Carro") PODE SIM ter seus pr√≥prios atributos espec√≠ficos (ex: "n√∫mero_de_portas", "tipo_de_combustivel") al√©m dos herdados. √â para isso que serve a especializa√ß√£o. üí° **Dica:** Subtipo = Herda do geral + adiciona o espec√≠fico. (Cap√≠tulo 2, p. 74-75)                                                                                                                                                                                                                                                                                                                                                       |
| 230 | A Primeira Forma Normal (1FN) exige que os valores dos atributos sejam at√¥micos, e uma tabela que satisfaz a 1FN est√° automaticamente livre de todas as anomalias de atualiza√ß√£o e exclus√£o.                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ Atomicidade √© o X da 1FN, perfeito! üëç No entanto, estar na 1FN √© s√≥ o primeiro passo. Uma tabela em 1FN ainda pode ter muitas redund√¢ncias e sofrer de anomalias de atualiza√ß√£o, exclus√£o e inser√ß√£o. As formas normais seguintes (2FN, 3FN, etc.) existem para tratar esses problemas. üí° **Dica:** 1FN √© o b√°sico, n√£o a solu√ß√£o para todos os males. (Cap√≠tulo 2, p. 79, 81, 84)                                                                                                                                                                                                                                                                                                                                   |
| 231 | Ao mapear um modelo ER para relacional, cada conjunto de entidade se torna uma tabela, e os relacionamentos 1:N s√£o sempre representados incluindo a chave da entidade do lado "N" como chave estrangeira na tabela do lado "1".                                                                                                                                                                                                                                                                                                     | F        | üë®‚Äçüè´ Entidades viram tabelas, certo! üëç Mas para um relacionamento 1:N (um PAI para N FILHOS), a chave prim√°ria da entidade do lado "1" (PAI) √© que vai como chave estrangeira para a tabela do lado "N" (FILHOS), para que cada filho saiba quem √© seu pai. O contr√°rio geraria multivalora√ß√£o ou redund√¢ncia. üí° **Dica:** Em 1:N, o "1" empresta sua chave para o "N". (Cap√≠tulo 2, p. 97, 100-101 Regra R4)                                                                                                                                                                                                                                                                                                             |
| 232 | A teoria de grafos √© √∫til para analisar redes, sendo que o "grau" de um v√©rtice (degree centrality) indica o n√∫mero de vezes que esse v√©rtice aparece como intermedi√°rio nos caminhos mais curtos entre outros pares de v√©rtices.                                                                                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ O grau de um v√©rtice √© simplesmente o n√∫mero de ARESTAS conectadas diretamente a ele (quantos "amigos" diretos ele tem). üëç O n√∫mero de vezes que um v√©rtice √© intermedi√°rio em caminhos mais curtos √© a "centralidade de intermedia√ß√£o" (betweenness centrality). üí° **Dica:** Grau = Conex√µes diretas. Intermedia√ß√£o = Ser a ponte. (Cap√≠tulo 2, p. 124)                                                                                                                                                                                                                                                                                                                                                             |
| 233 | A √Ålgebra Relacional define operadores como Uni√£o (‚à™) e Interse√ß√£o (‚à©) que podem ser aplicados a quaisquer duas tabelas, independentemente do n√∫mero ou tipo de seus atributos.                                                                                                                                                                                                                                                                                                                                                      | F        | üë®‚Äçüè´ Uni√£o e Interse√ß√£o s√£o operadores cl√°ssicos da √°lgebra de conjuntos, aplicados a rela√ß√µes! üëç MAS, para us√°-los, as tabelas precisam ser "union-compat√≠veis": mesmo n√∫mero de colunas e tipos de dados compat√≠veis nas colunas correspondentes. N√£o d√° para unir uma tabela de "Carros" com uma de "Frutas" diretamente. üí° **Dica:** Uni√£o/Interse√ß√£o = Parceiros precisam ter a mesma "forma". (Cap√≠tulo 3, p. 161, 164)                                                                                                                                                                                                                                                                                             |
| 234 | Em SQL, a cl√°usula `WHERE` √© usada para especificar as colunas a serem retornadas pela consulta, enquanto a cl√°usula `SELECT` aplica condi√ß√µes de filtro √†s linhas da tabela.                                                                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ √â o oposto! `SELECT` lista as COLUNAS que voc√™ quer ver (ex: `SELECT nome, salario`). `WHERE` filtra as LINHAS com base em condi√ß√µes (ex: `WHERE salario > 5000`). üí° **Dica:** `SELECT` = O qu√™ (colunas). `WHERE` = Quais (linhas). (Cap√≠tulo 3, p. 177)                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 235 | O comando SQL `DELETE FROM Clientes` remove todas as colunas da tabela "Clientes", mas mant√©m todas as suas linhas (registros) intactas.                                                                                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ `DELETE FROM Clientes` (sem cl√°usula `WHERE`) remove TODAS AS LINHAS (registros) da tabela "Clientes". A estrutura da tabela (as colunas) permanece, mas ela fica vazia. Para remover colunas, usa-se `ALTER TABLE DROP COLUMN`. Para remover a tabela inteira (estrutura e dados), `DROP TABLE`. üí° **Dica:** `DELETE` = Adeus linhas. `ALTER TABLE` = Mexe nas colunas. `DROP TABLE` = Adeus tabela. (Cap√≠tulo 3, p. 179)                                                                                                                                                                                                                                                                                            |
| 236 | Um cursor em SQL permite que um programa processe um conjunto de tuplas retornado por um `SELECT` como uma √∫nica unidade, aplicando opera√ß√µes em lote a todas as tuplas simultaneamente.                                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ Um cursor √© como um "dedo" que permite processar o resultado de um `SELECT` TUPLA POR TUPLA (uma linha de cada vez) dentro de um loop na linguagem de programa√ß√£o. Ele n√£o processa em lote todas de uma vez; ele serializa o acesso. üí° **Dica:** Cursor = Um de cada vez. (Cap√≠tulo 3, p. 192)                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 237 | Valores `NULL` em SQL s√£o tratados como zero em opera√ß√µes aritm√©ticas e como string vazia em concatena√ß√µes, garantindo que as opera√ß√µes sempre produzam resultados definidos e n√£o nulos.                                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ `NULL` √© contagioso! ü§ß Qualquer opera√ß√£o aritm√©tica com `NULL` geralmente resulta em `NULL` (ex: `5 + NULL` √© `NULL`). Concatenar uma string com `NULL` tamb√©m pode resultar em `NULL` (depende do SGBD, mas √© comum). `NULL` significa "desconhecido", ent√£o o resultado da opera√ß√£o com ele tamb√©m √© desconhecido. üí° **Dica:** `NULL` + QualquerCoisa = `NULL` (geralmente). (Cap√≠tulo 3, p. 197-199)                                                                                                                                                                                                                                                                                                              |
| 238 | A propriedade de Isolamento (I) do ACID garante que os resultados de uma transa√ß√£o sejam permanentemente armazenados, mesmo em caso de falha do sistema ap√≥s o commit.                                                                                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ Isolamento (I) garante que transa√ß√µes concorrentes n√£o interfiram umas nas outras, como se estivessem sozinhas. üëç A propriedade que garante a persist√™ncia dos dados ap√≥s o commit, mesmo com falhas, √© a DURABILIDADE (D). üí° **Dica:** I = Isolado (sem ver os outros). D = Dur√°vel (n√£o some). (Cap√≠tulo 4, p. 218)                                                                                                                                                                                                                                                                                                                                                                                                |
| 239 | O protocolo de Bloqueio de Duas Fases (2PL) previne deadlocks ao garantir que todas as transa√ß√µes solicitem seus bloqueios em uma ordem predefinida e globalmente consistente.                                                                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ O 2PL garante SERIALIZABILIDADE (resultado correto com concorr√™ncia). üëç MAS ele N√ÉO previne deadlocks por si s√≥. Deadlocks podem ocorrer se transa√ß√µes se bloquearem mutuamente (A espera B, B espera A). A ordem de solicita√ß√£o de bloqueios pode ajudar, mas n√£o √© a ess√™ncia do 2PL para prevenir deadlocks. üí° **Dica:** 2PL ‚â† Anti-Deadlock autom√°tico. (Cap√≠tulo 4, p. 224, 226)                                                                                                                                                                                                                                                                                                                                |
| 240 | No Teorema CAP, a "Toler√¢ncia a Parti√ß√µes" (P) significa que o sistema pode tolerar falhas em qualquer componente de hardware, como discos r√≠gidos, sem que haja perda de dados ou interrup√ß√£o do servi√ßo.                                                                                                                                                                                                                                                                                                                           | F        | üë®‚Äçüè´ Toler√¢ncia a Parti√ß√µes (P) no CAP se refere especificamente √† capacidade do sistema distribu√≠do de continuar operando (de alguma forma) mesmo que haja uma FALHA DE COMUNICA√á√ÉO (uma "parti√ß√£o") entre os n√≥s da rede. üëç N√£o √© sobre tolerar falha de disco em um n√≥ (isso √© mais sobre redund√¢ncia de disco ou durabilidade local). üí° **Dica:** P do CAP = Rede quebrada, mas ainda tentamos funcionar. (Cap√≠tulo 4, p. 233)                                                                                                                                                                                                                                                                                        |
| 241 | O modelo BASE (Basically Available, Soft state, Eventually consistent) √© uma alternativa ao ACID que prioriza a Consist√™ncia forte e imediata dos dados em detrimento da Disponibilidade, sendo ideal para sistemas banc√°rios.                                                                                                                                                                                                                                                                                                       | F        | üë®‚Äçüè´ BASE √© o oposto! Ele prioriza DISPONIBILIDADE (Basically Available) e aceita que a consist√™ncia ser√° "eventual". üëç √â bom para sistemas que precisam estar sempre no ar e podem tolerar um pequeno atraso na propaga√ß√£o de atualiza√ß√µes (ex: redes sociais). Sistemas banc√°rios geralmente precisam de consist√™ncia forte (ACID). üí° **Dica:** BASE = Dispon√≠vel agora, consistente depois. ACID = Consistente agora! (Cap√≠tulo 4, p. 233, 241)                                                                                                                                                                                                                                                                        |
| 242 | A principal fun√ß√£o de um "checkpoint" em um log de transa√ß√µes √© marcar o ponto onde todas as transa√ß√µes futuras devem ser ignoradas durante o processo de recupera√ß√£o ap√≥s uma falha.                                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ Um checkpoint √© um ponto de sincronia. üëç Ele ajuda a REDUZIR o trabalho durante a recupera√ß√£o. O sistema sabe que todas as transa√ß√µes comitadas ANTES do checkpoint j√° tiveram seus dados escritos no disco. Assim, na recupera√ß√£o, s√≥ precisa se preocupar com transa√ß√µes ativas no momento do checkpoint ou iniciadas depois. N√£o √© para ignorar transa√ß√µes futuras. üí° **Dica:** Checkpoint = "At√© aqui, tudo certo e salvo no disco". (Cap√≠tulo 4, p. 231)                                                                                                                                                                                                                                                        |
| 243 | Dados semiestruturados, como JSON, possuem uma estrutura completamente r√≠gida e predefinida por um schema global, assim como os dados em tabelas relacionais, mas utilizam uma sintaxe baseada em texto.                                                                                                                                                                                                                                                                                                                             | F        | üë®‚Äçüè´ JSON √© semiestruturado, usando pares chave-valor e aninhamento, o que d√° estrutura! üëç Mas a beleza √© a FLEXIBILIDADE. N√£o h√° um schema global r√≠gido obrigat√≥rio como nos bancos relacionais. Cada objeto JSON pode ter uma estrutura ligeiramente diferente. üí° **Dica:** Semiestruturado = Estrutura flex√≠vel, n√£o r√≠gida. (Cap√≠tulo 5, p. 249)                                                                                                                                                                                                                                                                                                                                                                     |
| 244 | Uma √Årvore B, usada para indexa√ß√£o, √© uma estrutura onde cada n√≥ interno pode ter no m√°ximo dois filhos (sub√°rvores), e todos os dados dos registros indexados s√£o armazenados exclusivamente no n√≥ raiz.                                                                                                                                                                                                                                                                                                                            | F        | üë®‚Äçüè´ √Årvores B s√£o balanceadas e √≥timas para disco! üëç Mas cada n√≥ interno pode ter V√ÅRIOS filhos (mais que dois), o que as torna "largas" e "rasas", bom para poucos acessos a disco. Os dados (ou ponteiros para eles) est√£o distribu√≠dos pelos n√≥s, especialmente nas folhas em algumas variantes como B+ Tree, n√£o s√≥ na raiz. üí° **Dica:** √Årvore B = Muitos filhos por n√≥, baixa altura. (Cap√≠tulo 5, p. 253, 255)                                                                                                                                                                                                                                                                                                    |
| 245 | A otimiza√ß√£o de consultas relacionais por transforma√ß√£o alg√©brica altera a sem√¢ntica da consulta original para encontrar um plano de execu√ß√£o mais r√°pido, podendo retornar um conjunto de resultados diferente, por√©m mais eficiente.                                                                                                                                                                                                                                                                                               | F        | üë®‚Äçüè´ A otimiza√ß√£o alg√©brica REESCREVE a consulta em formas equivalentes que produzem o MESMO RESULTADO, mas com um custo menor! üëç A sem√¢ntica (o significado, o que a consulta pede) n√£o pode mudar. O objetivo √© ser mais r√°pido, mas entregando a resposta correta. üí° **Dica:** Otimiza√ß√£o = Mesma resposta, caminho mais curto. (Cap√≠tulo 5, p. 270)                                                                                                                                                                                                                                                                                                                                                                   |
| 246 | Em um banco de dados temporal, o "tempo de transa√ß√£o" indica o per√≠odo durante o qual um fato √© verdadeiro no mundo real, sendo que este per√≠odo √© sempre definido pelo usu√°rio e n√£o pelo sistema.                                                                                                                                                                                                                                                                                                                                  | F        | üë®‚Äçüè´ O "tempo de transa√ß√£o" √© quando o DADO FOI REGISTRADO OU ALTERADO NO BANCO. üëç √â geralmente gerenciado pelo SISTEMA (com timestamps autom√°ticos). O per√≠odo em que o fato √© verdadeiro no mundo real √© o "tempo de VALIDADE". üí° **Dica:** Transa√ß√£o = Quando o BD soube. Validade = Quando aconteceu de verdade. (Cap√≠tulo 6, p. 300)                                                                                                                                                                                                                                                                                                                                                                                 |
| 247 | Um esquema floco de neve (snowflake schema) √© uma estrutura onde m√∫ltiplas tabelas de fatos compartilham um conjunto comum de tabelas de dimens√£o altamente desnormalizadas.                                                                                                                                                                                                                                                                                                                                                         | F        | üë®‚Äçüè´ Um esquema floco de neve tem UMA tabela de fatos central (como o estrela). üëç A diferen√ßa √© que suas tabelas de DIMENS√ÉO podem ser NORMALIZADAS em outras tabelas de dimens√£o menores, criando uma estrutura que lembra os "bra√ßos" de um floco de neve. N√£o s√£o m√∫ltiplas tabelas de fatos compartilhando dimens√µes desnormalizadas. üí° **Dica:** Floco de Neve = Dimens√µes com "bracinhos" normalizados. (Cap√≠tulo 6, p. 306, 308)                                                                                                                                                                                                                                                                                   |
| 248 | Um Data Warehouse (DWH) √© um sistema otimizado para escrita frequente de dados transacionais vol√°teis, sendo que a an√°lise de dados hist√≥ricos √© uma funcionalidade secund√°ria e raramente utilizada.                                                                                                                                                                                                                                                                                                                                | F        | üë®‚Äçüè´ Um DWH √© focado em AN√ÅLISE de dados HIST√ìRICOS e consolidados! üëç As escritas (cargas de dados) s√£o menos frequentes (ex: di√°rias, semanais) e os dados s√£o geralmente n√£o vol√°teis (read-only ap√≥s a carga). O dia-a-dia transacional √© com os sistemas OLTP. üí° **Dica:** DWH = Museu dos dados para estudo. (Cap√≠tulo 6, p. 309-310)                                                                                                                                                                                                                                                                                                                                                                                |
| 249 | Bancos de dados NoSQL do tipo chave-valor permitem armazenar um valor para cada chave, e o "valor" deve ser sempre uma estrutura JSON complexa para facilitar consultas aninhadas.                                                                                                                                                                                                                                                                                                                                                   | F        | üë®‚Äçüè´ Chave-valor √© super simples: uma chave aponta para um valor. üëç Esse VALOR pode ser qualquer coisa: uma string, um n√∫mero, um blob bin√°rio, ou sim, um JSON. Mas N√ÉO √© obrigat√≥rio que seja JSON ou complexo. Pode ser um simples contador. üí° **Dica:** Valor em KV = O que voc√™ quiser guardar. (Cap√≠tulo 7, p. 345)                                                                                                                                                                                                                                                                                                                                                                                                 |
| 250 | A "index-free adjacency" em bancos de grafos garante que qualquer consulta por propriedades de n√≥s, mesmo que n√£o envolvam relacionamentos diretos, seja executada em tempo constante, independentemente do tamanho do grafo.                                                                                                                                                                                                                                                                                                        | F        | üë®‚Äçüè´ "Index-free adjacency" √© para travessia R√ÅPIDA para VIZINHOS DIRETOS. üëç Se voc√™ quer buscar um n√≥ por uma PROPRIEDADE (ex: "todos os usu√°rios com idade > 30"), voc√™ ainda precisa de um √çNDICE naquela propriedade para ser r√°pido, sen√£o teria que varrer todos os n√≥s. üí° **Dica:** Vizinhos diretos = R√°pido sem √≠ndice. Busca por propriedade = Precisa de √≠ndice. (Cap√≠tulo 7, p. 366)                                                                                                                                                                                                                                                                                                                          |
| 251 | A informa√ß√£o digital pode ser facilmente copiada e transmitida, e sua representa√ß√£o atrav√©s de dados permite que algoritmos complexos sejam aplicados para processamento, categoriza√ß√£o e convers√£o entre diferentes formatos.                                                                                                                                                                                                                                                                                                       | V        | üë®‚Äçüè´ A primeira parte √© b√°sica: copiar e enviar bits √© f√°cil! üëç A parte avan√ßada √© que, por ser digital, podemos usar programas (algoritmos) para fazer coisas incr√≠veis com ela: organizar e-mails, traduzir textos, recomendar m√∫sicas, tudo isso √© processamento de dados. üí° **Dica:** Digital = Dados = Poder de Processamento. (Cap√≠tulo 1, p. 26)                                                                                                                                                                                                                                                                                                                                                                   |
| 252 | Um Sistema de Gerenciamento de Banco de Dados (SGBD) armazena dados de forma organizada, e al√©m disso, ele fornece mecanismos para garantir a independ√™ncia de dados f√≠sica, permitindo altera√ß√µes na infraestrutura de armazenamento sem impactar as aplica√ß√µes.                                                                                                                                                                                                                                                                    | V        | üë®‚Äçüè´ Guardar dados organizados √© o "feij√£o com arroz" de um SGBD. üëç A parte mais sofisticada √© que ele cria uma camada de abstra√ß√£o (independ√™ncia f√≠sica) para que as aplica√ß√µes n√£o precisem saber se o dado est√° num HD, SSD ou na nuvem, nem como est√° indexado. Isso d√° muita flexibilidade. üí° **Dica:** SGBD = Organiza + Esconde a bagun√ßa f√≠sica. (Cap√≠tulo 1, p. 28, 38)                                                                                                                                                                                                                                                                                                                                         |
| 253 | No modelo relacional, uma tabela √© composta por linhas (tuplas) e colunas (atributos), e a defini√ß√£o precisa desses atributos, incluindo seus dom√≠nios (tipos de dados), √© fundamental para a integridade e consist√™ncia dos dados armazenados.                                                                                                                                                                                                                                                                                      | V        | üë®‚Äçüè´ Linhas e colunas √© o b√°sico de uma tabela! üëç A parte mais profunda √© que definir o "tipo" de cada coluna (ex: essa coluna s√≥ aceita n√∫meros, essa s√≥ datas) √© crucial. Isso se chama dom√≠nio do atributo e ajuda a evitar que dados errados entrem, mantendo a qualidade. üí° **Dica:** Dom√≠nio do atributo = Regras do que pode entrar na coluna. (Cap√≠tulo 1, p. 30, 32; Cap√≠tulo 2, p. 109)                                                                                                                                                                                                                                                                                                                         |
| 254 | Big Data √© frequentemente caracterizado pelo grande volume de dados, e al√©m disso, a "Veracity" (Veracidade) dos dados em Big Data exige o desenvolvimento de algoritmos e m√©todos para avaliar a qualidade e a confiabilidade dos resultados anal√≠ticos.                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Muito dado √© o √≥bvio do Big Data! üëç Mas a "Veracidade" adiciona uma camada de complexidade: como os dados podem ser "sujos" ou incertos, precisamos de t√©cnicas espertas para limpar, validar e entender o qu√£o confi√°veis s√£o as conclus√µes que tiramos deles. üí° **Dica:** Big Data + Veracidade = Lidar com a imperfei√ß√£o dos dados em grande escala. (Cap√≠tulo 1, p. 39, 41)                                                                                                                                                                                                                                                                                                                                      |
| 255 | Um grafo de propriedades consiste em n√≥s e arestas que podem ter propriedades, e a linguagem Cypher, utilizada em bancos de grafos como Neo4j, √© declarativa e permite a especifica√ß√£o de padr√µes de busca complexos atrav√©s da travessia de relacionamentos.                                                                                                                                                                                                                                                                        | V        | üë®‚Äçüè´ N√≥s e arestas com "etiquetas" (propriedades) √© o b√°sico do modelo! üëç O pulo do gato √© que linguagens como Cypher permitem que voc√™ diga "encontre pessoas que s√£o amigas de amigos de algu√©m que trabalha em uma empresa X", descrevendo o padr√£o, e o banco se vira para achar. üí° **Dica:** Cypher = Descreva o padr√£o no grafo, e ele acha. (Cap√≠tulo 1, p. 42, 45-46)                                                                                                                                                                                                                                                                                                                                             |
| 256 | A organiza√ß√£o de Data Management inclui a defini√ß√£o da arquitetura de dados, e um aspecto avan√ßado dessa arquitetura √© o alinhamento com os modelos de dados da ind√∫stria e a promo√ß√£o de uma vis√£o unificada dos dados corporativos.                                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ Definir como os dados s√£o estruturados √© fundamental. üëç Um n√≠vel mais estrat√©gico √© garantir que essa estrutura "converse" com padr√µes do mercado (modelos da ind√∫stria) e que diferentes √°reas da empresa vejam os dados de forma consistente, evitando silos de informa√ß√£o. üí° **Dica:** Arquitetura de dados inteligente = Vis√£o integrada e padronizada. (Cap√≠tulo 1, p. 52-54; Cap√≠tulo 2, p. 143-144)                                                                                                                                                                                                                                                                                                           |
| 257 | No Modelo Entidade-Relacionamento, entidades representam objetos do mundo real e relacionamentos conectam essas entidades, sendo que a an√°lise de cardinalidade (ex: 1:N, N:M) √© crucial para determinar as regras de mapeamento para o modelo relacional.                                                                                                                                                                                                                                                                           | V        | üë®‚Äçüè´ Entidades e relacionamentos s√£o o ABC do ER! üëç A cardinalidade √© o que nos diz como transformar esses relacionamentos em tabelas no mundo relacional. Um N:M vira uma tabela de jun√ß√£o, um 1:N pode ser uma chave estrangeira, etc. üí° **Dica:** Cardinalidade no ER dita a "receita" das tabelas relacionais. (Cap√≠tulo 2, p. 65, 68-70, 97-102)                                                                                                                                                                                                                                                                                                                                                                     |
| 258 | A Primeira Forma Normal (1FN) exige que os valores dos atributos sejam at√¥micos (indivis√≠veis), e a satisfa√ß√£o das formas normais subsequentes (2FN, 3FN, BCNF) visa eliminar anomalias de dados atrav√©s da an√°lise de depend√™ncias funcionais e multivaloradas.                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ 1FN √© sobre n√£o ter "listas dentro das c√©lulas", simples! üëç As formas normais seguintes v√£o mais fundo, analisando como os atributos dependem uns dos outros (depend√™ncias funcionais) e como grupos de valores se relacionam (multivaloradas), tudo para deixar a tabela mais "limpa" e sem problemas. üí° **Dica:** Normaliza√ß√£o = Limpeza progressiva baseada em depend√™ncias. (Cap√≠tulo 2, p. 78-95)                                                                                                                                                                                                                                                                                                               |
| 259 | A integridade referencial em bancos de dados relacionais √© mantida por chaves estrangeiras que apontam para chaves prim√°rias, e as regras de cascata (ON DELETE CASCADE, ON UPDATE CASCADE) definem o comportamento autom√°tico do SGBD em tuplas dependentes.                                                                                                                                                                                                                                                                        | V        | üë®‚Äçüè´ Chave estrangeira apontando para prim√°ria √© o b√°sico da refer√™ncia! üëç O "plus" √© que voc√™ pode dizer ao banco: "Se eu apagar esse pai, apague todos os filhos automaticamente" (CASCADE). Isso ajuda a manter a consist√™ncia sem que a aplica√ß√£o precise fazer manualmente. üí° **Dica:** Cascata = Efeito domin√≥ controlado pelo SGBD. (Cap√≠tulo 2, p. 109, 111-112; Cap√≠tulo 3, p. 203)                                                                                                                                                                                                                                                                                                                              |
| 260 | A teoria de grafos utiliza n√≥s e arestas para representar estruturas, e algoritmos como o de Dijkstra s√£o fundamentais para resolver problemas de otimiza√ß√£o, como encontrar o caminho de menor custo em redes ponderadas.                                                                                                                                                                                                                                                                                                           | V        | üë®‚Äçüè´ N√≥s e arestas √© a defini√ß√£o de grafo! üëç O legal √© que com algoritmos como o de Dijkstra, podemos responder perguntas como "qual o caminho mais r√°pido no Waze?", onde as ruas s√£o arestas com pesos (dist√¢ncia/tempo). üí° **Dica:** Dijkstra = GPS dos grafos. (Cap√≠tulo 2, p. 113, 115-120)                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 261 | Um sociograma representa rela√ß√µes em um grupo social como um grafo, e m√©tricas como a centralidade de betweenness (intermedia√ß√£o) ajudam a identificar indiv√≠duos que atuam como pontes importantes no fluxo de informa√ß√£o da rede.                                                                                                                                                                                                                                                                                                  | V        | üë®‚Äçüè´ Sociograma √© o "mapa social" como um grafo. üëç A centralidade de betweenness vai al√©m de quem tem mais amigos diretos; ela mostra quem est√° no meio de muitos caminhos, sendo crucial para a comunica√ß√£o e coes√£o do grupo. üí° **Dica:** Betweenness = O "conector" da galera. (Cap√≠tulo 2, p. 124, 127)                                                                                                                                                                                                                                                                                                                                                                                                               |
| 262 | A √Ålgebra Relacional possui operadores b√°sicos como Sele√ß√£o e Proje√ß√£o, e sua propriedade de fechamento (closure) permite que o resultado de uma opera√ß√£o seja entrada para outra, possibilitando a constru√ß√£o de consultas complexas.                                                                                                                                                                                                                                                                                               | V        | üë®‚Äçüè´ Selecionar linhas e projetar colunas √© o b√°sico! üëç A "m√°gica" da √°lgebra relacional √© que, como cada opera√ß√£o retorna uma NOVA TABELA (rela√ß√£o), voc√™ pode encadear opera√ß√µes indefinidamente, construindo consultas cada vez mais sofisticadas. √â como Lego! üß± üí° **Dica:** Fechamento = O resultado de uma opera√ß√£o √© do mesmo tipo da entrada. (Cap√≠tulo 3, p. 161)                                                                                                                                                                                                                                                                                                                                               |
| 263 | Em SQL, `SELECT` especifica as colunas desejadas e `FROM` as tabelas de origem, enquanto jun√ß√µes (`JOIN`) s√£o usadas para combinar dados de m√∫ltiplas tabelas com base em predicados relacionais, sendo o `EQUIJOIN` um tipo comum que usa igualdade.                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ `SELECT` e `FROM` √© o come√ßo de toda consulta SQL! üëç A parte mais elaborada √© o `JOIN`, que permite "costurar" tabelas. O `EQUIJOIN` (ex: `ON tabelaA.id = tabelaB.id_A`) √© o tipo mais frequente, onde voc√™ junta linhas que t√™m valores iguais nas colunas de liga√ß√£o. üí° **Dica:** `JOIN` = A cola das tabelas relacionais. (Cap√≠tulo 3, p. 170, 177)                                                                                                                                                                                                                                                                                                                                                              |
| 264 | O comando `INSERT INTO` em SQL adiciona novas linhas a uma tabela, e Stored Procedures podem encapsular l√≥gicas de inser√ß√£o complexas, incluindo valida√ß√µes e inser√ß√µes em m√∫ltiplas tabelas de forma transacional.                                                                                                                                                                                                                                                                                                                  | V        | üë®‚Äçüè´ Inserir uma linha √© trivial. üëç O avan√ßado √© que voc√™ pode criar um "mini-programa" (Stored Procedure) no banco que, ao ser chamado, faz v√°rias verifica√ß√µes, talvez insira dados em 3 tabelas diferentes, e garante que ou tudo d√° certo, ou nada √© feito (transa√ß√£o). üí° **Dica:** Stored Procedure = L√≥gica de neg√≥cio reutiliz√°vel dentro do BD. (Cap√≠tulo 3, p. 179, 193)                                                                                                                                                                                                                                                                                                                                         |
| 265 | A presen√ßa de valores `NULL` em SQL indica dados ausentes ou desconhecidos, e a l√≥gica de tr√™s valores (TRUE, FALSE, UNKNOWN) que surge com `NULL` afeta o resultado de condi√ß√µes `WHERE` e jun√ß√µes, exigindo tratamento espec√≠fico (ex: `IS NULL`, `COALESCE`).                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ `NULL` √© o "n√£o sei"! üëç O problema √© que "n√£o sei" comparado com qualquer coisa geralmente d√° "n√£o sei" (UNKNOWN). Isso pode bugar suas condi√ß√µes. Por isso, existem fun√ß√µes como `IS NULL` (para checar se √© nulo) e `COALESCE` (para dar um valor padr√£o se for nulo). üí° **Dica:** `NULL` requer cuidado especial nas compara√ß√µes. (Cap√≠tulo 3, p. 197-199)                                                                                                                                                                                                                                                                                                                                                        |
| 266 | As views em SQL s√£o tabelas virtuais baseadas em consultas armazenadas, e a sua utiliza√ß√£o pode simplificar consultas complexas e implementar seguran√ßa em n√≠vel de coluna ou linha, restringindo o acesso aos dados subjacentes.                                                                                                                                                                                                                                                                                                    | V        | üë®‚Äçüè´ View √© uma "consulta salva com nome"! üëç O poder delas est√° em esconder a complexidade de uma super `JOIN` ou em mostrar s√≥ algumas colunas/linhas para certos usu√°rios, funcionando como uma camada de seguran√ßa ou simplifica√ß√£o. üí° **Dica:** View = Uma janela customizada para seus dados. (Cap√≠tulo 3, p. 206-208)                                                                                                                                                                                                                                                                                                                                                                                               |
| 267 | Uma transa√ß√£o ACID deve ser At√¥mica (tudo ou nada), e a Consist√™ncia (C) garante que a transa√ß√£o leve o banco de dados de um estado v√°lido para outro, respeitando todas as regras de integridade definidas (constraints).                                                                                                                                                                                                                                                                                                           | V        | üë®‚Äçüè´ Atomicidade √© o b√°sico: ou faz tudo ou n√£o faz nada. üëç A Consist√™ncia √© mais sutil: ela garante que as "leis" do banco (chaves prim√°rias, estrangeiras, checks) nunca sejam violadas ao final da transa√ß√£o. Se a transa√ß√£o fosse quebrar uma regra, ela seria desfeita. üí° **Dica:** C de ACID = Mantendo as regras do jogo. (Cap√≠tulo 4, p. 218)                                                                                                                                                                                                                                                                                                                                                                     |
| 268 | O protocolo de Bloqueio de Duas Fases (2PL) √© um m√©todo pessimista de controle de concorr√™ncia que ajuda a garantir a serializabilidade, e sua variante "Strict 2PL" exige que todos os bloqueios (de leitura e escrita) sejam mantidos at√© o commit/rollback da transa√ß√£o.                                                                                                                                                                                                                                                          | V        | üë®‚Äçüè´ 2PL usa bloqueios para evitar bagun√ßa (pessimista). üëç O "Strict 2PL" √© ainda mais cuidadoso: ele s√≥ solta os "brinquedos" (bloqueios) no finalzinho da brincadeira (commit/rollback). Isso evita problemas como leituras de dados que outra transa√ß√£o ainda n√£o confirmou (leituras sujas). üí° **Dica:** Strict 2PL = Segura os bloqueios at√© o amargo fim. (Cap√≠tulo 4, p. 224, embora o "Strict" n√£o seja detalhado, o conceito de manter bloqueios √© central)                                                                                                                                                                                                                                                      |
| 269 | O Teorema CAP afirma que em um sistema distribu√≠do s√≥ se pode ter duas de tr√™s garantias (Consist√™ncia, Disponibilidade, Toler√¢ncia a Parti√ß√µes), e a escolha entre CP e AP influencia diretamente o design de sistemas NoSQL para diferentes casos de uso.                                                                                                                                                                                                                                                                          | V        | üë®‚Äçüè´ O CAP √© o dilema fundamental dos sistemas distribu√≠dos! üëç E essa escolha √© crucial: um sistema financeiro pode preferir CP (Consist√™ncia e Toler√¢ncia, mesmo que fique indispon√≠vel √†s vezes). Um cat√°logo de produtos pode preferir AP (Dispon√≠vel e Tolerante, mesmo que mostre um pre√ßo antigo por alguns segundos). üí° **Dica:** CAP dita as prioridades do seu NoSQL distribu√≠do. (Cap√≠tulo 4, p. 233-234)                                                                                                                                                                                                                                                                                                       |
| 270 | O modelo BASE (Basically Available, Soft state, Eventually consistent) √© comum em sistemas NoSQL, e a "consist√™ncia eventual" implica que, se nenhuma nova atualiza√ß√£o for feita, todas as r√©plicas acabar√£o convergindo para o mesmo valor.                                                                                                                                                                                                                                                                                         | V        | üë®‚Äçüè´ BASE aceita que as coisas podem n√£o estar 100% sincronizadas o tempo todo. üëç "Eventualmente consistente" √© a promessa de que, com o tempo e sem novas mudan√ßas, todo mundo vai ver a mesma coisa. √â como um boato que se espalha e, eventualmente, todos ouvem a mesma vers√£o. üí° **Dica:** Consist√™ncia eventual = Paci√™ncia, que os dados chegam l√°. (Cap√≠tulo 4, p. 233, 241)                                                                                                                                                                                                                                                                                                                                      |
| 271 | A recupera√ß√£o de banco de dados ap√≥s uma falha utiliza um log de transa√ß√µes, e o processo de "redo" aplica novamente as opera√ß√µes de transa√ß√µes comitadas que podem n√£o ter sido escritas no disco antes da falha.                                                                                                                                                                                                                                                                                                                   | V        | üë®‚Äçüè´ O log √© a caixa-preta do BD! ‚úàÔ∏è üëç Na recupera√ß√£o, o "redo" √© como dar "replay" nas a√ß√µes das transa√ß√µes que j√° tinham sido confirmadas (commit) mas que, por causa da falha, talvez n√£o tenham chegado a ser salvas permanentemente no disco. Isso garante a durabilidade. üí° **Dica:** Redo = Refazer o que j√° estava certo. (Cap√≠tulo 4, p. 231-232)                                                                                                                                                                                                                                                                                                                                                                |
| 272 | Dados estruturados s√£o organizados em formatos predefinidos como tabelas, e o schema do banco de dados relacional define rigorosamente os tipos de dados e as restri√ß√µes de integridade para esses dados.                                                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Tabelas com linhas e colunas √© o cl√°ssico de dados estruturados! üëç O schema √© o "contrato" que diz exatamente como cada coluna deve ser (texto, n√∫mero, data) e quais regras n√£o podem ser quebradas (ex: CPF √∫nico, idade > 18). üí° **Dica:** Schema = As leis dos dados estruturados. (Cap√≠tulo 5, p. 248)                                                                                                                                                                                                                                                                                                                                                                                                          |
| 273 | √çndices como √Årvores B s√£o usados para acelerar consultas em bancos de dados, e uma √Årvore B+ (B plus tree) otimiza ainda mais as varreduras em faixa (range scans) ao armazenar todos os dados/ponteiros apenas nos n√≥s folha, que s√£o encadeados.                                                                                                                                                                                                                                                                                  | V        | üë®‚Äçüè´ √çndices s√£o os "atalhos" para achar dados r√°pido! üëç A √Årvore B+ vai um passo al√©m: ela coloca todos os "tesouros" (dados ou ponteiros) s√≥ nas folhas, e essas folhas s√£o ligadas como uma lista. Isso torna super eficiente pegar sequ√™ncias de dados (ex: todos os clientes com nome come√ßando com "A" at√© "C"). üí° **Dica:** B+ Tree = √ìtima para "pegar um peda√ßo" ordenado dos dados. (Cap√≠tulo 5, p. 252, 255-256)                                                                                                                                                                                                                                                                                               |
| 274 | O algoritmo MapReduce processa dados em paralelo com uma fase Map e uma Reduce, e a fase "shuffle and sort" intermedi√°ria √© crucial para agrupar os dados emitidos pela fase Map pela chave, antes de serem processados pela fase Reduce.                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Map e Reduce s√£o as estrelas! üëç Mas entre elas tem um passo importante escondido: o "shuffle and sort". Depois que o Map produz seus pares chave-valor, esses pares s√£o embaralhados e ordenados pela chave, para que o Reduce receba todos os valores de uma mesma chave juntos. üí° **Dica:** MapReduce = Map -> Shuffle/Sort -> Reduce. (Cap√≠tulo 5, p. 277-278, a ordena√ß√£o √© mencionada)                                                                                                                                                                                                                                                                                                                          |
| 275 | A arquitetura em camadas de um SGBD divide o sistema em m√≥dulos independentes, e a "Layer 2: Record-oriented Interface" √© respons√°vel por converter registros l√≥gicos em estruturas f√≠sicas e gerenciar transa√ß√µes, utilizando conceitos como cursores.                                                                                                                                                                                                                                                                              | V        | üë®‚Äçüè´ Camadas organizam a casa! üëç A Camada 2 √© a "tradutora" que pega os pedidos l√≥gicos de registros e os transforma em algo que as camadas mais baixas entendam fisicamente. √â aqui que o cursor (para processar linha a linha) e o gerenciamento de transa√ß√µes (para garantir ACID) entram em jogo. üí° **Dica:** Camada 2 = L√≥gica para o f√≠sico, com transa√ß√µes e cursores. (Cap√≠tulo 5, p. 281-282)                                                                                                                                                                                                                                                                                                                    |
| 276 | Bancos de dados federados permitem o acesso a dados distribu√≠dos em m√∫ltiplos sistemas como se fossem um √∫nico banco, e um otimizador de consulta global √© essencial para determinar estrat√©gias eficientes de execu√ß√£o que minimizem a movimenta√ß√£o de dados.                                                                                                                                                                                                                                                                       | V        | üë®‚Äçüè´ Acesso unificado a dados espalhados √© a promessa! üëç O desafio (e a parte avan√ßada) √© ter um "c√©rebro" (otimizador global) que saiba onde cada peda√ßo de dado est√° e como juntar as informa√ß√µes da forma mais barata e r√°pida, decidindo se faz uma parte da consulta aqui, outra ali, e como combina os resultados. üí° **Dica:** Federado = Um chefe para muitos oper√°rios distribu√≠dos. (Cap√≠tulo 6, p. 295, 297-298)                                                                                                                                                                                                                                                                                                |
| 277 | Bancos de dados temporais gerenciam dados ao longo do tempo, e a distin√ß√£o entre "tempo de validade" (quando um fato √© verdadeiro no mundo real) e "tempo de transa√ß√£o" (quando o banco registrou o fato) permite a reconstru√ß√£o bitemporal da hist√≥ria dos dados.                                                                                                                                                                                                                                                                   | V        | üë®‚Äçüè´ Gerenciar o tempo √© o b√°sico! üëç O conceito bitemporal √© poderoso: voc√™ pode perguntar "Qual era o sal√°rio do Jo√£o em Jan/2020, de acordo com o que o banco sabia em Fev/2020?". Isso permite auditorias precisas e entender n√£o s√≥ o que aconteceu, mas quando o sistema soube. üí° **Dica:** Bitemporal = Viagem no tempo em duas dimens√µes! (Cap√≠tulo 6, p. 300, 303)                                                                                                                                                                                                                                                                                                                                                |
| 278 | Um Data Warehouse (DWH) consolida dados de diversas fontes para an√°lise, e a utiliza√ß√£o de um esquema estrela ou floco de neve com tabelas de fatos e dimens√µes √© uma pr√°tica comum para modelar os dados de forma otimizada para consultas OLAP.                                                                                                                                                                                                                                                                                    | V        | üë®‚Äçüè´ DWH junta tudo para analisar, certo! üëç A modelagem em estrela/floco de neve √© um padr√£o porque organiza os dados de forma que as ferramentas OLAP (para fatiar, agregar, detalhar) consigam trabalhar de forma eficiente, com jun√ß√µes previs√≠veis entre fatos (os n√∫meros) e dimens√µes (o contexto). üí° **Dica:** DWH + Estrela/Floco = Playground do analista. (Cap√≠tulo 6, p. 304, 306, 309-310)                                                                                                                                                                                                                                                                                                                    |
| 279 | O Mapeamento Objeto-Relacional (ORM) facilita a persist√™ncia de objetos de linguagens OO em bancos de dados relacionais, e ferramentas ORM frequentemente geram o SQL necess√°rio para opera√ß√µes CRUD, abstraindo o desenvolvedor dos detalhes da linguagem SQL.                                                                                                                                                                                                                                                                      | V        | üë®‚Äçüè´ ORM faz a ponte entre mundos diferentes! üëç A grande ajuda √© que, em vez de escrever `INSERT`, `SELECT`, `UPDATE`, `DELETE` na m√£o, o desenvolvedor manipula objetos na sua linguagem (Java, C#), e o ORM se vira para traduzir isso em SQL e conversar com o banco. üí° **Dica:** ORM = SQL por baixo dos panos, objetos por cima. (Cap√≠tulo 6, p. 318-320)                                                                                                                                                                                                                                                                                                                                                            |
| 280 | Bancos de dados fuzzy permitem o armazenamento de dados imprecisos ou vagos, e a utiliza√ß√£o de fun√ß√µes de pertin√™ncia (membership functions) define o grau em que um objeto pertence a um conjunto fuzzy, permitindo consultas com termos lingu√≠sticos.                                                                                                                                                                                                                                                                              | V        | üë®‚Äçüè´ Lidar com "mais ou menos" √© a ideia! üëç As fun√ß√µes de pertin√™ncia s√£o a matem√°tica por tr√°s: elas dizem o qu√£o "membro" um item √© de um conceito vago (ex: "sal√°rio ALTO"). Com isso, voc√™ pode perguntar "clientes com sal√°rio MAIS OU MENOS alto" e obter resultados graduados. üí° **Dica:** Fuzzy = Graus de verdade com fun√ß√µes de pertin√™ncia. (Cap√≠tulo 6, p. 326-327, 330)                                                                                                                                                                                                                                                                                                                                      |
| 281 | Bancos de dados NoSQL como os chave-valor s√£o frequentemente schema-less, o que oferece flexibilidade, e essa aus√™ncia de esquema na escrita (schema-on-write) transfere a responsabilidade da interpreta√ß√£o da estrutura dos dados para a aplica√ß√£o no momento da leitura (schema-on-read).                                                                                                                                                                                                                                         | V        | üë®‚Äçüè´ Schema-less √© a marca da flexibilidade! üëç O "pre√ßo" dessa liberdade √© que, se o banco n√£o imp√µe regras na entrada, quem vai ler (a aplica√ß√£o) precisa saber o que esperar ou como lidar com diferentes formatos. A "intelig√™ncia" do esquema vai para a aplica√ß√£o. üí° **Dica:** Schema-on-read = A aplica√ß√£o decifra o que o banco guardou. (Cap√≠tulo 7, p. 344, 345)                                                                                                                                                                                                                                                                                                                                                 |
| 282 | Bancos de dados orientados a documentos armazenam dados em formatos como JSON ou BSON, e a capacidade de embutir (embed) estruturas de dados relacionadas dentro de um √∫nico documento pode otimizar leituras ao evitar jun√ß√µes (joins) custosas.                                                                                                                                                                                                                                                                                    | V        | üë®‚Äçüè´ Documentos guardam "mini-√°rvores" de dados. üëç Se voc√™ tem um blog post e seus coment√°rios, em vez de duas tabelas e um join, voc√™ pode colocar os coment√°rios DENTRO do documento do post. Na hora de ler o post, os coment√°rios j√° v√™m junto, sem join! üí° **Dica:** Embutir em documento = Menos joins, leitura mais r√°pida para dados relacionados. (Cap√≠tulo 7, p. 353)                                                                                                                                                                                                                                                                                                                                           |
| 283 | Bancos de dados orientados a colunas (Column-Family Stores) agrupam colunas em fam√≠lias, e essa estrutura, combinada com o armazenamento colunar, √© altamente eficiente para consultas anal√≠ticas que agregam valores sobre um grande n√∫mero de linhas, mas apenas de um subconjunto de colunas.                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Organizar por fam√≠lias de colunas √© o b√°sico. üëç A efici√™ncia vem porque, se voc√™ quer calcular a M√âDIA DE PRE√áO de milh√µes de produtos, mas s√≥ precisa da coluna "Pre√ßo", o banco l√™ apenas essa coluna do disco, ignorando todas as outras (descri√ß√£o, categoria, etc.). Isso √© muito mais r√°pido! üí° **Dica:** Column-family = Leia s√≥ o que precisa na vertical. (Cap√≠tulo 7, p. 349-352)                                                                                                                                                                                                                                                                                                                          |
| 284 | Bancos de dados orientados a grafos representam dados como n√≥s e relacionamentos, e a propriedade de "index-free adjacency" permite travessias eficientes entre n√≥s vizinhos, tornando-os ideais para an√°lises de caminhos e centralidade em redes.                                                                                                                                                                                                                                                                                  | V        | üë®‚Äçüè´ Grafos s√£o sobre conex√µes! üëç A "index-free adjacency" significa que ir de um n√≥ para seus vizinhos √© direto e r√°pido. Isso √© perfeito para perguntas como "Qual o caminho mais curto entre A e Z?" ou "Quem √© a pessoa mais conectada nesta rede social?". üí° **Dica:** Grafo + Index-free Adjacency = Navega√ß√£o super-r√°pida nos relacionamentos. (Cap√≠tulo 7, p. 364, 366)                                                                                                                                                                                                                                                                                                                                          |
| 285 | A persist√™ncia poliglota envolve o uso de diferentes tipos de bancos de dados em uma mesma aplica√ß√£o, e essa abordagem permite escolher o modelo de dados e as caracter√≠sticas de consist√™ncia/escalabilidade mais adequados para cada microsservi√ßo ou componente espec√≠fico.                                                                                                                                                                                                                                                       | V        | üë®‚Äçüè´ Usar v√°rias ferramentas √© o trivial. üëç A parte avan√ßada √© que, em arquiteturas de microsservi√ßos, cada servi√ßo pode ter seu pr√≥prio "mini-banco de dados" otimizado para sua fun√ß√£o. Um microsservi√ßo de cat√°logo de produtos pode usar um NoSQL de documento, enquanto o de pedidos usa um relacional. üí° **Dica:** Poliglota + Microsservi√ßos = Cada um com seu banco ideal. (Cap√≠tulo 7, p. 344)                                                                                                                                                                                                                                                                                                                   |
| 286 | O sharding em bancos de dados NoSQL distribui dados entre m√∫ltiplos n√≥s, e o uso de "consistent hashing" minimiza a quantidade de dados que precisam ser remanejados quando n√≥s s√£o adicionados ou removidos do cluster.                                                                                                                                                                                                                                                                                                             | V        | üë®‚Äçüè´ Dividir os dados (sharding) √© o b√°sico para escalar. üëç O "consistent hashing" √© a t√©cnica inteligente que faz com que, se um servidor novo entra na "roda" ou um antigo sai, s√≥ os vizinhos imediatos no "anel de hash" s√£o afetados. A maioria dos dados n√£o precisa se mexer. üí° **Dica:** Consistent Hashing = Reorganiza√ß√£o distribu√≠da com o m√≠nimo de bagun√ßa. (Cap√≠tulo 5, p. 259-261; Cap√≠tulo 7, p. 346)                                                                                                                                                                                                                                                                                                     |
| 287 | Bancos de dados XML nativos s√£o projetados para armazenar e consultar documentos XML eficientemente, e a linguagem XQuery, com suporte a express√µes XPath, permite a navega√ß√£o e transforma√ß√£o de estruturas XML hier√°rquicas complexas.                                                                                                                                                                                                                                                                                             | V        | üë®‚Äçüè´ Guardar XML √© o prop√≥sito! üëç XQuery √© a ferramenta poderosa que permite "andar" pela √°rvore XML (com XPath) e depois selecionar, filtrar e at√© mesmo construir novos resultados XML. √â como ter SQL, mas para o mundo hier√°rquico do XML. üí° **Dica:** XQuery = SQL dos XMLs. (Cap√≠tulo 7, p. 357, 359-361)                                                                                                                                                                                                                                                                                                                                                                                                           |
| 288 | Muitos sistemas NoSQL utilizam o paradigma MapReduce para processamento paralelo de dados, onde a fun√ß√£o `map` transforma os dados de entrada em pares chave-valor e a fun√ß√£o `reduce` agrega os valores associados a cada chave.                                                                                                                                                                                                                                                                                                    | V        | üë®‚Äçüè´ MapReduce √© o "trabalho em equipe" para Big Data! üëç A fun√ß√£o `map` √© como cada trabalhador pegando uma parte da tarefa e preparando (chave-valor). A fun√ß√£o `reduce` √© o supervisor que junta o trabalho de todos os que prepararam a mesma "pe√ßa" (chave) e finaliza. üí° **Dica:** MapReduce = Dividir (map), Agrupar (shuffle/sort impl√≠cito), Conquistar (reduce). (Cap√≠tulo 5, p. 277; Cap√≠tulo 7, p. 355)                                                                                                                                                                                                                                                                                                        |
| 289 | A replica√ß√£o de dados em bancos NoSQL pode ser s√≠ncrona ou ass√≠ncrona, e a replica√ß√£o ass√≠ncrona, embora melhore a lat√™ncia de escrita, introduz uma janela onde leituras em r√©plicas secund√°rias podem retornar dados desatualizados (stale reads).                                                                                                                                                                                                                                                                                 | V        | üë®‚Äçüè´ Replicar √© copiar os dados. üëç Se for ass√≠ncrono (o mestre diz "OK, escrevi!" antes das c√≥pias confirmarem), a escrita √© r√°pida. Mas, nesse meio tempo, se voc√™ ler de uma c√≥pia que ainda n√£o recebeu a atualiza√ß√£o, ver√° o dado antigo. √â o pre√ßo da velocidade. üí° **Dica:** Ass√≠ncrono = R√°pido, mas pode ler o "ontem". (Conceito geral de replica√ß√£o, relevante para Cap. 4 e Cap. 7)                                                                                                                                                                                                                                                                                                                            |
| 290 | Bancos de dados em mem√≥ria (IMDBs) armazenam dados primariamente na RAM para acesso de baixa lat√™ncia, e muitos IMDBs modernos implementam estrat√©gias de persist√™ncia como snapshotting ou append-only logs para garantir a durabilidade dos dados.                                                                                                                                                                                                                                                                                 | V        | üë®‚Äçüè´ Guardar na RAM √© para ser veloz! üöÄ üëç Para n√£o perder tudo se a luz acabar, esses bancos espertos podem tirar "fotos" do estado da mem√≥ria para o disco (snapshotting) ou registrar cada mudan√ßa em um di√°rio (append-only log), garantindo que os dados possam ser recuperados. üí° **Dica:** IMDB + Persist√™ncia = R√°pido e n√£o some (se bem configurado). (Cap√≠tulo 7, p. 346)                                                                                                                                                                                                                                                                                                                                      |
| 291 | O modelo de dados Column-Family, exemplificado pelo Bigtable, organiza dados em uma tabela multidimensional esparsa, e a utiliza√ß√£o de timestamps por c√©lula permite o versionamento e a recupera√ß√£o de estados hist√≥ricos dos dados.                                                                                                                                                                                                                                                                                                | V        | üë®‚Äçüè´ Tabela grande e com buracos (esparsa) √© a ideia. üëç O timestamp em cada c√©lula √© como um carimbo de "quando esse valor espec√≠fico foi escrito". Isso permite guardar v√°rias vers√µes do mesmo "pedaacinho" de dado e perguntar "como estava isso ontem?". üí° **Dica:** Column-Family + Timestamps = M√°quina do tempo celular. (Cap√≠tulo 7, p. 349-351)                                                                                                                                                                                                                                                                                                                                                                  |
| 292 | Document stores como MongoDB permitem indexa√ß√£o em campos dentro dos documentos JSON/BSON, e esses √≠ndices secund√°rios s√£o cruciais para otimizar consultas que filtram por atributos que n√£o s√£o a chave prim√°ria do documento.                                                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Guardar documentos flex√≠veis √© bom. üëç Mas se voc√™ s√≥ pudesse buscar pelo ID do documento, seria limitado. √çndices em campos internos (ex: "cidade" dentro de um documento "usu√°rio") permitem achar rapidamente todos os usu√°rios de uma certa cidade, sem varrer tudo. üí° **Dica:** √çndices em documentos = Achar r√°pido dentro da "gaveta". (Cap√≠tulo 7, p. 356)                                                                                                                                                                                                                                                                                                                                                    |
| 293 | Bancos de dados orientados a grafos como Neo4j utilizam linguagens de consulta espec√≠ficas como Cypher, e essas linguagens s√£o projetadas para expressar travessias de profundidade vari√°vel e busca de padr√µes complexos nos relacionamentos.                                                                                                                                                                                                                                                                                       | V        | üë®‚Äçüè´ Grafos t√™m sua pr√≥pria "l√≠ngua". üëç Cypher (e similares) √© feita para "desenhar" o padr√£o que voc√™ procura no grafo (ex: A √© amigo de B, que trabalha para C). Voc√™ pode dizer "amigos de amigos de amigos" (profundidade vari√°vel) de forma concisa. üí° **Dica:** Linguagem de Grafo = Desenhando o caminho. (Cap√≠tulo 1, p. 45; Cap√≠tulo 3, p. 186; Cap√≠tulo 7, p. 364)                                                                                                                                                                                                                                                                                                                                              |
| 294 | A escolha de uma chave de sharding apropriada em um sistema NoSQL distribu√≠do √© cr√≠tica para o balanceamento de carga e a performance, e uma chave mal escolhida pode levar a "hot spots" onde alguns n√≥s ficam sobrecarregados.                                                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Distribuir os dados √© o objetivo do sharding. üëç Se voc√™ escolhe uma chave ruim (ex: data, e todos os dados de hoje v√£o para o mesmo servidor), aquele servidor vai "fritar" (hot spot) enquanto os outros ficam ociosos. A chave tem que espalhar bem a carga. üí° **Dica:** Boa chave de sharding = Carga bem distribu√≠da. (Cap√≠tulo 7, p. 346 - sharding e hashing)                                                                                                                                                                                                                                                                                                                                                  |
| 295 | Sistemas NoSQL que oferecem " tunable consistency" (consist√™ncia ajust√°vel) permitem que a aplica√ß√£o escolha o n√≠vel de consist√™ncia desejado por opera√ß√£o (ex: leituras podem ser eventualmente consistentes, escritas podem ser mais fortes).                                                                                                                                                                                                                                                                                      | V        | üë®‚Äçüè´ Flexibilidade na consist√™ncia! üëç Em vez de um tamanho √∫nico para todos, alguns NoSQL (como Cassandra) deixam a aplica√ß√£o decidir: "Para esta leitura r√°pida de cat√°logo, tudo bem ver um dado um pouco antigo. Mas para esta transa√ß√£o financeira, preciso de consist√™ncia mais forte!". üí° **Dica:** Consist√™ncia ajust√°vel = Voc√™ no controle do trade-off. (Cap√≠tulo 4, p. 235-237, discute configura√ß√µes de consist√™ncia; o conceito de "tunable" √© uma aplica√ß√£o disso)                                                                                                                                                                                                                                          |
| 296 | Embora os bancos de dados NoSQL variem em seus modelos de dados, uma caracter√≠stica comum √© a otimiza√ß√£o para escalabilidade horizontal, o que geralmente envolve a distribui√ß√£o de dados e processamento em um cluster de servidores commodity.                                                                                                                                                                                                                                                                                     | V        | üë®‚Äçüè´ Modelos diferentes, mas um objetivo comum! üëç Muitos NoSQL foram pensados para crescer "para os lados" (adicionando mais m√°quinas baratas) em vez de "para cima" (comprando um super servidor caro). Distribuir os dados e o trabalho √© chave para isso. üí° **Dica:** NoSQL + Commodity Hardware = Escalabilidade horizontal acess√≠vel. (Cap√≠tulo 7, p. 344)                                                                                                                                                                                                                                                                                                                                                           |
| 297 | A aus√™ncia de jun√ß√µes (joins) no n√≠vel do servidor em muitos bancos de dados NoSQL (especialmente chave-valor e documento) impulsiona a denormaliza√ß√£o ou a realiza√ß√£o de jun√ß√µes na camada da aplica√ß√£o.                                                                                                                                                                                                                                                                                                                            | V        | üë®‚Äçüè´ Se o banco n√£o faz join, algu√©m tem que fazer! üëç Para evitar m√∫ltiplas idas ao banco, os desenvolvedores podem denormalizar (embutir dados relacionados) ou, se os dados est√£o separados, a aplica√ß√£o busca os peda√ßos e os "junta" em mem√≥ria. üí° **Dica:** Sem join no BD = Mais trabalho para a aplica√ß√£o ou modelo denormalizado. (Cap√≠tulo 7, p. 353, 346)                                                                                                                                                                                                                                                                                                                                                       |
| 298 | O conceito de "polyglot persistence" reconhece que diferentes partes de uma aplica√ß√£o podem ter diferentes requisitos de armazenamento de dados, justificando o uso de m√∫ltiplos tipos de bancos de dados (SQL e NoSQL) em conjunto.                                                                                                                                                                                                                                                                                                 | V        | üë®‚Äçüè´ Uma ferramenta para cada trabalho! üëç Em vez de for√ßar um √∫nico banco a fazer tudo, a persist√™ncia poliglota diz: use um relacional para o financeiro (ACID!), um de grafos para as conex√µes sociais, um chave-valor para o cache. Cada um na sua especialidade. üí° **Dica:** Poliglota = A melhor ferramenta para cada necessidade de dado. (Cap√≠tulo 7, p. 344)                                                                                                                                                                                                                                                                                                                                                      |
| 299 | Muitos bancos de dados NoSQL foram projetados para lidar com os desafios de aplica√ß√µes web modernas, como grandes volumes de dados n√£o estruturados ou semiestruturados, alta taxa de requisi√ß√µes e necessidade de baixa lat√™ncia.                                                                                                                                                                                                                                                                                                   | V        | üë®‚Äçüè´ A internet mudou o jogo dos dados! üëç Os bancos relacionais tradicionais nem sempre eram a melhor resposta para o volume, variedade e velocidade dos dados da web. NoSQL surgiu para preencher essa lacuna, oferecendo solu√ß√µes mais adaptadas. üí° **Dica:** NoSQL = Resposta aos desafios da era da web. (Cap√≠tulo 7, p. 343)                                                                                                                                                                                                                                                                                                                                                                                         |
| 300 | Embora "NoSQL" signifique "Not Only SQL", a maioria dos bancos de dados categorizados como NoSQL n√£o oferece nenhuma interface ou compatibilidade com a linguagem SQL para consulta ou manipula√ß√£o de dados.                                                                                                                                                                                                                                                                                                                         | V        | üë®‚Äçüè´ "Not Only SQL" √© uma interpreta√ß√£o, mas na pr√°tica, a grande maioria dos NoSQL usa suas pr√≥prias APIs e linguagens de consulta (Cypher para Neo4j, query language do MongoDB, etc.). üëç Eles se afastam do SQL para explorar outros modelos e otimiza√ß√µes. Algumas ferramentas tentam colocar uma "casca" SQL em cima de NoSQL, mas n√£o √© o nativo. üí° **Dica:** NoSQL geralmente fala sua pr√≥pria l√≠ngua, n√£o SQL. (Cap√≠tulo 7, p. 343-344)                                                                                                                                                                                                                                                                           |
| 301 |  Suspeita-se que um funcion√°rio alterou sal√°rios indevidamente em uma tabela `Funcionarios` de um banco SQL. **Solu√ß√£o Pericial:** O perito deve obter um dump completo da tabela e compar√°-lo com um backup anterior √≠ntegro, identificando as tuplas alteradas pela diferen√ßa nos valores da coluna `Salario` e cruzando com logs de acesso do SGBD para correlacionar com o suspeito.                                                                                                                                | V        | üë®‚Äç‚öñÔ∏è Correto. A compara√ß√£o de estados (dump atual vs. backup) √© uma t√©cnica fundamental. A an√°lise de logs transacionais do SGBD (se dispon√≠veis e √≠ntegros) pode revelar quem (`USER_ID`) executou quais comandos `UPDATE` e quando (`TIMESTAMP`), vinculando a altera√ß√£o ao funcion√°rio. üí° **Conceito:** Logs de transa√ß√£o (Cap. 4, p. 231) e a import√¢ncia de backups (Cap. 4, p. 232). A consulta para encontrar diferen√ßas seria algo como `SELECT * FROM Funcionarios_Atual EXCEPT SELECT * FROM Funcionarios_Backup`.                                                                                                                                                                                               |
| 302 |  Um sistema de vendas registrou transa√ß√µes fraudulentas. Suspeita-se de inser√ß√µes diretas no banco SQL. **Solu√ß√£o Pericial:** O perito deve focar em analisar apenas as views (`CREATE VIEW`) criadas recentemente, pois inser√ß√µes fraudulentas sempre deixam rastros na defini√ß√£o de novas views de acesso.                                                                                                                                                                                                            | F        | üë®‚Äç‚öñÔ∏è Views s√£o tabelas virtuais, n√£o o local prim√°rio de armazenamento. Inser√ß√µes diretas (fraudulentas ou n√£o) ocorrem nas tabelas base (`INSERT INTO TabelaBase`). O perito deve analisar a tabela base de transa√ß√µes, seus logs, triggers de inser√ß√£o e, se houver suspeita de acesso privilegiado, os logs de comandos DML e DDL. Views podem ser usadas para *ocultar* ou *facilitar* acesso, mas n√£o s√£o o foco da inser√ß√£o em si. üí° **Conceito:** Views vs. Tabelas Base (Cap. 3, p. 206), Comandos DML (Cap. 3, p. 179).                                                                                                                                                                                           |
| 303 |  Dados confidenciais de clientes vazaram. Suspeita-se de uma consulta SQL maliciosa. **Solu√ß√£o Pericial:** O perito deve analisar os logs de query do SGBD (se habilitados e preservados) buscando por `SELECT` statements que acessem as tabelas sens√≠veis, especialmente aqueles com cl√°usulas `WHERE` pouco restritivas ou sem `WHERE`, e correlacionar com os IPs e usu√°rios que as executaram.                                                                                                                     | V        | üë®‚Äç‚öñÔ∏è Perfeito. Logs de query s√£o a "caixa-preta" das consultas. Um `SELECT * FROM Clientes_Confidenciais` ou um `SELECT ... WHERE 1=1` s√£o altamente suspeitos. Cruzar com dados de autentica√ß√£o e rede √© crucial para identificar o ponto de origem. üí° **Conceito:** Auditoria de acesso e logs (impl√≠cito na necessidade de seguran√ßa, Cap. 3, p. 206-209). A capacidade de um SGBD de logar queries √© uma funcionalidade de seguran√ßa/auditoria.                                                                                                                                                                                                                                                                        |
| 304 |  Um invasor excluiu registros importantes de uma tabela `Pedidos`. **Solu√ß√£o Pericial:** O perito deve restaurar o √∫ltimo backup completo e, em seguida, aplicar apenas os logs de `INSERT` ocorridos ap√≥s o backup, ignorando os logs de `DELETE` para recuperar os dados.                                                                                                                                                                                                                                             | F        | üë®‚Äç‚öñÔ∏è Restaurar o backup √© o primeiro passo. Depois, √© preciso aplicar o log de transa√ß√µes (redo log) para REFAZER todas as transa√ß√µes COMITADAS ap√≥s o backup, incluindo `INSERT`s, `UPDATE`s e `DELETE`s leg√≠timos. Ignorar `DELETE`s pode trazer de volta dados que foram legitimamente exclu√≠dos ou recriar um estado inconsistente. A an√°lise forense tentaria identificar o `DELETE` malicioso e, se poss√≠vel, reverter *apenas* ele ou recuperar de um ponto anterior a ele. üí° **Conceito:** Recupera√ß√£o com logs (redo) (Cap. 4, p. 231-232).                                                                                                                                                                       |
| 305 |  Suspeita de SQL Injection em uma aplica√ß√£o web que acessa um banco SQL. **Solu√ß√£o Pericial:** O perito deve analisar os logs do servidor web para identificar requisi√ß√µes HTTP com par√¢metros suspeitos (ex: contendo `'; --`, `OR 1=1`) e, em seguida, verificar nos logs do SGBD se queries malformadas ou com l√≥gica inesperada, correspondentes a esses par√¢metros, foram de fato executadas contra o banco.                                                                                                       | V        | üë®‚Äç‚öñÔ∏è Exato. A investiga√ß√£o come√ßa na "porta de entrada" (servidor web) para achar a tentativa de inje√ß√£o. Depois, confirma-se no "cofre" (SGBD) se a inje√ß√£o teve sucesso e qual query foi executada. A combina√ß√£o dos logs √© poderosa. üí° **Conceito:** SQL Injection (Cap. 3, p. 209-211). A an√°lise de logs de diferentes sistemas √© uma pr√°tica forense comum.                                                                                                                                                                                                                                                                                                                                                          |
| 306 |  Chaves importantes de um banco de dados Redis (chave-valor em mem√≥ria) desapareceram. **Solu√ß√£o Pericial:** O perito deve focar em analisar os arquivos de log de comandos do Redis (`redis-cli MONITOR`) para identificar comandos `DEL` ou `FLUSHDB`/`FLUSHALL` executados, e verificar os arquivos de persist√™ncia (RDB/AOF) para tentar recuperar vers√µes anteriores das chaves, se a persist√™ncia estiver configurada.                                                                                            | V        | üë®‚Äç‚öñÔ∏è Correto. `MONITOR` mostra os comandos em tempo real (se estava ativo). `DEL` apaga chaves espec√≠ficas, `FLUSHDB` apaga todas do DB atual, `FLUSHALL` apaga tudo de todos os DBs. Arquivos RDB (snapshots) ou AOF (log de escrita) s√£o a esperan√ßa para recupera√ß√£o, se existirem e n√£o tiverem sido sobrescritos/corrompidos. üí° **Conceito:** Persist√™ncia em IMDBs (Cap. 7, p. 346, Redis p. 368), Logs de SGBD (an√°logo).                                                                                                                                                                                                                                                                                           |
| 307 |  Documentos em um MongoDB foram alterados indevidamente. **Solu√ß√£o Pericial:** O perito deve restaurar o backup mais recente e aplicar o oplog (operation log) do MongoDB, filtrando por opera√ß√µes de `update` na collection suspeita e analisando o conte√∫do do campo `o2` (documento antes da altera√ß√£o) e `o` (documento ap√≥s) para identificar as modifica√ß√µes e o timestamp.                                                                                                                                       | V        | üë®‚Äç‚öñÔ∏è Perfeito. O oplog do MongoDB √© como o log de transa√ß√µes dos relacionais, mas para opera√ß√µes replicadas. Ele guarda as modifica√ß√µes. Analisar os campos `o` (novo objeto) e `o2` (objeto antigo, em updates) nas entradas do oplog permite ver o "antes e depois". üí° **Conceito:** Logs de replica√ß√£o/opera√ß√£o (an√°logo ao Cap. 4, p. 231). Os campos `o` e `o2` s√£o espec√≠ficos da estrutura do oplog do MongoDB.                                                                                                                                                                                                                                                                                                     |
| 308 |  Suspeita de acesso n√£o autorizado a um banco de documentos CouchDB. **Solu√ß√£o Pericial:** O perito deve analisar os logs de acesso do CouchDB (se configurados) e, crucialmente, inspecionar o campo `_rev` (revis√£o) dos documentos, pois m√∫ltiplas revis√µes com timestamps pr√≥ximos ou altera√ß√µes inesperadas podem indicar manipula√ß√£o ou acesso por um agente n√£o autorizado.                                                                                                                                      | V        | üë®‚Äç‚öñÔ∏è Boa abordagem! O campo `_rev` √© central no CouchDB para controle de concorr√™ncia multivers√£o (MVCC). Uma sequ√™ncia estranha de revis√µes, ou revis√µes criadas em hor√°rios suspeitos, pode ser um forte ind√≠cio. Logs de acesso HTTP ao CouchDB tamb√©m seriam vitais. üí° **Conceito:** MVCC (impl√≠cito em Document Stores como CouchDB, Cap. 7, p. 354-355).                                                                                                                                                                                                                                                                                                                                                             |
| 309 |  Um atacante explorou uma vulnerabilidade de NoSQL Injection em uma API que interage com um banco de documentos, extraindo dados sens√≠veis. **Solu√ß√£o Pericial:** O perito deve analisar os logs da API e do banco buscando por queries que contenham operadores de consulta do banco (ex: `$gt`, `$ne` no MongoDB) injetados em campos de entrada do usu√°rio, e que resultaram na devolu√ß√£o de um volume de dados maior ou diferente do esperado.                                                                      | V        | üë®‚Äç‚öñÔ∏è Exato. NoSQL Injection acontece quando a entrada do usu√°rio n√£o √© sanitizada e permite que ele injete operadores da linguagem de consulta do NoSQL. Se um campo esperava um ID e recebe `{"$ne": null}`, pode retornar todos os documentos. A an√°lise combina logs da API (o que chegou) e do BD (o que foi executado). üí° **Conceito:** Analogia com SQL Injection (Cap. 3, p. 209-211), mas com operadores NoSQL.                                                                                                                                                                                                                                                                                                    |
| 310 |  Em um banco chave-valor distribu√≠do com sharding, um n√≥ (shard) espec√≠fico est√° apresentando lentid√£o extrema, afetando a performance da aplica√ß√£o. **Solu√ß√£o Pericial:** O perito deve, primeiramente, desabilitar o sharding e consolidar todos os dados em um √∫nico n√≥ para facilitar a an√°lise e identificar a causa raiz da lentid√£o.                                                                                                                                                                             | F        | üë®‚Äç‚öñÔ∏è Desabilitar o sharding e consolidar tudo num n√≥ s√≥ em um sistema em produ√ß√£o √© geralmente invi√°vel e pode piorar a situa√ß√£o (sobrecarregando o n√≥ √∫nico). A abordagem correta seria monitorar o n√≥ problem√°tico (m√©tricas de CPU, mem√≥ria, I/O, rede, tamanho das filas de requisi√ß√£o), analisar as queries/opera√ß√µes que est√£o sendo direcionadas a ele (hot keys?), e verificar se h√° desbalanceamento de dados ou carga. üí° **Conceito:** Sharding e balanceamento (Cap. 7, p. 346-347). Diagn√≥stico em sistemas distribu√≠dos √© complexo.                                                                                                                                                                           |
| 311 |  Dados em um HBase (Column-Family) parecem ter sido corrompidos ou sobrescritos com informa√ß√µes incorretas. **Solu√ß√£o Pericial:** O perito deve utilizar a capacidade de versionamento do HBase (que armazena m√∫ltiplas vers√µes de uma c√©lula por timestamp) para examinar o hist√≥rico de altera√ß√µes da(s) c√©lula(s) afetada(s) e identificar quando a altera√ß√£o indevida ocorreu e qual era o valor anterior.                                                                                                          | V        | üë®‚Äç‚öñÔ∏è Exatamente! O versionamento por timestamp √© uma caracter√≠stica poderosa do HBase (e do Bigtable). O perito pode "voltar no tempo" para uma c√©lula espec√≠fica e ver seus valores anteriores, ajudando a pinpointar a corrup√ß√£o. üí° **Conceito:** Versionamento em Column-Family Stores (Cap. 7, p. 350-351).                                                                                                                                                                                                                                                                                                                                                                                                            |
| 312 |  Em um banco de grafos Neo4j, relacionamentos inesperados foram criados entre n√≥s, indicando poss√≠vel atividade maliciosa. **Solu√ß√£o Pericial:** O perito deve executar consultas Cypher para identificar os novos relacionamentos (ex: por data de cria√ß√£o, se dispon√≠vel como propriedade, ou por tipo), analisar as propriedades desses relacionamentos e dos n√≥s conectados, e cruzar com logs de transa√ß√£o do Neo4j para identificar a origem.                                                                     | V        | üë®‚Äç‚öñÔ∏è Perfeito. Cypher √© a ferramenta para "interrogar" o grafo. Consultas como `MATCH (a)-[r:NOVO_TIPO_SUSPEITO]->(b) WHERE r.timestamp_criacao > 'data_suspeita' RETURN a, r, b` seriam um ponto de partida. Logs de transa√ß√£o (se habilitados e detalhados) podem mostrar qual usu√°rio/processo criou esses relacionamentos. üí° **Conceito:** Consultando grafos com Cypher (Cap. 1, p. 45; Cap. 3, p. 186), Propriedades em arestas (Cap. 1, p. 42).                                                                                                                                                                                                                                                                     |
| 313 |  Um n√≥ em um cluster Cassandra (Column-Family, arquitetura distribu√≠da sem mestre) est√° offline, e h√° suspeita de perda de dados. **Solu√ß√£o Pericial:** O perito deve verificar o n√≠vel de replica√ß√£o da keyspace afetada e o n√≠vel de consist√™ncia usado nas escritas. Se o fator de replica√ß√£o era >1 e as escritas usavam `QUORUM`, √© prov√°vel que os dados existam em outras r√©plicas e possam ser recuperados via "repair" ou leituras com consist√™ncia `QUORUM`.                                                  | V        | üë®‚Äç‚öñÔ∏è Exato. A beleza da arquitetura do Cassandra est√° na replica√ß√£o e consist√™ncia ajust√°vel. Se a escrita precisou da confirma√ß√£o de um quorum de n√≥s (ex: 2 de 3 r√©plicas), e um n√≥ caiu, os outros n√≥s do quorum ainda t√™m os dados. O "repair" sincroniza as r√©plicas. üí° **Conceito:** Replica√ß√£o e Consist√™ncia Ajust√°vel (Quorum) (Cap. 4, p. 235-237; Cassandra implementa esses conceitos).                                                                                                                                                                                                                                                                                                                        |
| 314 |  Em um banco de grafos, um perito precisa identificar todos os n√≥s que est√£o a exatamente 3 saltos (hops) de um n√≥ de interesse, seguindo apenas relacionamentos do tipo `CONHECE`. **Solu√ß√£o Pericial:** O perito deve realizar uma consulta SQL padr√£o com tr√™s `JOIN`s na tabela de relacionamentos, filtrando pelo tipo `CONHECE`.                                                                                                                                                                                  | F        | üë®‚Äç‚öñÔ∏è Bancos de grafos s√£o feitos para esse tipo de travessia de forma nativa e eficiente, usando linguagens como Cypher. Uma consulta Cypher seria `MATCH (inicio)-[:CONHECE*3]->(fim) WHERE id(inicio) = 'id_interesse' RETURN fim`. Tentar simular isso com `JOIN`s em um modelo relacional para grafos pode ser muito ineficiente para profundidades maiores. üí° **Conceito:** Travessia de profundidade vari√°vel em grafos (Cap. 3, p. 184-186 - exemplo com Cypher `HAS*`).                                                                                                                                                                                                                                            |
| 315 |  Suspeita-se que um algoritmo de recomenda√ß√£o em um banco de grafos foi manipulado para favorecer certos produtos. **Solu√ß√£o Pericial:** O perito deve analisar os caminhos (paths) e os pesos das arestas que levam aos produtos recomendados versus os n√£o recomendados para um conjunto de usu√°rios de teste, buscando por anomalias ou padr√µes de recomenda√ß√£o que n√£o se alinham com o comportamento esperado do algoritmo ou dos dados hist√≥ricos de intera√ß√£o.                                                   | V        | üë®‚Äç‚öñÔ∏è √ìtima abordagem. A per√≠cia aqui √© entender como o algoritmo *deveria* funcionar e comparar com como ele *est√°* funcionando. Analisar os "porqu√™s" da recomenda√ß√£o (os caminhos no grafo) e os "quantos" (pesos das arestas, se houver) pode revelar manipula√ß√£o ou bias. üí° **Conceito:** An√°lise de caminhos em grafos (Cap. 1, p. 44; Cap. 7, p. 366). A l√≥gica do algoritmo √© o foco.                                                                                                                                                                                                                                                                                                                               |
| 316 |  √â preciso determinar o hor√°rio exato de uma modifica√ß√£o cr√≠tica em um banco de dados. **Solu√ß√£o Pericial:** O perito deve confiar unicamente no timestamp do sistema de arquivos do arquivo de dados do banco, pois este √© o indicador mais preciso e imut√°vel da altera√ß√£o.                                                                                                                                                                                                                                           | F        | üë®‚Äç‚öñÔ∏è O timestamp do sistema de arquivos pode ser facilmente alterado e reflete apenas a √∫ltima modifica√ß√£o no arquivo *como um todo*, n√£o em registros espec√≠ficos. O perito deve buscar timestamps *dentro* dos logs de transa√ß√£o do SGBD, ou em colunas de `data_modificacao` mantidas pela aplica√ß√£o/triggers, que s√£o muito mais granulares e confi√°veis para a altera√ß√£o espec√≠fica. üí° **Conceito:** Import√¢ncia dos logs internos do SGBD vs. metadados do SO (Cap. 4, p. 231).                                                                                                                                                                                                                                      |
| 317 |  Um perito precisa analisar um grande volume de logs de um SGBD para encontrar atividades suspeitas. **Solu√ß√£o Pericial:** O perito deve carregar os logs em uma ferramenta de an√°lise de logs (ou mesmo em outro banco de dados) e utilizar t√©cnicas de filtragem, agrega√ß√£o e busca por padr√µes (ex: regex, anomalias estat√≠sticas) para identificar eventos de interesse, em vez de uma leitura manual completa.                                                                                                     | V        | üë®‚Äç‚öñÔ∏è Leitura manual de logs gigantes √© invi√°vel e propensa a erros. Ferramentas e scripts para parsear, filtrar (por IP, usu√°rio, tipo de comando, hor√°rio) e encontrar anomalias (ex: muitos logins falhos, seguido de um sucesso de um IP estranho) s√£o essenciais. üí° **Conceito:** Processamento de grandes volumes de dados (an√°logo ao Big Data, Cap. 1, p. 39; MapReduce para an√°lise de logs, Cap. 5, p. 277).                                                                                                                                                                                                                                                                                                      |
| 318 |  Um perito precisa garantir a integridade de uma imagem forense de um disco contendo arquivos de banco de dados. **Solu√ß√£o Pericial:** O perito deve calcular hashes criptogr√°ficos (ex: SHA-256) da imagem original e de quaisquer c√≥pias de trabalho, comparando-os para assegurar que n√£o houve altera√ß√µes acidentais ou intencionais durante o processo de c√≥pia e an√°lise.                                                                                                                                         | V        | üë®‚Äç‚öñÔ∏è Fundamental! Hashing cria uma "impress√£o digital" √∫nica do dado. Se o hash da c√≥pia n√£o bate com o do original, a c√≥pia n√£o √© id√™ntica e sua integridade est√° comprometida. Isso √© um pilar da cadeia de cust√≥dia digital. üí° **Conceito:** Integridade de dados (Cap. 2, p. 109; Cap. 4, p. 217). Hashing √© uma t√©cnica criptogr√°fica b√°sica para isso.                                                                                                                                                                                                                                                                                                                                                               |
| 319 |  √â necess√°rio identificar se dados foram exfiltrados de um banco de dados. **Solu√ß√£o Pericial:** O perito deve focar exclusivamente na an√°lise de logs de firewall, pois qualquer exfiltra√ß√£o de dados deixar√° rastros claros de grandes transfer√™ncias de sa√≠da nesse componente.                                                                                                                                                                                                                                      | F        | üë®‚Äç‚öñÔ∏è Logs de firewall s√£o importantes, mas n√£o exclusivos. Dados podem ser exfiltrados de muitas formas: logs de SGBD (muitas `SELECT`s), logs de servidor web (grandes respostas HTTP), logs de proxy, logs de sistema (comandos de c√≥pia), uso de USB, e-mail, etc. Uma investiga√ß√£o de exfiltra√ß√£o √© multifacetada. üí° **Conceito:** Amea√ßas e vetores de ataque s√£o diversos. A per√≠cia requer uma vis√£o hol√≠stica.                                                                                                                                                                                                                                                                                                     |
| 320 |  Um perito encontra arquivos de log de um SGBD que parecem ter sido truncados ou modificados. **Solu√ß√£o Pericial:** O perito deve analisar os timestamps de modifica√ß√£o dos arquivos de log no sistema de arquivos, verificar a sequ√™ncia e consist√™ncia interna dos registros de log restantes (ex: n√∫meros de sequ√™ncia de log - LSNs), e procurar por evid√™ncias de comandos de limpeza de log ou acesso por contas privilegiadas nos logs do sistema operacional.                                                   | V        | üë®‚Äç‚öñÔ∏è Abordagem completa! Se o log do SGBD foi adulterado, o perito vira detetive üïµÔ∏è‚Äç‚ôÇÔ∏è: timestamps do SO, consist√™ncia interna dos LSNs (se um pulou, algo sumiu), e logs do pr√≥prio SO para ver quem mexeu nos arquivos ou rodou comandos suspeitos. üí° **Conceito:** Anti-forense (tentativa de apagar rastros) e a necessidade de cruzar m√∫ltiplas fontes de evid√™ncia. (Logs, Cap. 4, p. 231).                                                                                                                                                                                                                                                                                                                         |
| 321 |  Uma empresa est√° com consultas lentas em seu banco de dados relacional principal. **Solu√ß√£o Sugerida:** A empresa deve imediatamente migrar todos os seus dados para um banco de dados NoSQL chave-valor, pois estes s√£o inerentemente mais r√°pidos para qualquer tipo de consulta.                                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ Migrar tudo para chave-valor sem an√°lise √© como usar um martelo para todos os parafusos. Chave-valor √© r√°pido para buscas por chave, mas p√©ssimo para joins e consultas complexas que podem ser o gargalo no SQL. A solu√ß√£o √© analisar as queries lentas, otimizar √≠ndices, refatorar SQL, e *talvez* usar NoSQL para *partes espec√≠ficas* da aplica√ß√£o (persist√™ncia poliglota). üí° **Conceito:** Adequa√ß√£o do modelo de dados ao problema (Cap. 7, p. 344). Otimiza√ß√£o de consultas (Cap. 5, p. 267).                                                                                                                                                                                                                |
| 322 |  Uma startup est√° desenvolvendo uma rede social e precisa de um banco para armazenar perfis de usu√°rio, posts e conex√µes (amizades, seguidores). **Solu√ß√£o Sugerida:** Um banco de dados orientado a grafos √© uma escolha adequada, pois modela nativamente os relacionamentos entre usu√°rios e posts, facilitando consultas como "amigos de amigos" ou "posts de pessoas que sigo".                                                                                                                                    | V        | üë®‚Äçüè´ Perfeito para redes sociais! Grafos s√£o feitos para representar e consultar conex√µes. Perguntas sobre relacionamentos, recomenda√ß√µes baseadas em conex√µes, etc., s√£o muito mais naturais e eficientes em um banco de grafos do que tentar simular isso em um relacional com muitas tabelas de jun√ß√£o. üí° **Conceito:** Modelo de Grafos para dados interconectados (Cap. 1, p. 42-44; Cap. 7, p. 364).                                                                                                                                                                                                                                                                                                                 |
| 323 |  Uma empresa de e-commerce precisa armazenar o cat√°logo de produtos, onde cada produto tem atributos variados e alguns s√£o espec√≠ficos de sua categoria. **Solu√ß√£o Sugerida:** Um banco de dados relacional com um esquema r√≠gido e uma √∫nica tabela `Produtos` com todas as colunas poss√≠veis para todos os tipos de produto √© a melhor abordagem para garantir a integridade.                                                                                                                                         | F        | üë®‚Äçüè´ Isso levaria a uma tabela gigantesca com muitos `NULL`s (esparsa) e dif√≠cil de manter. Para cat√°logos com atributos variados, um banco de documentos NoSQL (onde cada produto/documento pode ter seus pr√≥prios campos) ou um modelo relacional com tabelas separadas por categoria (usando heran√ßa/generaliza√ß√£o) ou um padr√£o EAV (Entidade-Atributo-Valor, com ressalvas) seriam mais flex√≠veis e eficientes. üí° **Conceito:** Flexibilidade de esquema para dados heterog√™neos (Cap. 7, p. 353 - Document Stores). Generaliza√ß√£o no ER (Cap. 2, p. 74).                                                                                                                                                             |
| 324 |  Uma aplica√ß√£o precisa de um cache de alta performance para dados frequentemente acessados, a fim de reduzir a carga no banco de dados principal. **Solu√ß√£o Sugerida:** Um banco de dados chave-valor em mem√≥ria como Redis ou Memcached √© uma excelente escolha, pois oferece acesso de baix√≠ssima lat√™ncia para leituras e escritas simples baseadas em chave.                                                                                                                                                        | V        | üë®‚Äçüè´ Tiro certeiro! üéØ Bancos chave-valor em mem√≥ria s√£o os reis do cache. Acesso por chave √© quase instant√¢neo. Isso tira uma carga enorme do banco principal, que pode se dedicar a opera√ß√µes mais complexas. üí° **Conceito:** Bancos Chave-Valor In-Memory para caching (Cap. 7, p. 346, Redis p. 368).                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 325 |  Uma empresa global precisa de um banco de dados para seu sistema de reservas que seja altamente dispon√≠vel e tolerante a parti√ß√µes de rede entre continentes, mesmo que isso signifique uma pequena janela de poss√≠vel inconsist√™ncia eventual nos dados de disponibilidade. **Solu√ß√£o Sugerida:** Um sistema NoSQL que priorize AP (Disponibilidade e Toler√¢ncia a Parti√ß√µes) sobre C (Consist√™ncia forte), como Cassandra, seria adequado, utilizando estrat√©gias de consist√™ncia eventual.                          | V        | üë®‚Äç‚öñÔ∏è Exato. Para um sistema global onde estar "no ar" e funcionando mesmo com problemas de rede √© mais cr√≠tico do que ter o √∫ltimo assento 100% sincronizado instantaneamente, um NoSQL AP com consist√™ncia eventual √© um bom trade-off. Cassandra foi projetado para isso. üí° **Conceito:** Teorema CAP e escolha de trade-offs (Cap. 4, p. 233-234). Consist√™ncia Eventual (Cap. 4, p. 233).                                                                                                                                                                                                                                                                                                                              |
| 326 |  Um perito precisa determinar se um arquivo de banco de dados SQLite em um dispositivo m√≥vel foi modificado externamente (ex: por outra aplica√ß√£o ou manualmente). **Solu√ß√£o Pericial:** O perito deve analisar os arquivos de journal do SQLite (`-journal`, `-wal`) associados ao banco principal, pois eles registram as transa√ß√µes n√£o comitadas ou as p√°ginas alteradas, e a aus√™ncia ou inconsist√™ncia desses arquivos em rela√ß√£o ao banco principal pode indicar manipula√ß√£o ou um desligamento incorreto.       | V        | üë®‚Äç‚öñÔ∏è Correto. Arquivos de journal (roll-back journal ou write-ahead log - WAL) s√£o cruciais para a atomicidade e recupera√ß√£o do SQLite. Se o banco principal foi modificado e o journal n√£o reflete isso corretamente, ou se o journal indica transa√ß√µes incompletas que "sumiram", √© um forte ind√≠cio de altera√ß√£o externa ou corrup√ß√£o. üí° **Conceito:** Logs de transa√ß√£o e recupera√ß√£o (an√°logo ao Cap. 4, p. 218, 231). SQLite tem seus pr√≥prios mecanismos internos.                                                                                                                                                                                                                                                  |
| 327 |  Suspeita de que um funcion√°rio usou um script para apagar seletivamente registros de uma tabela SQL ao longo de v√°rias semanas. **Solu√ß√£o Pericial:** O perito deve configurar um trigger `AFTER DELETE` na tabela em quest√£o em uma c√≥pia forense do banco, e ent√£o reprocessar os backups incrementais ou logs de transa√ß√£o do per√≠odo suspeito. O trigger gravaria em uma tabela de auditoria cada `DELETE` que seria executado, permitindo identificar os registros e os momentos das exclus√µes.                   | V        | üë®‚Äç‚öñÔ∏è Abordagem engenhosa! Como os `DELETE`s j√° ocorreram, o perito simula a passagem do tempo numa c√≥pia. Ao aplicar os logs/backups, o trigger "pega" os `DELETE`s que o script original teria feito, registrando-os. Isso ajuda a reconstruir o que foi apagado e quando. üí° **Conceito:** Triggers (Cap. 3, p. 204), Logs de Transa√ß√£o (Cap. 4, p. 231). Simula√ß√£o e reconstru√ß√£o de eventos.                                                                                                                                                                                                                                                                                                                            |
| 328 |  Um perito examina um servidor web comprometido e encontra um script PHP que parece interagir com um MySQL, mas as credenciais do banco n√£o est√£o no script. **Solu√ß√£o Pericial:** O perito deve procurar por arquivos de configura√ß√£o da aplica√ß√£o PHP (ex: `config.php`, `.env`), vari√°veis de ambiente do servidor web ou do sistema, ou at√© mesmo em outros scripts inclu√≠dos (`include`/`require`) que possam conter as credenciais de conex√£o com o banco de dados.                                               | V        | üë®‚Äç‚öñÔ∏è As credenciais raramente ficam "hardcoded" no script principal por boas pr√°ticas de seguran√ßa. Elas s√£o geralmente externalizadas. O perito precisa "ca√ßar" üïµÔ∏è‚Äç‚ôÄÔ∏è por esses arquivos de configura√ß√£o ou vari√°veis de ambiente para entender como o script malicioso poderia estar acessando o banco. üí° **Conceito:** Configura√ß√£o de aplica√ß√µes e seguran√ßa de credenciais. Intera√ß√£o aplica√ß√£o-banco (Cap. 3, p. 192-196 JDBC/Embedded).                                                                                                                                                                                                                                                                            |
| 329 |  Um perito precisa analisar o conte√∫do de "espa√ßo n√£o alocado" em um disco r√≠gido que continha um banco de dados, buscando por fragmentos de registros deletados. **Solu√ß√£o Pericial:** O perito deve utilizar ferramentas de "file carving" e busca por strings/padr√µes conhecidos da estrutura da tabela (ex: delimitadores, nomes de colunas comuns) no espa√ßo n√£o alocado, pois mesmo ap√≥s a exclus√£o, os dados podem permanecer fisicamente no disco at√© serem sobrescritos.                                       | V        | üë®‚Äç‚öñÔ∏è Quando voc√™ "deleta" um arquivo, geralmente s√≥ o ponteiro para ele √© removido; os dados continuam l√° at√© que novos dados os substituam. "Carving" √© como escavar ‚õèÔ∏è o disco procurando por peda√ßos reconhec√≠veis de arquivos ou dados. üí° **Conceito:** Persist√™ncia de dados em disco e recupera√ß√£o de dados deletados (fora do escopo direto do SGBD, mas relevante para per√≠cia em arquivos de BD).                                                                                                                                                                                                                                                                                                                 |
| 330 |  Suspeita de que um banco de dados PostgreSQL foi acessado remotamente por um IP n√£o autorizado. **Solu√ß√£o Pericial:** O perito deve analisar o arquivo `pg_hba.conf` (Host-Based Authentication) para verificar as regras de permiss√£o de conex√£o por IP e m√©todo de autentica√ß√£o, e cruzar essa informa√ß√£o com os logs de conex√£o do PostgreSQL, que registram tentativas de login (sucesso e falha) e os IPs de origem.                                                                                              | V        | üë®‚Äç‚öñÔ∏è `pg_hba.conf` √© o "porteiro" üíÇ do PostgreSQL, dizendo quem pode tentar entrar e como. Os logs de conex√£o s√£o o livro de visitas, registrando quem realmente tentou (e se conseguiu). A combina√ß√£o dos dois mostra se as regras foram burladas ou se um IP permitido foi comprometido. üí° **Conceito:** Configura√ß√£o de seguran√ßa e autentica√ß√£o em SGBDs (an√°logo ao GRANT/REVOKE e seguran√ßa de acesso, Cap. 3, p. 208-209).                                                                                                                                                                                                                                                                                         |
| 331 |  Um perito precisa determinar se um usu√°rio espec√≠fico visualizou dados sens√≠veis em uma aplica√ß√£o web que usa um banco SQL. **Solu√ß√£o Pericial:** O perito deve focar apenas nos logs do SGBD, pois qualquer visualiza√ß√£o de dados pela aplica√ß√£o web resultar√° em um comando `SELECT` direto do usu√°rio logado no banco.                                                                                                                                                                                              | F        | üë®‚Äç‚öñÔ∏è A aplica√ß√£o web geralmente se conecta ao banco com UM usu√°rio de aplica√ß√£o gen√©rico, n√£o com o usu√°rio final. O perito precisa correlacionar os LOGS DA APLICA√á√ÉO WEB (que registram qual usu√°rio web fez qual a√ß√£o na interface) com os LOGS DO SGBD (que mostram as queries executadas pelo usu√°rio de aplica√ß√£o em nome do usu√°rio web). S√≥ olhar o log do BD n√£o diz qual *usu√°rio final* viu o qu√™. üí° **Conceito:** Arquitetura de N-camadas e correla√ß√£o de logs. (Cap. 5, p. 284-286 - Uso de BDs em lojas online)                                                                                                                                                                                             |
| 332 |  Um perito analisa um banco de dados NoSQL orientado a documentos e suspeita que um documento foi revertido para uma vers√£o anterior maliciosamente. **Solu√ß√£o Pericial:** O perito deve verificar se o banco de dados implementa versionamento de documentos (ex: atrav√©s de um campo de revis√£o como `_rev` e armazenamento de vers√µes antigas) e, se sim, examinar o hist√≥rico de revis√µes do documento em quest√£o, comparando os timestamps e o conte√∫do das vers√µes para identificar a revers√£o.                   | V        | üë®‚Äç‚öñÔ∏è Se o banco guarda o hist√≥rico (como CouchDB com `_rev` ou sistemas com MVCC expl√≠cito), o perito pode "assistir ao filme" das mudan√ßas do documento, identificando a revers√£o e quando ela ocorreu. üí° **Conceito:** Versionamento e MVCC em NoSQL (Cap. 7, p. 354-355).                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 333 |  Em um caso de ransomware, um banco de dados SQL foi criptografado. O perito possui backups, mas precisa verificar se algum dado foi exfiltrado *antes* da criptografia. **Solu√ß√£o Pericial:** O perito deve restaurar o backup mais recente anterior ao incidente em um ambiente isolado e analisar os logs de transa√ß√£o/query desse per√≠odo buscando por atividades an√¥malas de `SELECT` em grande volume ou em tabelas sens√≠veis, al√©m de verificar logs de rede e de sistema por transfer√™ncias de dados suspeitas. | V        | üë®‚Äç‚öñÔ∏è Correto. Ransomware muitas vezes rouba dados antes de criptografar. O perito precisa "voltar no tempo" com o backup e os logs para procurar por sinais de " reconhecimento" e "coleta" de dados pelo atacante *antes* do "boom" üí•. üí° **Conceito:** An√°lise de logs para detec√ß√£o de comportamento an√¥malo (Cap. 4, p. 231). Combina√ß√£o de fontes de evid√™ncia.                                                                                                                                                                                                                                                                                                                                                       |
| 334 |  Um perito precisa analisar um cluster Elasticsearch (motor de busca e banco NoSQL) para investigar a altera√ß√£o indevida de um √≠ndice. **Solu√ß√£o Pericial:** O perito deve focar exclusivamente na an√°lise dos arquivos de configura√ß√£o do Elasticsearch, pois qualquer altera√ß√£o nos dados de um √≠ndice √© refletida diretamente e apenas nesses arquivos.                                                                                                                                                              | F        | üë®‚Äç‚öñÔ∏è Arquivos de configura√ß√£o s√£o importantes para entender como o cluster est√° montado, mas a altera√ß√£o de *dados* dentro de um √≠ndice √© registrada nos LOGS DE TRANSA√á√ÉO (translog) do Elasticsearch e, eventualmente, consolidada nos segmentos de √≠ndice no disco. O perito precisaria analisar esses logs, os snapshots (se houver) e possivelmente usar APIs de auditoria do Elasticsearch. üí° **Conceito:** Logs e persist√™ncia em sistemas distribu√≠dos (an√°logo a outros NoSQL e SGBDs). Elasticsearch tem sua pr√≥pria arquitetura interna.                                                                                                                                                                        |
| 335 |  Um perito suspeita que metadados de arquivos de um banco de dados (ex: datas de cria√ß√£o/modifica√ß√£o no sistema de arquivos) foram adulterados para ocultar uma intrus√£o. **Solu√ß√£o Pericial:** O perito deve comparar os timestamps do sistema de arquivos com timestamps internos do SGBD (ex: de logs de transa√ß√£o, ou de colunas `data_criacao`/`data_modificacao` nas tabelas), e tamb√©m procurar por ferramentas de anti-forense no sistema que poderiam ter sido usadas para alterar os metadados do SO.         | V        | üë®‚Äç‚öñÔ∏è √ìtima checagem cruzada! Timestamps do SO s√£o f√°ceis de mudar. Timestamps internos do BD (se √≠ntegros) s√£o mais confi√°veis. A presen√ßa de ferramentas que mexem em timestamps (timestomp) √© um forte ind√≠cio de adultera√ß√£o. üí° **Conceito:** Anti-forense e a import√¢ncia de n√£o confiar em uma √∫nica fonte de tempo. (Relevante para a integridade da evid√™ncia, Cap. 4 sobre logs).                                                                                                                                                                                                                                                                                                                                  |
