| Id  | afirma√ß√£o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | resposta                                                                                                                                                                                                                                                                                                      | explica√ß√£o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | Em um pipeline GitLab, para otimizar o tempo de execu√ß√£o, um job no est√°gio `deploy` pode iniciar sua execu√ß√£o assim que qualquer job do est√°gio anterior, `test`, for conclu√≠do com sucesso, mesmo que outros jobs do mesmo est√°gio `test` ainda estejam em execu√ß√£o.                                                                                                                                                                                                                          | F                                                                                                                                                                                                                                                                                                             | **Formal:** A execu√ß√£o padr√£o de um pipeline no GitLab √© estritamente sequencial entre os est√°gios. O est√°gio `deploy` s√≥ pode come√ßar quando **TODOS** os jobs do est√°gio `test` forem conclu√≠dos com sucesso. A funcionalidade que permite quebrar essa rigidez √© a diretiva `needs`, que cria um Grafo Ac√≠clico Dirigido (DAG), mas a afirma√ß√£o descreve o comportamento padr√£o de forma incorreta.<br/><br/>**Feynman/Dica üéØ:** Imagine est√°gios como barreiras. Todos os corredores (`jobs`) de uma fase (`test`) precisam cruzar a linha de chegada antes que a barreira para a pr√≥xima fase (`deploy`) seja aberta para todos. A pegadinha est√° em "qualquer job". A palavra-chave √© **TODOS**.                                                                                                                                                                                                                                                         |
| 2   | A utiliza√ß√£o da diretiva `cache` no arquivo `.gitlab-ci.yml` com a `key` baseada no `CI_COMMIT_REF_SLUG` garante o compartilhamento de depend√™ncias entre jobs de diferentes est√°gios dentro da mesma execu√ß√£o do pipeline, enquanto os `artifacts` s√£o utilizados para persistir dados entre diferentes execu√ß√µes de pipeline.                                                                                                                                                                 | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o inverte os conceitos. `artifacts` s√£o usados para passar dados **entre jobs de diferentes est√°gios DENTRO da mesma execu√ß√£o de pipeline** (ex: um bin√°rio compilado). `cache` √© usado para acelerar execu√ß√µes futuras do pipeline, persistindo dados **entre diferentes execu√ß√µes de pipeline** (ex: depend√™ncias baixadas).<br/><br/>**Feynman/Dica üéØ:** A banca trocou as malas no aeroporto! ‚úàÔ∏è **Artefato** √© a sua mala de m√£o, voc√™ leva de um port√£o (`job`) para o outro na *mesma viagem* (`pipeline`). **Cache** √© o arm√°rio que voc√™ aluga no aeroporto para guardar suas coisas para a *pr√≥xima viagem*. N√£o confunda os dois.                                                                                                                                                                                                                                                                                             |
| 3   | A funcionalidade Review Apps do GitLab permite a cria√ß√£o de ambientes din√¢micos e ef√™meros para cada Merge Request (MR). Para sua implementa√ß√£o, √© mandat√≥rio o uso de um orquestrador como Kubernetes, pois a gest√£o de m√∫ltiplos ambientes tempor√°rios √© invi√°vel utilizando apenas scripts `shell` em um servidor tradicional.                                                                                                                                                               | F                                                                                                                                                                                                                                                                                                             | **Formal:** Embora o Kubernetes seja a plataforma ideal e mais comum para Review Apps devido √† sua capacidade de gerenciar namespaces e recursos dinamicamente, n√£o √© mandat√≥rio. √â perfeitamente poss√≠vel, embora mais complexo, implementar Review Apps em um servidor tradicional usando scripts `shell` que, por exemplo, criam um novo subdom√≠nio no Nginx e um novo diret√≥rio no servidor web, nomeados com base no ID do MR. A afirma√ß√£o erra ao usar a palavra "mandat√≥rio".<br/><br/>**Feynman/Dica üéØ:** Cuidado com absolutismos como "mandat√≥rio", "sempre", "nunca". A banca adora us√°-los para invalidar uma afirma√ß√£o. Pense: "Existe *alguma* forma, mesmo que gambiarra, de fazer isso sem Kubernetes?". Sim, existe. Ent√£o, n√£o √© mandat√≥rio. √â uma quest√£o de viabilidade, n√£o de possibilidade.                                                                                                                                             |
| 4   | No contexto de um pipeline de Infraestrutura como C√≥digo (IaC) utilizando Terraform, a separa√ß√£o dos comandos `terraform plan` e `terraform apply` em jobs distintos, onde o job de `apply` √© configurado com `when: manual` e depende de um artefato gerado pelo `plan`, √© uma pr√°tica de seguran√ßa recomendada para evitar altera√ß√µes n√£o revisadas em ambientes de produ√ß√£o.                                                                                                                 | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© a descri√ß√£o exata da melhor pr√°tica para pipelines de IaC. O `plan` gera um plano de execu√ß√£o que √© revisado no Merge Request. O `apply` manual for√ßa um port√£o de aprova√ß√£o humano deliberado antes de modificar a infraestrutura real. Isso alinha a automa√ß√£o com a governan√ßa.<br/><br/>**Feynman/Dica üéØ:** Pense como um engenheiro civil. Primeiro, voc√™ cria a planta (`plan`) e todos os engenheiros revisam. S√≥ depois que todos aprovam, um respons√°vel d√° a ordem para come√ßar a constru√ß√£o (`apply`). Voc√™ nunca come√ßaria a construir sem revisar a planta. A afirma√ß√£o descreve esse fluxo seguro.                                                                                                                                                                                                                                                                                                                            |
| 5   | As CI/CD Variables do tipo `File` no GitLab s√£o uma forma segura de armazenar conte√∫do de arquivos, como chaves SSH ou certificados, e, quando utilizadas em um job, o GitLab injeta o conte√∫do do arquivo diretamente como uma string na vari√°vel de ambiente correspondente.                                                                                                                                                                                                                  | F                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma pegadinha sutil e t√©cnica. Vari√°veis do tipo `File` **N√ÉO** injetam o conte√∫do do arquivo em uma vari√°vel de ambiente. Em vez disso, o GitLab salva o conte√∫do em um arquivo tempor√°rio no runner e coloca o **CAMINHO** para esse arquivo na vari√°vel de ambiente. O seu script ent√£o precisa ler o arquivo a partir desse caminho.<br/><br/>**Feynman/Dica üéØ:** O GitLab n√£o te d√° o tesouro (`conte√∫do`), ele te d√° o mapa para o tesouro (`caminho do arquivo`). A afirma√ß√£o diz que ele te d√° o tesouro na m√£o. Errado. Fonte: Quest√£o conceitual similar sobre manipula√ß√£o de segredos.                                                                                                                                                                                                                                                                                                                                           |
| 6   | A estrat√©gia de deploy Blue/Green visa reduzir o risco e o downtime ao manter duas vers√µes id√™nticas do ambiente de produ√ß√£o. A transi√ß√£o de tr√°fego do ambiente `blue` para o `green` √© tipicamente orquestrada pelo GitLab Runner, que possui funcionalidades nativas para manipula√ß√£o de DNS (Domain Name System) e regras de balanceadores de carga.                                                                                                                                        | F                                                                                                                                                                                                                                                                                                             | **Formal:** O GitLab Runner executa scripts, mas ele **n√£o possui funcionalidades nativas** para gerenciar DNS ou balanceadores de carga. A l√≥gica para o chaveamento de tr√°fego deve ser implementada em um script (`.sh`, Ansible playbook, etc.) que use as ferramentas apropriadas (CLI da AWS, `kubectl`, API do Cloudflare, etc.). O Runner apenas invoca esse script.<br/><br/>**Feynman/Dica üéØ:** O GitLab Runner √© um "faz-tudo", mas n√£o um "sabe-tudo". Ele √© o gar√ßom que leva seu pedido (`script`) para a cozinha (`servidor`), mas ele mesmo n√£o sabe cozinhar (`gerenciar DNS`). A banca atribuiu uma intelig√™ncia ao Runner que ele n√£o tem.                                                                                                                                                                                                                                                                                                  |
| 7   | Em um monorepo, a utiliza√ß√£o da diretiva `rules:changes` em conjunto com pipelines Pai-Filho (Parent-Child Pipelines) √© uma t√©cnica avan√ßada que permite a um pipeline "pai" detectar quais componentes do reposit√≥rio foram alterados e gerar dinamicamente um pipeline "filho" que executa jobs apenas para esses componentes.                                                                                                                                                                | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© a descri√ß√£o precisa da solu√ß√£o mais escal√°vel para CI/CD em monorepos. O pipeline pai atua como um orquestrador que gera uma configura√ß√£o de pipeline din√¢mica, e o pipeline filho a executa. Isso evita a execu√ß√£o desnecess√°ria de testes e builds para componentes n√£o alterados.<br/><br/>**Feynman/Dica üéØ:** Pense em um restaurante com um menu gigante (monorepo). Em vez de o chef cozinhar todos os pratos do menu para cada pedido (pipeline lento), um gar√ßom inteligente (pipeline pai) anota apenas o que o cliente pediu (`changes`) e entrega uma comanda customizada (pipeline filho) para o chef cozinhar apenas aqueles pratos. √â a m√°xima efici√™ncia.                                                                                                                                                                                                                                                                    |
| 8   | O GitLab Flow, como estrat√©gia de branching, diferencia-se do Git Flow por eliminar o branch `develop` e utilizar branches de ambiente de longa dura√ß√£o (ex: `staging`, `production`) que s√£o diretamente mapeados para os ambientes correspondentes, simplificando o processo de entrega cont√≠nua.                                                                                                                                                                                             | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente as caracter√≠sticas centrais do GitLab Flow. Sua simplicidade e o mapeamento direto de branches para ambientes o tornam mais adequado para projetos que praticam CI/CD do que o mais cerimonioso Git Flow.<br/><br/>**Feynman/Dica üéØ:** O GitLab Flow √© o minimalista do mundo do Git. Ele joga fora o que n√£o √© essencial (`develop`) e organiza o que sobra de forma pr√°tica (branches por ambiente). Se a quest√£o descreve um fluxo mais simples e alinhado com deploy cont√≠nuo, provavelmente √© GitLab Flow.                                                                                                                                                                                                                                                                                                                                                                                                  |
| 9   | O arquivo `CODEOWNERS` permite definir propriet√°rios para arquivos ou diret√≥rios espec√≠ficos. Quando um Merge Request √© aberto, o GitLab utiliza este arquivo para notificar os propriet√°rios, mas a aprova√ß√£o deles √© opcional, servindo como uma sugest√£o de revisores, a menos que seja combinada com a funcionalidade de "Required Approvals" em um branch protegido.                                                                                                                       | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° correta e detalha uma nuance importante. Por si s√≥, o `CODEOWNERS` apenas sugere e notifica. √â a combina√ß√£o com as regras de aprova√ß√£o de um branch protegido que torna essa aprova√ß√£o **obrigat√≥ria**. A banca testa se voc√™ conhece a intera√ß√£o entre as duas funcionalidades.<br/><br/>**Feynman/Dica üéØ:** `CODEOWNERS` te convida para a festa (`revis√£o`). `Branch Protegido` √© o seguran√ßa na porta que diz que voc√™ n√£o entra (`merge`) sem o crach√° de convidado (`aprova√ß√£o`). Os dois trabalham juntos para criar uma festa exclusiva.                                                                                                                                                                                                                                                                                                                                                                                  |
| 10  | (CESPE - 2021, SEFAZ-CE) A integra√ß√£o cont√≠nua √© uma pr√°tica de desenvolvimento de software que visa a evitar que um desenvolvedor suba para o reposit√≥rio um c√≥digo com erro de compila√ß√£o ou que quebre algum teste unit√°rio.                                                                                                                                                                                                                                                                 | V                                                                                                                                                                                                                                                                                                             | **Formal:** A quest√£o descreve o prop√≥sito fundamental da Integra√ß√£o Cont√≠nua (CI). Cada integra√ß√£o de c√≥digo dispara um build e testes automatizados para fornecer feedback r√°pido sobre a sa√∫de do c√≥digo, prevenindo a integra√ß√£o de erros na linha de base principal.<br/><br/>**Feynman/Dica üéØ:** CI √© o "dedo-duro" automatizado da equipe. Antes que seu c√≥digo "fofoque" com os outros c√≥digos no reposit√≥rio, ele passa por uma verifica√ß√£o. Se tiver algo errado, ele te avisa na hora. √â uma quest√£o conceitual cl√°ssica.                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 11  | Um Runner do GitLab configurado com o executor `shell` oferece o maior n√≠vel de seguran√ßa e isolamento entre jobs, pois cada job √© executado em um ambiente de cont√™iner descart√°vel, prevenindo que um job acesse dados ou modifique o ambiente de outro.                                                                                                                                                                                                                                      | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o √© o exato oposto da verdade. O executor `shell` oferece o **menor** n√≠vel de seguran√ßa e isolamento, pois os jobs rodam diretamente na m√°quina do runner e podem interferir uns com os outros. O maior n√≠vel de isolamento √© fornecido pelos executores `docker` e `kubernetes`.<br/><br/>**Feynman/Dica üéØ:** A banca descreveu um sandu√≠che de presunto e disse que √© vegano. `shell` √© compartilhar o mesmo prato e talheres com todos na mesa. `docker` √© dar a cada um seu pr√≥prio prato e talheres descart√°veis. A troca de conceitos √© uma pegadinha cl√°ssica.                                                                                                                                                                                                                                                                                                                                                                   |
| 12  | A utiliza√ß√£o da palavra-chave `interruptible: true` em um job faz com que, caso um novo pipeline seja iniciado para o mesmo Merge Request, o GitLab aguarde a conclus√£o do job antigo antes de iniciar o novo, para garantir a consist√™ncia dos resultados.                                                                                                                                                                                                                                     | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve o comportamento oposto. `interruptible: true` faz com que o job antigo seja **automaticamente cancelado** para que o novo pipeline (com o c√≥digo mais recente) possa rodar imediatamente, economizando recursos e tempo de runner.<br/><br/>**Feynman/Dica üéØ:** `interruptible` significa exatamente isso: que pode ser interrompido. A banca disse que ele "espera". √â uma contradi√ß√£o direta com o significado da palavra. Foco no vocabul√°rio!                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 13  | A vari√°vel de ambiente pr√©-definida `$CI_PIPELINE_SOURCE` √© utilizada para identificar o evento que disparou o pipeline, sendo √∫til para criar regras (`rules`) que executam jobs espec√≠ficos apenas para Merge Requests (`merge_request_event`) ou para execu√ß√µes agendadas (`schedule`).                                                                                                                                                                                                      | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve perfeitamente o prop√≥sito e a utilidade da vari√°vel `$CI_PIPELINE_SOURCE`. √â uma das vari√°veis mais importantes para a cria√ß√£o de l√≥gicas de pipeline condicionais e complexas.<br/><br/>**Feynman/Dica üéØ:** Essa vari√°vel √© o "detetive" do pipeline. Ele te conta *quem* iniciou a confus√£o: foi um `push`? Um `MR`? Um `agendamento`? Sabendo a origem, voc√™ pode decidir o que fazer. √â uma quest√£o de conhecimento direto da ferramenta.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 14  | Para implementar a observabilidade, que √© a capacidade de inferir o estado interno de um sistema a partir de seus outputs externos, √© suficiente coletar logs e m√©tricas. Traces distribu√≠dos s√£o considerados uma otimiza√ß√£o, mas n√£o um dos pilares fundamentais da observabilidade.                                                                                                                                                                                                          | F                                                                                                                                                                                                                                                                                                             | **Formal:** A teoria moderna da observabilidade √© firmemente baseada em tr√™s pilares: **M√©tricas, Logs e Traces**. Traces n√£o s√£o uma otimiza√ß√£o, mas sim o pilar que permite entender o fluxo de uma requisi√ß√£o atrav√©s de m√∫ltiplos servi√ßos em uma arquitetura de microsservi√ßos, sendo essencial para depurar problemas de lat√™ncia e erros em sistemas distribu√≠dos.<br/><br/>**Feynman/Dica üéØ:** Observabilidade √© um banquinho de tr√™s pernas: M√©tricas, Logs e Traces. A banca tirou a perna "Traces" e disse que o banquinho ainda fica de p√©. N√£o fica. Um pilar faltando torna a afirma√ß√£o falsa.                                                                                                                                                                                                                                                                                                                                                   |
| 15  | A integra√ß√£o do GitLab com o HashiCorp Vault permite que os jobs de CI/CD obtenham segredos dinamicamente, autenticando-se no Vault atrav√©s de um JSON Web Token (JWT) de curta dura√ß√£o fornecido pelo GitLab. Isso evita que segredos de longa dura√ß√£o sejam armazenados nas CI/CD Variables do GitLab.                                                                                                                                                                                        | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© a descri√ß√£o precisa e t√©cnica da integra√ß√£o segura com o Vault. √â o padr√£o-ouro para o gerenciamento de segredos, pois minimiza a superf√≠cie de ataque ao eliminar a necessidade de armazenar segredos est√°ticos no pr√≥prio sistema de CI.<br/><br/>**Feynman/Dica üéØ:** Em vez de dar a senha do cofre (`segredo no GitLab`) ao seu funcion√°rio (`job`), voc√™ d√° a ele um crach√° especial (`JWT`) que s√≥ funciona por 5 minutos para pegar um item espec√≠fico no cofre (`Vault`). √â muito mais seguro. A afirma√ß√£o descreve este processo moderno.                                                                                                                                                                                                                                                                                                                                                                                          |
| 16  | (Adaptada - IADES/2019) O uso de Docker em um pipeline de CI/CD, por meio do executor `docker`, garante que o ambiente de execu√ß√£o dos jobs seja consistente e isolado, resolvendo o problema "funciona na minha m√°quina", e permite a utiliza√ß√£o de imagens de servi√ßo, como bancos de dados, para testes de integra√ß√£o.                                                                                                                                                                       | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o duas das principais vantagens de usar o executor `docker`: a cria√ß√£o de ambientes de build reproduz√≠veis e o uso de `services` para instanciar depend√™ncias externas (como um banco de dados) para a execu√ß√£o de testes de integra√ß√£o de forma isolada.<br/><br/>**Feynman/Dica üéØ:** O Docker cria uma "caixa de areia" limpa e padronizada para cada `job` brincar. Ele pode at√© trazer seus pr√≥prios brinquedos (`services`, como um banco de dados). Isso garante que a brincadeira (`build/test`) seja sempre a mesma, n√£o importa em qual parquinho (`runner`) ela aconte√ßa.                                                                                                                                                                                                                                                                                                                                |
| 17  | A diretiva `resource_group` em um job de deploy no `.gitlab-ci.yml` √© utilizada para agrupar m√∫ltiplos jobs que podem ser executados em paralelo para o mesmo ambiente, aumentando a velocidade do deploy.                                                                                                                                                                                                                                                                                      | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve o oposto do prop√≥sito do `resource_group`. Ele atua como um **mutex (bloqueio de exclus√£o m√∫tua)**, garantindo que apenas **um** job com o mesmo `resource_group` seja executado por vez. Seu objetivo √© prevenir condi√ß√µes de corrida e garantir a seguran√ßa do deploy, e n√£o aumentar o paralelismo.<br/><br/>**Feynman/Dica üéØ:** Pense em `resource_group` como a chave do banheiro em um posto de gasolina. S√≥ uma pessoa pode usar o banheiro (`ambiente de deploy`) por vez. A afirma√ß√£o diz que a chave serve para que v√°rias pessoas usem o banheiro ao mesmo tempo. N√£o faz sentido. √â uma pegadinha de invers√£o de conceito.                                                                                                                                                                                                                                                                                        |
| 18  | No GitLab, o tier `Free` oferece funcionalidades de CI/CD, incluindo o uso de Shared Runners, mas as ferramentas de An√°lise de Seguran√ßa de Aplica√ß√£o Est√°tica (SAST) e An√°lise de Seguran√ßa de Aplica√ß√£o Din√¢mica (DAST) s√£o exclusivas do tier `Premium`.                                                                                                                                                                                                                                     | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° na distribui√ß√£o dos tiers. As principais funcionalidades de DevSecOps (SAST, DAST, Dependency Scanning, etc.) s√£o, na verdade, exclusivas do tier **Ultimate**. O tier `Premium` foca mais em governan√ßa e gerenciamento de projetos (Code Owners, Aprova√ß√µes de MR, Roadmaps), mas n√£o inclui a su√≠te de seguran√ßa avan√ßada.<br/><br/>**Feynman/Dica üéØ:** A banca te oferece um menu de tr√™s pratos: Gr√°tis, Premium e Ultimate. Ela pegou o prato principal do Ultimate (seguran√ßa) e disse que ele vem no Premium. √â uma troca sutil, mas que testa o conhecimento detalhado dos planos comerciais do GitLab. **Lembre-se:** Seguran√ßa de ponta = Ultimate.                                                                                                                                                                                                                                                                    |
| 19  | Para implementar um rollback autom√°tico de um release com falha, um pipeline pode utilizar um job com a regra `when: on_failure` que, ao ser acionado, consulta a API (Application Programming Interface) do GitLab para encontrar o √∫ltimo deploy bem-sucedido para aquele `environment` e re-executa o job de deploy correspondente.                                                                                                                                                          | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma descri√ß√£o t√©cnica e vi√°vel de uma implementa√ß√£o de rollback autom√°tico. O uso combinado de `environments` para rastrear o hist√≥rico de deploys, um job de monitoramento que pode falhar e um job de `on_failure` que usa a API para reverter, comp√µe um ciclo de resili√™ncia completo.<br/><br/>**Feynman/Dica üéØ:** O pipeline tem um plano B. Se o "Plano A" (`deploy`) explode no ar (job de monitoramento falha), o "Plano B" (`rollback job`) √© acionado automaticamente. Ele pega o avi√£o anterior que pousou em seguran√ßa (`√∫ltimo deploy de sucesso`) e o coloca no ar novamente.                                                                                                                                                                                                                                                                                                                                                |
| 20  | A diretiva `needs` permite criar um Grafo Ac√≠clico Dirigido (DAG), mas ela s√≥ pode definir depend√™ncias entre jobs que est√£o em est√°gios diferentes. N√£o √© poss√≠vel usar `needs` para criar uma depend√™ncia entre dois jobs que pertencem ao mesmo est√°gio.                                                                                                                                                                                                                                     | F                                                                                                                                                                                                                                                                                                             | **Formal:** √â perfeitamente poss√≠vel e comum usar `needs` para criar depend√™ncias entre jobs no mesmo est√°gio. Por exemplo, em um est√°gio `test`, um job de teste de integra√ß√£o (`integration_test`) pode ter um `needs: [unit_test]` para garantir que os testes unit√°rios passem primeiro, mesmo que ambos estejam no mesmo est√°gio l√≥gico.<br/><br/>**Feynman/Dica üéØ:** A banca colocou uma limita√ß√£o que n√£o existe. `needs` √© sobre a depend√™ncia do `job`, n√£o do `stage`. Ele te d√° liberdade total para conectar os pontos (`jobs`) como voc√™ quiser, desde que n√£o crie um loop. A restri√ß√£o imposta na afirma√ß√£o √© a pegadinha.                                                                                                                                                                                                                                                                                                                      |
| 21  | A Lei Geral de Prote√ß√£o de Dados (LGPD - Lei n¬∫ 13.709/2018) exige a rastreabilidade e a documenta√ß√£o dos processos que lidam com dados pessoais. A utiliza√ß√£o de um pipeline de CI/CD no GitLab, onde cada altera√ß√£o de c√≥digo e deploy √© registrada, versionada e associada a um Merge Request com aprova√ß√µes, pode ser utilizada como evid√™ncia para auditorias de conformidade com a LGPD.                                                                                                  | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o faz uma conex√£o correta entre uma exig√™ncia legal e uma capacidade t√©cnica. Embora o GitLab n√£o "garanta" a conformidade por si s√≥, seu rastro de auditoria completo (quem mudou o qu√™, quem aprovou, quando foi para produ√ß√£o) √© uma ferramenta poderosa para demonstrar o devido processo e a governan√ßa exigidos por regulamenta√ß√µes como a LGPD, GDPR ou SOX.<br/><br/>**Feynman/Dica üéØ:** Pense no GitLab como o "cart√≥rio" da sua empresa de software. Cada passo, cada assinatura (`aprova√ß√£o`), cada documento (`c√≥digo`) √© carimbado e arquivado. Quando o fiscal da LGPD (`auditor`) aparece, voc√™ tem uma pasta organizada para mostrar todo o hist√≥rico. A conex√£o entre TI e Direito √© um tema moderno em concursos.                                                                                                                                                                                                      |
| 22  | Em uma arquitetura de microsservi√ßos gerenciada com multi-repo, a forma recomendada para lidar com depend√™ncias entre projetos (ex: uma biblioteca comum) √© utilizar a diretiva `include:project`, que permite que o pipeline do servi√ßo consumidor inclua e execute diretamente o pipeline da biblioteca.                                                                                                                                                                                      | F                                                                                                                                                                                                                                                                                                             | **Formal:** `include:project` √© usado para compartilhar *templates* de configura√ß√£o de pipeline, e n√£o para orquestrar a execu√ß√£o entre projetos. A ferramenta correta para um pipeline em um projeto disparar a execu√ß√£o de um pipeline em outro projeto √© a diretiva **`trigger`**. A afirma√ß√£o confunde compartilhar configura√ß√£o com disparar execu√ß√£o.<br/><br/>**Feynman/Dica üéØ:** `include` √© como copiar e colar uma receita de bolo de um livro para o seu. `trigger` √© como telefonar para o seu vizinho e pedir para ele come√ßar a fazer o bolo dele agora. S√£o a√ß√µes completamente diferentes. Pegadinha de terminologia precisa.                                                                                                                                                                                                                                                                                                                  |
| 23  | A pr√°tica de tratar a configura√ß√£o do pipeline como c√≥digo (Pipeline as Code), ao armazenar o arquivo `.gitlab-ci.yml` no mesmo reposit√≥rio do c√≥digo da aplica√ß√£o, permite aplicar os mesmos princ√≠pios de versionamento, revis√£o por pares (via MR) e auditoria ao processo de CI/CD que s√£o aplicados ao c√≥digo-fonte.                                                                                                                                                                       | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© a defini√ß√£o e a principal vantagem do "Pipeline as Code". O processo de automa√ß√£o se torna parte do produto de software, com todo o rigor de engenharia que isso implica.<br/><br/>**Feynman/Dica üéØ:** Seu pipeline n√£o √© mais uma "caixa preta" configurada por cliques em uma interface. Ele √© um cidad√£o de primeira classe no seu projeto, com certid√£o de nascimento (`commit inicial`), hist√≥rico de vida (`git log`) e precisa de permiss√£o (`MR`) para mudar.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 24  | (FGV - 2022, SENADO FEDERAL) Em um fluxo de trabalho Git, o comando `git push --tags` √© utilizado para enviar para o reposit√≥rio remoto apenas as tags que foram criadas desde o √∫ltimo push, sendo uma forma incremental de sincroniza√ß√£o.                                                                                                                                                                                                                                                     | F                                                                                                                                                                                                                                                                                                             | **Formal:** Por padr√£o, `git push` n√£o envia tags. O comando `git push --tags` envia **TODAS** as suas tags locais que ainda n√£o existem no reposit√≥rio remoto, e n√£o apenas as criadas desde o √∫ltimo push. N√£o √© um comando inerentemente incremental baseado no hist√≥rico de push.<br/><br/>**Feynman/Dica üéØ:** A banca usa a palavra "incremental" para te induzir ao erro. O comando √© mais como um "sincronize todas as minhas tags faltantes", n√£o um "envie minhas novas tags". √â uma pegadinha sobre o comportamento exato de um comando Git fundamental para o processo de release.                                                                                                                                                                                                                                                                                                                                                                  |
| 25  | A filosofia de "shift left" no contexto de DevSecOps, facilitada pelo GitLab, refere-se a mover as atividades de seguran√ßa para os est√°gios finais do ciclo de vida, como `staging` e `production`, onde as ferramentas de DAST podem analisar a aplica√ß√£o em um ambiente realista e completo.                                                                                                                                                                                                  | F                                                                                                                                                                                                                                                                                                             | **Formal:** "Shift Left" (Mover para a Esquerda) significa mover as atividades de seguran√ßa para o **in√≠cio** do ciclo de vida (para a "esquerda" em um diagrama de fluxo). O objetivo √© encontrar e corrigir vulnerabilidades o mais cedo poss√≠vel, idealmente durante o desenvolvimento e no Merge Request, quando o custo da corre√ß√£o √© menor. A afirma√ß√£o inverte o conceito.<br/><br/>**Feynman/Dica üéØ:** Pense em uma linha do tempo. A esquerda √© o come√ßo (ideia, c√≥digo), a direita √© o fim (produ√ß√£o). "Shift Left" √© fazer as coisas mais cedo. A banca disse que √© fazer as coisas mais tarde. √â uma invers√£o direta do significado. Como disse Her√°clito, "O caminho para cima e o caminho para baixo s√£o um e o mesmo", mas aqui, a dire√ß√£o importa!                                                                                                                                                                                             |
| 26  | A vari√°vel `$CI_JOB_TOKEN` √© um token de curta dura√ß√£o e com escopo limitado, que permite que um job se autentique no mesmo projeto GitLab para, por exemplo, puxar imagens do Container Registry ou clonar outro reposit√≥rio, sem a necessidade de criar tokens de acesso pessoal.                                                                                                                                                                                                             | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente a fun√ß√£o e os benef√≠cios do `$CI_JOB_TOKEN`. Ele √© um mecanismo de autentica√ß√£o seguro e autom√°tico, fundamental para a intera√ß√£o entre jobs e outras funcionalidades do GitLab dentro do mesmo projeto ou inst√¢ncia.<br/><br/>**Feynman/Dica üéØ:** O `$CI_JOB_TOKEN` √© o crach√° tempor√°rio que o GitLab d√° para cada `job`. Com ele, o `job` pode andar pelas √°reas permitidas do "pr√©dio" (`projeto GitLab`) sem precisar de uma chave mestra (`token pessoal`). √â seguro e pr√°tico.                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 27  | O GitLab Pages √© um servi√ßo para hospedar sites est√°ticos diretamente de um reposit√≥rio. Para publicar um site, √© necess√°rio criar um job com o nome `pages`, cujo script deve gerar os arquivos do site e mov√™-los para um artefato na pasta `_site`, seguindo a conven√ß√£o do Jekyll, que √© o √∫nico gerador de site est√°tico suportado.                                                                                                                                                        | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° na parte final. O job precisa, sim, se chamar `pages` e gerar os arquivos em uma pasta `public` (n√£o `_site`) que √© salva como artefato. No entanto, o GitLab Pages √© agn√≥stico em rela√ß√£o ao gerador. Voc√™ pode usar qualquer ferramenta (Hugo, Gatsby, Next.js, ou apenas HTML puro) para gerar os arquivos est√°ticos, desde que o resultado final esteja na pasta `public`.<br/><br/>**Feynman/Dica üéØ:** A banca te d√° 90% de verdade e 10% de mentira. O nome do job (`pages`) est√° certo, a ideia de artefato est√° certa. A pasta de destino (`_site` em vez de `public`) e a restri√ß√£o ao Jekyll s√£o as mentiras. Foco nos detalhes t√©cnicos precisos.                                                                                                                                                                                                                                                                      |
| 28  | A utiliza√ß√£o de um Dockerfile multi-est√°gio √© uma t√©cnica de otimiza√ß√£o que permite separar o ambiente de build do ambiente de produ√ß√£o, resultando em uma imagem final menor e mais segura, pois cont√©m apenas o artefato compilado e as depend√™ncias de tempo de execu√ß√£o, excluindo as ferramentas de build e depend√™ncias de desenvolvimento.                                                                                                                                               | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© a defini√ß√£o perfeita e o prop√≥sito de um Dockerfile multi-est√°gio. √â uma das pr√°ticas mais importantes para a cria√ß√£o de imagens Docker prontas para produ√ß√£o.<br/><br/>**Feynman/Dica üéØ:** √â como cozinhar. Voc√™ usa uma cozinha industrial cheia de ferramentas (`est√°gio de build`) para preparar a comida. Mas na hora de entregar, voc√™ coloca s√≥ a comida pronta em uma embalagem pequena e limpa (`est√°gio de produ√ß√£o`), sem levar o fog√£o e as panelas junto.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 29  | A funcionalidade de Value Stream Analytics do GitLab fornece m√©tricas de performance do pipeline, como a dura√ß√£o dos jobs e a frequ√™ncia de falhas, sendo a principal ferramenta para identificar gargalos t√©cnicos na execu√ß√£o do CI/CD.                                                                                                                                                                                                                                                       | F                                                                                                                                                                                                                                                                                                             | **Formal:** Embora a identifica√ß√£o de gargalos seja o objetivo, o Value Stream Analytics (VSA) foca no **fluxo de valor completo**, medindo o tempo gasto em etapas do processo humano e de desenvolvimento, como o tempo de revis√£o de um MR ou o tempo que uma issue fica em planejamento. A ferramenta para analisar a performance t√©cnica dos pipelines (dura√ß√£o, etc.) √© a se√ß√£o **CI/CD Analytics**.<br/><br/>**Feynman/Dica üéØ:** A banca trocou as ferramentas. **CI/CD Analytics** √© o "veloc√≠metro" do seu pipeline, mede a performance da m√°quina. **Value Stream Analytics** √© o "cron√¥metro" do seu processo de ponta a ponta, mede a performance da equipe e do fluxo. S√£o an√°lises diferentes.                                                                                                                                                                                                                                                   |
| 30  | A diretiva `parallel` em um job do GitLab permite executar m√∫ltiplos scripts diferentes em paralelo dentro do mesmo job, para acelerar tarefas independentes.                                                                                                                                                                                                                                                                                                                                   | F                                                                                                                                                                                                                                                                                                             | **Formal:** A diretiva `parallel` executa o **mesmo** job (com o mesmo script) m√∫ltiplas vezes em paralelo. Ela n√£o serve para rodar scripts diferentes. Seu principal caso de uso √© dividir uma grande su√≠te de testes (sharding), onde cada execu√ß√£o paralela roda uma fatia dos testes usando as vari√°veis `CI_NODE_INDEX` e `CI_NODE_TOTAL`.<br/><br/>**Feynman/Dica üéØ:** `parallel` √© como ter uma m√°quina de xerox que tira v√°rias c√≥pias da *mesma* p√°gina ao mesmo tempo. A afirma√ß√£o diz que ela tira c√≥pias de *p√°ginas diferentes* simultaneamente. √â uma interpreta√ß√£o errada da funcionalidade.                                                                                                                                                                                                                                                                                                                                                   |
| 31  | A integra√ß√£o do GitLab com o Prometheus permite que m√©tricas de sa√∫de da aplica√ß√£o sejam coletadas e exibidas diretamente na interface do GitLab. Para que isso funcione, a aplica√ß√£o deve expor um endpoint `/metrics` e o servidor Prometheus deve ser configurado para "raspar" (scrape) esse endpoint, sendo o GitLab um intermedi√°rio para visualiza√ß√£o.                                                                                                                                   | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente a arquitetura de integra√ß√£o. A aplica√ß√£o exp√µe, o Prometheus coleta, e o GitLab visualiza. √â um fluxo de dados cl√°ssico para monitoramento em ecossistemas modernos.<br/><br/>**Feynman/Dica üéØ:** A aplica√ß√£o "fala" sobre sua sa√∫de. O Prometheus √© o "ouvinte" que anota tudo. O GitLab √© o "rep√≥rter" que pega as anota√ß√µes do Prometheus e as exibe em uma manchete de jornal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 32  | O arquivo `erlang.config`, mencionado no `docker-compose.yml` para o servi√ßo RabbitMQ, √© um arquivo de configura√ß√£o espec√≠fico do GitLab Runner, utilizado para otimizar a comunica√ß√£o entre o runner e o message broker.                                                                                                                                                                                                                                                                       | F                                                                                                                                                                                                                                                                                                             | **Formal:** O arquivo `erlang.config` n√£o tem nenhuma rela√ß√£o com o GitLab Runner. Ele √© um arquivo de configura√ß√£o do ambiente de tempo de execu√ß√£o do **Erlang/OTP**, a tecnologia sobre a qual o RabbitMQ √© constru√≠do. Ele √© usado para ajustar par√¢metros de baixo n√≠vel da M√°quina Virtual Erlang (BEAM), como configura√ß√µes de rede e kernel.<br/><br/>**Feynman/Dica üéØ:** A banca pegou um detalhe t√©cnico muito espec√≠fico de um servi√ßo (RabbitMQ) e tentou conect√°-lo √† ferramenta principal (GitLab). √â uma tentativa de confundir o candidato misturando tecnologias. Se voc√™ n√£o reconhece um arquivo de configura√ß√£o, desconfie se ele pertence √† ferramenta que est√° sendo primariamente testada.                                                                                                                                                                                                                                              |
| 33  | A diretiva `after_script` em um job do `.gitlab-ci.yml` define uma s√©rie de comandos que s√£o executados somente se o `script` principal do job for conclu√≠do com sucesso.                                                                                                                                                                                                                                                                                                                       | F                                                                                                                                                                                                                                                                                                             | **Formal:** `after_script` executa **independentemente do resultado do job** (sucesso ou falha). Seu prop√≥sito √© executar tarefas de limpeza, como remover arquivos tempor√°rios, fazer logout de servi√ßos ou coletar logs de depura√ß√£o, coisas que voc√™ quer que aconte√ßam n√£o importa o que aconte√ßa no script principal.<br/><br/>**Feynman/Dica üéØ:** Pense no `after_script` como a equipe de limpeza do teatro. Eles entram e limpam o palco (`runner`) depois que a pe√ßa (`job`) acaba, n√£o importa se a pe√ßa foi um sucesso aplaudido de p√© ou um fracasso vaiado. A banca disse que eles s√≥ limpam se a pe√ßa for um sucesso.                                                                                                                                                                                                                                                                                                                            |
| 34  | A utiliza√ß√£o de um `healthcheck` no `docker-compose.yml` ou em um Dockerfile permite que o Docker Engine verifique a sa√∫de interna de um cont√™iner. Se um `healthcheck` falhar repetidamente, o Docker ir√° automaticamente remover e recriar o cont√™iner a partir da imagem original.                                                                                                                                                                                                           | F                                                                                                                                                                                                                                                                                                             | **Formal:** O `healthcheck` informa o **estado** do cont√™iner (`healthy`, `unhealthy`). Outras partes do ecossistema podem usar essa informa√ß√£o. Por exemplo, um orquestrador como o Kubernetes pode decidir reiniciar um pod "unhealthy". No `docker-compose`, a diretiva `restart: always` ir√° reiniciar um cont√™iner que parou, mas o `healthcheck` por si s√≥ n√£o aciona uma recria√ß√£o. A a√ß√£o de recriar n√£o √© o comportamento padr√£o do Docker Engine isoladamente.<br/><br/>**Feynman/Dica üéØ:** O `healthcheck` √© o term√¥metro. Ele te diz se o paciente (`cont√™iner`) est√° com febre (`unhealthy`). Ele n√£o √© o m√©dico que aplica a inje√ß√£o (`recria√ß√£o`). A afirma√ß√£o confundiu o diagn√≥stico com o tratamento.                                                                                                                                                                                                                                        |
| 35  | Para conectar um job do GitLab CI a um cluster Kubernetes de forma segura, a abordagem recomendada √© instalar o GitLab Agent for Kubernetes no cluster. O Agent estabelece uma conex√£o reversa e segura com o GitLab, eliminando a necessidade de expor o servidor da API do Kubernetes na internet ou de armazenar credenciais de cluster (`kubeconfig`) como vari√°veis no GitLab.                                                                                                             | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o a arquitetura e os benef√≠cios de seguran√ßa do GitLab Agent for Kubernetes. Ele representa a evolu√ß√£o em rela√ß√£o ao m√©todo antigo (baseado em `kubeconfig`), seguindo o princ√≠pio de "conex√£o de dentro para fora" que √© muito mais seguro.<br/><br/>**Feynman/Dica üéØ:** Em vez de voc√™ deixar a porta da sua casa (`API do K8s`) aberta para o entregador do GitLab entrar, o Agente √© como um "mordomo" que mora na sua casa e liga para o GitLab para perguntar se tem alguma entrega, buscando-a de forma segura. √â a diferen√ßa entre uma porta aberta e uma comunica√ß√£o segura iniciada internamente.                                                                                                                                                                                                                                                                                                        |
| 36  | Em um pipeline GitLab, √© poss√≠vel passar vari√°veis de um job para outro em um est√°gio subsequente utilizando `artifacts` do tipo `.env`. Para isso, o job produtor gera um arquivo de texto com declara√ß√µes `export VAR=valor`, e o job consumidor automaticamente carrega essas vari√°veis em seu ambiente de shell, tornando-as dispon√≠veis para o script.                                                                                                                                     | F                                                                                                                                                                                                                                                                                                             | **Formal:** A funcionalidade de artefatos do tipo `.env` (`artifacts:reports:dotenv`) existe e √© poderosa, mas a afirma√ß√£o descreve seu funcionamento de forma incorreta. O arquivo gerado deve ter o formato `VAR=valor` (sem `export`). E o mais importante, essas vari√°veis s√£o carregadas e disponibilizadas apenas para **jobs subsequentes que possuem `needs` ou `dependencies`** apontando para o job produtor, e n√£o para todos os jobs subsequentes indiscriminadamente.<br/><br/>**Feynman/Dica üéØ:** A banca descreveu uma transfer√™ncia de poder quase m√°gica. Na realidade, a transfer√™ncia √© expl√≠cita. O job "filho" precisa declarar que "herda" (`needs`) do job "pai" para receber as vari√°veis. A pegadinha est√° na palavra "automaticamente" e no formato do arquivo, testando o conhecimento preciso do mecanismo.                                                                                                                        |
| 37  | A diretiva `workflow:rules` no `.gitlab-ci.yml` √© utilizada para controlar a execu√ß√£o de jobs individuais dentro de um pipeline j√° existente, permitindo, por exemplo, que um job de deploy seja ignorado se o commit for em um branch de feature.                                                                                                                                                                                                                                              | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o confunde o escopo de `workflow:rules` com o de `rules` dentro de um job. `workflow:rules` opera em um n√≠vel superior e decide se **um pipeline inteiro deve ser criado ou n√£o**. A l√≥gica descrita na afirma√ß√£o ‚Äì controlar a execu√ß√£o de um *job individual* ‚Äì √© a fun√ß√£o da diretiva `rules` definida dentro daquele job.<br/><br/>**Feynman/Dica üéØ:** Pense no `workflow` como o porteiro do pr√©dio. Ele decide se voc√™ entra no pr√©dio (`cria o pipeline`). `rules` dentro de um job √© o seguran√ßa de uma sala espec√≠fica. Ele decide se voc√™ entra naquela sala (`executa o job`). A banca trocou o porteiro do pr√©dio pelo seguran√ßa da sala.                                                                                                                                                                                                                                                                                    |
| 38  | A integra√ß√£o do GitLab com o Ansible para automa√ß√£o de deploy √© eficaz, mas requer que o servidor de destino tenha o Ansible instalado, pois o GitLab Runner se conecta via SSH e invoca o comando `ansible-playbook` diretamente na m√°quina remota.                                                                                                                                                                                                                                            | F                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma invers√£o fundamental de como o Ansible funciona no modo "push" (o padr√£o). O Ansible **n√£o precisa ser instalado na m√°quina de destino**. A m√°quina de controle (neste caso, o cont√™iner do GitLab Runner que cont√©m Ansible) se conecta via SSH ao destino e executa m√≥dulos Python que s√£o enviados para o n√≥ gerenciado, sem a necessidade de um agente ou instala√ß√£o pr√©via no destino.<br/><br/>**Feynman/Dica üéØ:** O Ansible √© como um mestre de marionetes. Ele fica no palco (`Runner`) e controla os bonecos (`servidores de destino`) usando fios (`SSH`). Os bonecos n√£o precisam ter um "mini-mestre" instalado neles. A afirma√ß√£o sugere que os bonecos precisam de uma instala√ß√£o pr√©via, o que √© falso para o modo padr√£o.                                                                                                                                                                                               |
| 39  | A utiliza√ß√£o de "Feature Flags" (ou Feature Toggles) √© uma pr√°tica de engenharia que complementa o Trunk-Based Development, permitindo que os desenvolvedores integrem c√≥digo de features inacabadas no branch principal (`main`) de forma segura, mantendo essas features desabilitadas em produ√ß√£o at√© que estejam prontas para o lan√ßamento.                                                                                                                                                 | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve perfeitamente a sinergia entre Feature Flags e Trunk-Based Development. Essa combina√ß√£o permite a integra√ß√£o cont√≠nua de todo o c√≥digo, evitando os "merge hells" de branches de longa dura√ß√£o, ao mesmo tempo que desvincula o deploy do c√≥digo da sua libera√ß√£o para os usu√°rios, dando controle total ao time de produto.<br/><br/>**Feynman/Dica üéØ:** A Feature Flag √© um "interruptor" üí° no seu c√≥digo. Voc√™ instala a fia√ß√£o e a l√¢mpada (`c√≥digo da feature`) na parede (`main branch`), mas deixa o interruptor desligado. O c√≥digo est√° em produ√ß√£o, mas ningu√©m v√™ a luz. Quando est√° pronto, voc√™ apenas liga o interruptor, sem precisar chamar o eletricista de novo (`fazer outro deploy`).                                                                                                                                                                                                                    |
| 40  | O GitLab Runner, ao usar o executor Kubernetes, cria um Pod para cada job. As diretivas `image` e `services` do `.gitlab-ci.yml` s√£o mapeadas, respectivamente, para a imagem do cont√™iner principal e para os cont√™ineres "sidecar" dentro do mesmo Pod, compartilhando o mesmo contexto de rede.                                                                                                                                                                                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma descri√ß√£o t√©cnica precisa de como o executor Kubernetes do GitLab traduz a sintaxe do `.gitlab-ci.yml` para objetos Kubernetes. O cont√™iner principal executa o `script`, enquanto os `services` se tornam cont√™ineres adicionais no mesmo Pod, o que permite que eles se comuniquem via `localhost`, simplificando a configura√ß√£o de testes de integra√ß√£o.<br/><br/>**Feynman/Dica üéØ:** Um `Pod` no Kubernetes √© como um pequeno apartamento. O `image` do job √© o morador principal. Os `services` s√£o os colegas de quarto que ele chama para ajudar. Eles moram todos juntos e podem conversar facilmente (via `localhost`), mas est√£o isolados dos outros apartamentos (`outros jobs`).                                                                                                                                                                                                                                            |
| 41  | Em um pipeline GitLab, um job configurado com `when: delayed` e `start_in: '1 hour'` ser√° iniciado exatamente 1 hora ap√≥s a conclus√£o do est√°gio anterior, mesmo que o Runner associado s√≥ fique dispon√≠vel 30 minutos depois desse per√≠odo.                                                                                                                                                                                                                                                    | F                                                                                                                                                                                                                                                                                                             | **Formal:** O `start_in` define o tempo m√≠nimo de espera antes que um job possa ser enfileirado. O job s√≥ come√ßar√° a ser executado quando duas condi√ß√µes forem atendidas: o tempo de espera ter passado **E** um Runner compat√≠vel estar dispon√≠vel para execut√°-lo. Ele n√£o "reserva" um runner para o futuro.<br/><br/>**Feynman/Dica üéØ:** A afirma√ß√£o ignora a disponibilidade dos recursos. √â como agendar uma reuni√£o para as 15h (`start_in: '1 hour'`). Se a sala de reuni√µes (`Runner`) s√≥ desocupar √†s 15h30, a reuni√£o s√≥ come√ßar√° √†s 15h30, mesmo que o hor√°rio agendado j√° tenha passado. A inten√ß√£o n√£o garante a execu√ß√£o imediata.                                                                                                                                                                                                                                                                                                              |
| 42  | (Adaptada - FCC/2018) O arquivo `pom.xml` em um projeto Maven √© utilizado para definir as depend√™ncias do projeto e os plugins de build. A execu√ß√£o do comando `mvn dependency:go-offline` em um pipeline de CI tem o objetivo de baixar todas as depend√™ncias do projeto para um cache local do Maven, permitindo que os builds subsequentes sejam executados sem acesso √† internet, desde que as depend√™ncias n√£o tenham sido alteradas.                                                      | V                                                                                                                                                                                                                                                                                                             | **Formal:** A quest√£o descreve corretamente a fun√ß√£o do `pom.xml` e o prop√≥sito do goal `dependency:go-offline`. √â uma t√©cnica de otimiza√ß√£o crucial em pipelines para acelerar builds e torn√°-los mais resilientes a falhas de rede, pr√©-populando o cache de depend√™ncias.<br/><br/>**Feynman/Dica üéØ:** Pense nisso como ir ao supermercado (`internet`) e comprar todos os ingredientes (`depend√™ncias`) da sua receita de uma vez s√≥ e guard√°-los na sua despensa (`cache local`). Na pr√≥xima vez que for cozinhar, voc√™ pega tudo da despensa, o que √© muito mais r√°pido e n√£o depende de o supermercado estar aberto.                                                                                                                                                                                                                                                                                                                                    |
| 43  | A funcionalidade Auto DevOps do GitLab, quando ativada, analisa o c√≥digo-fonte do projeto e cria automaticamente um pipeline completo de CI/CD, incluindo build, teste, an√°lise de seguran√ßa e deploy para um cluster Kubernetes, utilizando Herokuish Buildpacks. No entanto, ela n√£o suporta projetos Java que utilizam Gradle, sendo compat√≠vel apenas com Maven.                                                                                                                            | F                                                                                                                                                                                                                                                                                                             | **Formal:** O Auto DevOps √© extremamente poderoso e flex√≠vel. Ele suporta uma vasta gama de linguagens e gerenciadores de depend√™ncia, incluindo Java com Maven **e** Gradle. A afirma√ß√£o cria uma limita√ß√£o falsa para invalidar a quest√£o. O Auto DevOps detectar√° o `build.gradle` e usar√° a l√≥gica apropriada.<br/><br/>**Feynman/Dica üéØ:** O Auto DevOps √© o "faz-tudo" inteligente do GitLab. A banca tenta te convencer de que ele sabe falar v√°rias l√≠nguas, mas esqueceu uma muito popular (Gradle). √â uma tentativa de pegar o candidato no detalhe do suporte a tecnologias espec√≠ficas. Na d√∫vida, lembre-se que o Auto DevOps √© projetado para ser abrangente.                                                                                                                                                                                                                                                                                    |
| 44  | O princ√≠pio de Idempot√™ncia, crucial para a automa√ß√£o de deploy com ferramentas como Ansible ou Terraform, garante que a execu√ß√£o de uma opera√ß√£o m√∫ltiplas vezes produzir√° o mesmo resultado que produzi-la uma √∫nica vez. Isso significa que, se um pipeline de deploy falhar no meio e for re-executado, ele n√£o ir√° duplicar recursos ou causar erros, mas sim verificar o estado atual e aplicar apenas as mudan√ßas necess√°rias.                                                           | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© a defini√ß√£o exata de idempot√™ncia e sua import√¢ncia cr√≠tica em pipelines de automa√ß√£o. Ferramentas que possuem essa caracter√≠stica s√£o inerentemente mais seguras e resilientes, pois permitem a re-execu√ß√£o de tarefas sem efeitos colaterais indesejados.<br/><br/>**Feynman/Dica üéØ:** Idempot√™ncia √© como um interruptor de luz. Apertar uma vez acende a luz. Apertar de novo (ou mais 10 vezes) com a luz j√° acesa n√£o faz nada de novo; o resultado final (luz acesa) √© o mesmo. Ferramentas idempotentes s√£o "inteligentes" o suficiente para n√£o refazerem o que j√° est√° feito.                                                                                                                                                                                                                                                                                                                                                     |
| 45  | A diretiva `trigger` em um pipeline pode ser usada para iniciar um pipeline em um projeto downstream. No entanto, por raz√µes de seguran√ßa, n√£o √© poss√≠vel passar vari√°veis do pipeline "pai" para o pipeline "filho", que deve contar apenas com suas pr√≥prias vari√°veis de projeto.                                                                                                                                                                                                            | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o √© falsa. A diretiva `trigger` suporta o encaminhamento de vari√°veis. Voc√™ pode usar a sintaxe `forward` dentro da chave `trigger` para passar vari√°veis espec√≠ficas, como `forward: { yaml_variables: true, pipeline_variables: true }`, ou passar vari√°veis customizadas. Essa capacidade √© essencial para passar contexto entre pipelines.<br/><br/>**Feynman/Dica üéØ:** A banca est√° tentando impor uma limita√ß√£o de seguran√ßa que, na pr√°tica, tornaria a funcionalidade muito menos √∫til. √â poss√≠vel, sim, passar informa√ß√µes. Pense em uma corrida de revezamento: o corredor A (`pai`) precisa passar o bast√£o (`vari√°veis`) para o corredor B (`filho`). A afirma√ß√£o diz que isso √© proibido.                                                                                                                                                                                                                                   |
| 46  | O GitLab Container Registry √© compat√≠vel com a especifica√ß√£o da Docker Registry API V2, o que significa que ele pode ser usado para armazenar n√£o apenas imagens Docker, mas tamb√©m outros tipos de pacotes compat√≠veis com o formato OCI (Open Container Initiative), como Helm Charts.                                                                                                                                                                                                        | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° correta. O registro do GitLab evoluiu para ser mais do que apenas um registro Docker. Sendo compat√≠vel com a especifica√ß√£o OCI, ele pode ser usado como um reposit√≥rio gen√©rico para diversos tipos de artefatos de nuvem nativa, incluindo Helm Charts, o que centraliza ainda mais a gest√£o de pacotes de release.<br/><br/>**Feynman/Dica üéØ:** O Container Registry do GitLab √© como uma garagem moderna. No come√ßo, era s√≥ para carros (`Docker`). Agora, ela aceita motos, bicicletas e patinetes (`Helm Charts`, `WASM`, etc.), desde que eles sigam as regras de tr√¢nsito do condom√≠nio (`padr√£o OCI`).                                                                                                                                                                                                                                                                                                                    |
| 47  | (Adaptada - CESGRANRIO/2018) Em um pipeline que utiliza a ferramenta de an√°lise de seguran√ßa Trivy para escanear uma imagem Docker, a descoberta de uma vulnerabilidade com severidade `CRITICAL` resultar√° automaticamente na remo√ß√£o da imagem vulner√°vel do GitLab Container Registry para prevenir seu uso.                                                                                                                                                                                 | F                                                                                                                                                                                                                                                                                                             | **Formal:** Ferramentas de scan como o Trivy **identificam** e **relatam** vulnerabilidades. Elas podem ser configuradas para fazer um job de pipeline falhar (usando `exit-code 1`). No entanto, elas n√£o possuem a capacidade ou a permiss√£o para executar a√ß√µes destrutivas, como remover uma imagem de um registro. A a√ß√£o de remo√ß√£o seria uma l√≥gica separada e expl√≠cita que precisaria ser implementada em um script, usando a API do GitLab.<br/><br/>**Feynman/Dica üéØ:** O Trivy √© o guarda de seguran√ßa que te avisa que h√° um item perigoso na sua prateleira e pode te impedir de colocar mais coisas l√° (`falhar o pipeline`). Ele n√£o √© o time de demoli√ß√£o que entra e destr√≥i o item (`remove a imagem`). A banca atribuiu uma a√ß√£o ao scanner que ele n√£o executa.                                                                                                                                                                           |
| 48  | A utiliza√ß√£o de um "Service Mesh" como Istio ou Linkerd em um cluster Kubernetes, embora adicione complexidade, facilita a implementa√ß√£o de estrat√©gias de deploy avan√ßadas como Canary Releases, pois o Service Mesh controla o roteamento de tr√°fego entre os servi√ßos em um n√≠vel granular, permitindo o direcionamento preciso de uma porcentagem do tr√°fego para uma nova vers√£o da aplica√ß√£o.                                                                                             | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o um dos principais casos de uso para um Service Mesh. Ele abstrai a l√≥gica de roteamento, seguran√ßa e observabilidade da aplica√ß√£o, fornecendo uma camada de controle poderosa que √© ideal para implementar Canary Releases, A/B testing e outras estrat√©gias de roteamento de tr√°fego complexas, de forma declarativa.<br/><br/>**Feynman/Dica üéØ:** Pense no Service Mesh como o "controlador de tr√°fego a√©reo" ‚úàÔ∏è dentro do seu cluster. Sem ele, os avi√µes (`servi√ßos`) meio que se viram para conversar. Com ele, voc√™ pode dizer: "Controlador, mande 5% dos passageiros para o port√£o B (`nova vers√£o`) e o resto para o port√£o A (`vers√£o est√°vel`)". Ele te d√° controle fino e seguro.                                                                                                                                                                                                                    |
| 49  | O termo "GitOps" refere-se a uma pr√°tica onde o reposit√≥rio Git √© a √∫nica fonte da verdade para definir o estado desejado de uma aplica√ß√£o e sua infraestrutura. Um agente de software, como o Argo CD ou o Flux, rodando no ambiente de destino (ex: Kubernetes), compara continuamente o estado real com o estado desejado no Git e aplica as mudan√ßas necess√°rias para convergir os dois.                                                                                                    | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© a defini√ß√£o can√¥nica de GitOps. A principal diferen√ßa para um pipeline de CI/CD tradicional (push-based) √© que o GitOps usa um modelo "pull-based", onde um agente no cluster puxa as mudan√ßas, em vez de o pipeline empurr√°-las. O GitLab pode ser usado como o reposit√≥rio Git, mas o mecanismo de sincroniza√ß√£o √© diferente.<br/><br/>**Feynman/Dica üéØ:** No CI/CD normal, o GitLab √© o carteiro que entrega a encomenda (`deploy`) na sua casa (`cluster`). No GitOps, voc√™ tem um rob√¥ em casa (`agente Argo/Flux`) que fica olhando a vitrine da loja online (`reposit√≥rio Git`) o tempo todo. Assim que um produto novo aparece na vitrine, o rob√¥ mesmo vai l√° e busca. √â uma mudan√ßa de paradigma de empurrar para puxar.                                                                                                                                                                                                          |
| 50  | (Adaptada - CEBRASPE/2023) A An√°lise de Seguran√ßa de Aplica√ß√£o Est√°tica (SAST), integrada a um pipeline de CI/CD, opera analisando o c√≥digo-fonte ou o bin√°rio compilado em busca de padr√µes de vulnerabilidades conhecidas, sem executar a aplica√ß√£o. Por essa raz√£o, √© incapaz de detectar falhas de configura√ß√£o no ambiente de deploy, como uma porta de banco de dados exposta publicamente.                                                                                               | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° correta e destaca a limita√ß√£o do SAST. Por ser "est√°tico" e analisar o c√≥digo "em repouso", ele n√£o tem conhecimento do ambiente em que a aplica√ß√£o ser√° executada. Falhas de configura√ß√£o de infraestrutura ou em tempo de execu√ß√£o s√£o o dom√≠nio de outras ferramentas, como a An√°lise de Seguran√ßa de Aplica√ß√£o Din√¢mica (DAST) ou scanners de configura√ß√£o de nuvem (CSPM).<br/><br/>**Feynman/Dica üéØ:** SAST √© como revisar a planta de uma casa. Voc√™ pode encontrar problemas de estrutura (vulnerabilidades no c√≥digo), mas voc√™ n√£o consegue saber se o construtor vai esquecer uma janela aberta (`porta de banco de dados exposta`) quando a casa estiver pronta. Para isso, voc√™ precisa visitar a casa pronta (`DAST`).                                                                                                                                                                                              |
| 51  | A diretiva `artifacts:expose_as` no `.gitlab-ci.yml` permite que um artefato gerado por um job, como um relat√≥rio HTML, seja exibido diretamente na interface do Merge Request, mas requer que o artefato esteja no formato `gzip` e que o job utilize a palavra-chave `artifacts:reports` para especificar o tipo de relat√≥rio.                                                                                                                                                                | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o mistura conceitos corretamente, mas com detalhes t√©cnicos incorretos, uma t√°tica cl√°ssica da CEBRASPE. A diretiva `artifacts:expose_as` √© real e serve para expor artefatos na UI. No entanto, ela n√£o exige o formato `gzip`. Al√©m disso, a palavra-chave que a acompanha para relat√≥rios espec√≠ficos √© `artifacts:reports` (como `artifacts:reports:junit`), mas a funcionalidade de "expor como" √© independente do tipo de relat√≥rio e foca mais na acessibilidade do artefato visual.<br/><br/>**Feynman/Dica üéØ:** A banca te deu uma receita de bolo quase perfeita, mas trocou o fermento por sal. `expose_as` √© para dar um nome bonito ao seu anexo. `artifacts:reports` √© para o GitLab *entender* o conte√∫do do anexo (como um relat√≥rio de teste). E a exig√™ncia de `gzip` √© uma inven√ß√£o para confundir. Foco na fun√ß√£o de cada palavra-chave: `expose_as` √© sobre **visualiza√ß√£o**, `reports` √© sobre **interpreta√ß√£o**.  |
| 52  | Em um pipeline GitLab, para garantir que um conjunto de jobs de deploy para m√∫ltiplos microsservi√ßos s√≥ seja executado ap√≥s a conclus√£o de um √∫nico job de aprova√ß√£o manual, pode-se configurar os jobs de deploy com `needs: ["manual_approval_job"]` e `when: on_success`, enquanto o job de aprova√ß√£o √© configurado com `when: manual`.                                                                                                                                                      | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve um padr√£o de design de pipeline muito comum e correto, conhecido como "Gate". O job manual atua como um port√£o. Todos os jobs subsequentes que dependem dele (`needs`) ficam bloqueados no estado "waiting for resource" at√© que um operador clique manualmente no bot√£o "play" do job de aprova√ß√£o. Isso cria um ponto de controle deliberado antes de uma fase cr√≠tica, como um deploy em produ√ß√£o.<br/><br/>**Feynman/Dica üéØ:** Pense em uma barragem (`job manual`). A √°gua (`jobs de deploy`) est√° pronta para correr, mas fica esperando. Somente quando o operador abre as comportas (`clica no play`), a √°gua flui. A diretiva `needs` √© o que conecta o rio √† barragem. A afirma√ß√£o descreve corretamente essa engenharia de controle de fluxo.                                                                                                                                                                      |
| 53  | A funcionalidade de "Protected Environments" (Ambientes Protegidos) do GitLab (tier Premium/Ultimate) permite restringir quem pode fazer deploy para um ambiente espec√≠fico, como `production`. Al√©m disso, ela pode ser configurada para exigir aprova√ß√µes de m√∫ltiplos usu√°rios ou grupos antes que um deploy possa prosseguir, fornecendo uma camada de governan√ßa similar √†s aprova√ß√µes de Merge Request, mas para o processo de deploy.                                                    | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° perfeitamente correta. "Protected Environments" √© uma funcionalidade de governan√ßa crucial que estende o controle de acesso para o lado das Opera√ß√µes (CD). Ela permite definir pol√≠ticas como "Apenas membros do grupo 'SRE Team' podem fazer deploy em produ√ß√£o" ou "Um deploy para produ√ß√£o requer a aprova√ß√£o de um membro do 'QA Leadership' E um do 'Security Team'".<br/><br/>**Feynman/Dica üéØ:** Se "Protected Branches" protege quem pode *escrever* o c√≥digo, "Protected Environments" protege quem pode *lan√ßar* o c√≥digo. √â a mesma l√≥gica de seguran√ßa, mas aplicada a uma etapa diferente e mais cr√≠tica do ciclo de vida. A afirma√ß√£o descreve essa simetria de forma precisa.                                                                                                                                                                                                                                     |
| 54  | Ao utilizar o executor `docker+machine` para auto-scaling de runners, o GitLab Runner provisiona novas m√°quinas virtuais sob demanda. Por padr√£o, essas m√°quinas s√£o persistentes e reutilizadas para m√∫ltiplos jobs para otimizar o cache de camadas do Docker, sendo desligadas apenas ap√≥s um longo per√≠odo de inatividade.                                                                                                                                                                  | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o cont√©m uma imprecis√£o fundamental sobre o ciclo de vida das m√°quinas provisionadas. A principal vantagem do `docker+machine` para CI/CD √© que as m√°quinas virtuais s√£o, por padr√£o, **descart√°veis e de uso √∫nico (single-use)**. Uma nova VM √© criada para cada job e destru√≠da logo ap√≥s sua conclus√£o. Isso garante o m√°ximo de isolamento e um ambiente limpo, prevenindo o "envenenamento" de cache entre jobs. A persist√™ncia √© uma configura√ß√£o opcional, n√£o o padr√£o.<br/><br/>**Feynman/Dica üéØ:** A banca descreve um hotel (`reutiliza√ß√£o de VMs`) quando na verdade o `docker+machine` opera como um hospital que usa agulhas descart√°veis (`VMs de uso √∫nico`) para cada paciente (`job`). A seguran√ßa e a limpeza do isolamento s√£o mais importantes que a pequena otimiza√ß√£o de reutilizar a agulha.                                                                                                                    |
| 55  | O GitLab Package Registry permite que uma organiza√ß√£o hospede seus pr√≥prios pacotes privados de diferentes tecnologias, como Maven (Java), npm (Node.js) e PyPI (Python), no mesmo projeto. Um job de CI/CD pode, ent√£o, ser configurado para publicar o artefato de um projeto (ex: um arquivo `.jar`) nesse registro, e outros projetos podem consumi-lo como uma depend√™ncia, autenticando-se usando o `$CI_JOB_TOKEN`.                                                                      | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com exatid√£o a funcionalidade e o fluxo de trabalho do GitLab Package Registry. Ele atua como um reposit√≥rio privado de artefatos (como Artifactory ou Nexus), integrado ao ecossistema GitLab, permitindo um gerenciamento de depend√™ncias internas seguro e simplificado, onde a autentica√ß√£o √© gerenciada nativamente pelo CI/CD.<br/><br/>**Feynman/Dica üéØ:** O GitLab te d√° uma "prateleira" (`Package Registry`) s√≥ sua para guardar seus "potes de ingredientes" especiais (`pacotes Maven/npm`). Quando outro projeto seu precisa de um desses potes, ele n√£o precisa ir ao supermercado p√∫blico (`Maven Central`), ele pega diretamente da sua prateleira usando o crach√° de funcion√°rio (`$CI_JOB_TOKEN`).                                                                                                                                                                                                          |
| 56  | A diretiva `retry` em um job do `.gitlab-ci.yml` permite que um job seja re-executado automaticamente em caso de falha. Se `retry: 2` for definido, o job ser√° executado um total de duas vezes: a execu√ß√£o original e uma nova tentativa.                                                                                                                                                                                                                                                      | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° na contagem. `retry: 2` significa que o job ser√° re-executado **at√© duas vezes** *ap√≥s* a falha inicial. Portanto, ele pode ser executado um total de **tr√™s** vezes: a execu√ß√£o original + duas novas tentativas. √â um erro de interpreta√ß√£o comum que a banca adora explorar.<br/><br/>**Feynman/Dica üéØ:** Lembre-se: `retry` √© o n√∫mero de "vidas extras" que voc√™ d√° ao seu job, como em um videogame. Se voc√™ tem 2 retries, voc√™ tem a sua vida original + 2 vidas extras. Total de 3 chances. A banca quer que voc√™ esque√ßa de contar a primeira tentativa.                                                                                                                                                                                                                                                                                                                                                                |
| 57  | (Adaptada - AOCP/2023) A An√°lise de Seguran√ßa de Aplica√ß√£o Din√¢mica (DAST) √© uma t√©cnica de teste de seguran√ßa "black-box" que examina uma aplica√ß√£o em execu√ß√£o a partir do exterior. Em um pipeline GitLab, um scanner DAST normalmente ataca a URL de uma Review App ou de um ambiente de Staging para encontrar vulnerabilidades como Cross-Site Scripting (XSS) ou SQL Injection, sem ter acesso ao c√≥digo-fonte.                                                                          | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve perfeitamente o que √© DAST, como ele funciona (black-box) e como ele se encaixa em um pipeline de CI/CD moderno. Ele complementa o SAST ao testar a aplica√ß√£o em seu estado operacional, encontrando vulnerabilidades que s√≥ se manifestam em tempo de execu√ß√£o.<br/><br/>**Feynman/Dica üéØ:** DAST √© o "ladr√£o do bem" que voc√™ contrata para tentar invadir sua casa j√° constru√≠da. Ele n√£o olha a planta (`c√≥digo-fonte`), ele apenas testa as portas, janelas e paredes (`endpoints da aplica√ß√£o`) para ver se encontra uma brecha. √â o teste do mundo real.                                                                                                                                                                                                                                                                                                                                                               |
| 58  | A utiliza√ß√£o de um "monorepo" com muitos servi√ßos exige uma estrat√©gia de versionamento e tagging cuidadosa. Para automatizar o versionamento sem√¢ntico, um pipeline pode ser configurado para analisar as mensagens de commit desde a √∫ltima tag, e se encontrar commits com o prefixo `feat:`, ele incrementa a vers√£o menor (minor), enquanto um prefixo `fix:` incrementa a vers√£o de patch, de acordo com a especifica√ß√£o Conventional Commits.                                            | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma descri√ß√£o precisa de um fluxo de trabalho de automa√ß√£o de release avan√ßado e muito eficaz. O uso do padr√£o Conventional Commits transforma as mensagens de commit em dados estruturados que podem ser lidos por ferramentas de automa√ß√£o para determinar o versionamento sem√¢ntico e gerar changelogs automaticamente, o que √© especialmente √∫til em monorepos.<br/><br/>**Feynman/Dica üéØ:** Voc√™ ensina sua equipe a falar uma "l√≠ngua secreta" nos commits (`feat`, `fix`, `docs`). Depois, voc√™ programa um rob√¥ (`pipeline`) que entende essa l√≠ngua e sabe exatamente como numerar a pr√≥xima vers√£o do seu produto e escrever o relat√≥rio de mudan√ßas, sem que nenhum humano precise fazer isso manualmente.                                                                                                                                                                                                                       |
| 59  | A diretiva `inherit` no `.gitlab-ci.yml` permite controlar quais configura√ß√µes globais definidas no bloco `default` um job espec√≠fico ir√° herdar. Se um job for definido com `inherit: { default: false }`, ele n√£o herdar√° nenhuma configura√ß√£o do bloco `default`, como `image` ou `before_script`, operando em um estado completamente isolado.                                                                                                                                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente o prop√≥sito da diretiva `inherit`. Ela oferece um controle granular sobre a heran√ßa de configura√ß√µes, o que √© √∫til para jobs muito espec√≠ficos que precisam de um ambiente completamente diferente do padr√£o definido para o resto do pipeline (por exemplo, um job que roda em um runner `shell` do Windows enquanto todos os outros rodam em `docker` do Linux).<br/><br/>**Feynman/Dica üéØ:** `default` √© a "heran√ßa de fam√≠lia" que todos os filhos (`jobs`) recebem. A diretiva `inherit: { default: false }` √© o filho que diz: "Eu recuso a heran√ßa, vou come√ßar do zero". √â a cl√°usula de exce√ß√£o que confirma a regra da heran√ßa.                                                                                                                                                                                                                                                                        |
| 60  | No GitLab, √© poss√≠vel agendar a execu√ß√£o de pipelines em intervalos regulares (ex: toda noite) usando a funcionalidade de "Scheduled Pipelines". No entanto, esses pipelines agendados sempre rodam no √∫ltimo commit do branch padr√£o do projeto (`main`), n√£o sendo poss√≠vel configurar um agendamento para rodar em um branch de feature espec√≠fico.                                                                                                                                          | F                                                                                                                                                                                                                                                                                                             | **Formal:** A funcionalidade de "Scheduled Pipelines" √© mais flex√≠vel do que a afirmado. Ao criar um agendamento na interface do GitLab, voc√™ pode especificar **qualquer branch ou tag** para o qual o pipeline deve ser executado. √â comum ter agendamentos noturnos que rodam testes mais longos e pesados contra o branch de desenvolvimento (`develop`) ou outros branches de longa dura√ß√£o.<br/><br/>**Feynman/Dica üéØ:** A banca tentou colocar um cabresto em um cavalo que corre livre. O agendador do GitLab n√£o √© limitado ao branch principal. Voc√™ pode apont√°-lo para onde quiser. √â uma pegadinha que testa o conhecimento pr√°tico da configura√ß√£o na UI, n√£o apenas a sintaxe do YAML.                                                                                                                                                                                                                                                          |
| 61  | A Lei de Direitos Autorais (Lei n¬∫ 9.610/98), em seu Art. 7¬∫, protege as obras intelectuais, incluindo os programas de computador. A funcionalidade de "License Compliance" do GitLab (tier Ultimate) auxilia na conformidade ao escanear as depend√™ncias do projeto, identificar suas licen√ßas de software (ex: MIT, GPL, Apache) e compar√°-las com uma pol√≠tica definida, permitindo proibir o uso de depend√™ncias com licen√ßas restritivas que poderiam criar obriga√ß√µes legais indesejadas. | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o faz uma conex√£o precisa entre um requisito legal complexo (gest√£o de licen√ßas de software) e uma capacidade t√©cnica avan√ßada do GitLab. A gest√£o de licen√ßas de depend√™ncias √© um aspecto cr√≠tico de governan√ßa de software para evitar contamina√ß√£o de licen√ßas virais (como a GPL) em c√≥digo propriet√°rio.<br/><br/>**Feynman/Dica üéØ:** Imagine que cada depend√™ncia que voc√™ usa √© um "ingrediente" com um selo de origem. O GitLab "l√™" todos os selos e verifica se algum deles vem de uma "fazenda" (`licen√ßa GPL`) que te obriga a doar toda a sua receita (`tornar seu c√≥digo aberto`). √â uma prote√ß√£o legal automatizada. A conex√£o com a lei √© o diferencial aqui.                                                                                                                                                                                                                                                           |
| 62  | A diretiva `services` em um job do `.gitlab-ci.yml` √© usada para iniciar cont√™ineres auxiliares. Esses cont√™ineres s√£o iniciados e seu `entrypoint` √© executado antes do `before_script` do job principal, e eles s√£o automaticamente interrompidos ap√≥s a conclus√£o do `after_script` do job.                                                                                                                                                                                                  | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente o ciclo de vida dos cont√™ineres de servi√ßo em rela√ß√£o ao job principal. Eles s√£o provisionados antes que qualquer script do job comece e desprovisionados depois que tudo termina, fornecendo um ambiente de depend√™ncia limpo e isolado para a dura√ß√£o exata do job.<br/><br/>**Feynman/Dica üéØ:** Os `services` s√£o os "atores coadjuvantes" contratados para uma cena espec√≠fica (`job`). Eles chegam ao est√∫dio antes do ator principal (`script`), atuam junto com ele e v√£o embora assim que a cena acaba. Seu ciclo de vida √© perfeitamente sincronizado com o do job.                                                                                                                                                                                                                                                                                                                                     |
| 63  | Um "canary release" √© uma estrat√©gia de deploy onde a nova vers√£o da aplica√ß√£o √© implantada ao lado da vers√£o antiga, e o GitLab CI/CD, por meio de seus Runners, distribui uma pequena porcentagem do tr√°fego de produ√ß√£o para a nova vers√£o, monitorando os resultados antes de aumentar gradualmente o tr√°fego.                                                                                                                                                                              | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha √© sutil, mas crucial, e repete um padr√£o: atribuir intelig√™ncia ao Runner que ele n√£o possui. O GitLab CI/CD **orquestra** o deploy, mas o **roteamento de tr√°fego** em si √© uma fun√ß√£o da infraestrutura subjacente (um Service Mesh como Istio, um Balanceador de Carga de Aplica√ß√£o da AWS, etc.). O Runner executa o script que comanda a infraestrutura, mas ele mesmo n√£o divide ou distribui tr√°fego.<br/><br/>**Feynman/Dica üéØ:** O Runner √© o piloto do avi√£o, ele segue o plano de voo (`script`). O "controlador de tr√°fego a√©reo" (`Service Mesh`) √© quem decide para qual pista o avi√£o vai. A afirma√ß√£o disse que o piloto tamb√©m √© o controlador de tr√°fego. S√£o fun√ß√µes separadas.                                                                                                                                                                                                                                     |
| 64  | A funcionalidade "Merge Trains" (GitLab Premium/Ultimate) resolve o problema de um "main quebrado" em projetos com alta frequ√™ncia de merges. Ela cria uma fila de Merge Requests aprovados e os testa sequencialmente, como se j√° tivessem sido mesclados, garantindo que a combina√ß√£o de m√∫ltiplos MRs n√£o quebre o branch de destino.                                                                                                                                                        | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o o problema do "main quebrado por acumula√ß√£o" e como os Merge Trains o resolvem. Em vez de testar cada MR isoladamente, ele testa a fila de MRs de forma acumulada (`main` + MR1, depois `main` + MR1 + MR2, etc.), garantindo que o branch principal permane√ßa sempre "verde".<br/><br/>**Feynman/Dica üéØ:** Pense em vag√µes de trem sendo adicionados √† composi√ß√£o. Em vez de testar cada vag√£o separadamente, o Merge Train engata um novo vag√£o (`MR`) na composi√ß√£o existente e testa o trem inteiro para ver se ele n√£o descarrila. Se o teste passar, o vag√£o √© permanentemente acoplado. √â um teste de integra√ß√£o em s√©rie antes do merge real.                                                                                                                                                                                                                                                            |
| 65  | Ao construir uma imagem Docker em um pipeline, para passar segredos como um token de banco de dados para o processo de build (ex: para baixar um artefato de um reposit√≥rio privado), a pr√°tica recomendada √© usar a instru√ß√£o `ARG` no Dockerfile e passar a vari√°vel de CI/CD para ela atrav√©s da flag `--build-arg`. Isso garante que o segredo n√£o seja persistido nas camadas da imagem final.                                                                                             | F                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma pegadinha de seguran√ßa perigosa. Usar `ARG` e `--build-arg` para segredos √© uma **m√° pr√°tica**, porque, embora o `ARG` n√£o persista na imagem final se n√£o for usado por um `ENV`, ele ainda pode ser inspecionado no hist√≥rico do build (`docker history`). A forma segura e moderna de lidar com segredos durante o build √© usar os **BuildKit secrets mounts** (`--mount=type=secret,...`), que montam o segredo como um arquivo tempor√°rio no cont√™iner de build, sem nunca ser escrito em nenhuma camada.<br/><br/>**Feynman/Dica üéØ:** Usar `ARG` para um segredo √© como escrever a senha em um post-it e col√°-lo no computador enquanto voc√™ trabalha. Depois voc√™ joga o post-it fora, mas algu√©m pode encontr√°-lo no lixo (`docker history`). Usar `secrets mounts` √© como sussurrar a senha no seu ouvido; ela nunca √© escrita em lugar nenhum. A banca te ofereceu uma solu√ß√£o que "parece" segura, mas n√£o √©.                |
| 66  | (CEBRASPE - 2023, TJ-ES) O termo DevOps refere-se a uma cultura que visa unificar o desenvolvimento de software (Dev) e a opera√ß√£o de software (Ops), enfatizando a colabora√ß√£o, automa√ß√£o e comunica√ß√£o entre desenvolvedores e outros profissionais de TI.                                                                                                                                                                                                                                    | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma quest√£o conceitual cl√°ssica e uma defini√ß√£o padr√£o e correta da cultura DevOps, que √© o fundamento filos√≥fico para a exist√™ncia de ferramentas como o GitLab.<br/><br/>**Feynman/Dica üéØ:** DevOps √© sobre fazer com que os "construtores" (`Dev`) e os "zeladores" (`Ops`) do pr√©dio conversem e trabalhem juntos desde o in√≠cio, em vez de um culpar o outro quando algo quebra. √â uma quest√£o de trabalho em equipe, facilitado por ferramentas.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 67  | O GitLab permite a cria√ß√£o de "Webhooks", que s√£o callbacks HTTP acionados por eventos espec√≠ficos no reposit√≥rio (ex: push, merge request). Um caso de uso comum √© a integra√ß√£o com sistemas de terceiros, como o Jira, onde um push com uma chave de issue na mensagem de commit pode acionar um webhook que atualiza o status da issue correspondente no Jira.                                                                                                                               | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o o que s√£o webhooks e um de seus casos de uso mais populares: a integra√ß√£o de sistemas. Eles s√£o o "cimento" que permite que o GitLab se comunique de forma proativa com outras ferramentas no ecossistema de TI.<br/><br/>**Feynman/Dica üéØ:** Um Webhook √© o "sistema de alerta" do GitLab. Quando algo acontece (um `push`), ele "telefona" para o n√∫mero que voc√™ cadastrou (`URL do Jira`) e avisa: "Ei, aconteceu isso aqui!". A partir da√≠, o outro sistema decide o que fazer com a informa√ß√£o.                                                                                                                                                                                                                                                                                                                                                                                                            |
| 68  | A diretiva `timeout` pode ser definida no n√≠vel do projeto, do runner e do job. A preced√™ncia √© a seguinte: o timeout definido no job sobrescreve o do runner, que por sua vez sobrescreve o do projeto. Portanto, o valor de timeout mais espec√≠fico sempre prevalece.                                                                                                                                                                                                                         | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente a hierarquia e a regra de preced√™ncia para a configura√ß√£o de timeouts no GitLab, demonstrando um conhecimento detalhado da configura√ß√£o da plataforma. O comportamento √© "o mais espec√≠fico vence".<br/><br/>**Feynman/Dica üéØ:** √â como as regras de CSS (Cascading Style Sheets) na web. Uma regra de estilo definida diretamente em um elemento (`job`) √© mais forte do que uma regra definida em um arquivo geral (`projeto`). A especificidade vence.                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 69  | A utiliza√ß√£o de `tags` Git √© o mecanismo padr√£o para acionar um deploy em produ√ß√£o. Para refor√ßar a seguran√ßa, o GitLab permite a cria√ß√£o de "Protected Tags", que funcionam de forma similar aos "Protected Branches", permitindo restringir quem pode criar tags (ex: apenas `Maintainers`) e prevenindo sua altera√ß√£o ou exclus√£o.                                                                                                                                                           | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° inteiramente correta. "Protected Tags" √© uma funcionalidade de governan√ßa essencial para garantir que o processo de release seja controlado e que apenas usu√°rios autorizados possam criar os pontos de versionamento que normalmente disparam os deploys mais cr√≠ticos.<br/><br/>**Feynman/Dica üéØ:** Se uma tag `v1.0.0` √© a "chave que lan√ßa o foguete" para produ√ß√£o, voc√™ n√£o quer que qualquer um possa criar essa chave. `Protected Tags` garante que s√≥ o "comandante da miss√£o" (`Maintainer`) possa girar a chave.                                                                                                                                                                                                                                                                                                                                                                                                       |
| 70  | O arquivo `.gitlab/issue_templates/bug.md` permite pr√©-definir um template para a cria√ß√£o de issues do tipo "bug". Quando um usu√°rio seleciona este template, o corpo da descri√ß√£o da issue √© pr√©-populado com o conte√∫do do arquivo markdown, mas o t√≠tulo da issue e suas labels devem ser preenchidos manualmente pelo usu√°rio, pois n√£o podem ser definidos no template.                                                                                                                    | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° na limita√ß√£o imposta. Embora o conte√∫do do template markdown preencha a descri√ß√£o, √© poss√≠vel, sim, adicionar metadados como `labels` e at√© mesmo um `title` (ou parte dele) diretamente no template usando um front matter YAML na parte superior do arquivo markdown, ou atrav√©s de par√¢metros na URL de cria√ß√£o da issue. A afirma√ß√£o cria uma falsa limita√ß√£o.<br/><br/>**Feynman/Dica üéØ:** A banca te diz que o formul√°rio pr√©-preenchido s√≥ pode ter o campo principal (`descri√ß√£o`) e que os outros campos (`labels`, `t√≠tulo`) voc√™ tem que preencher na m√£o. Na verdade, o sistema do GitLab √© mais inteligente e permite pr√©-preencher v√°rios campos, economizando ainda mais tempo.                                                                                                                                                                                                                                    |
| 71  | Em um pipeline GitLab, o uso da palavra-chave `dependencies` em um job permite que ele baixe artefatos de jobs anteriores. Se `dependencies: []` for especificado, o job n√£o baixar√° artefatos de nenhum job anterior, mesmo que o pipeline como um todo tenha artefatos de est√°gios pr√©vios. Esta t√©cnica √© usada para acelerar jobs que n√£o necessitam de dados de etapas anteriores.                                                                                                         | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o o comportamento e o caso de uso da diretiva `dependencies` com um array vazio (`[]`). Por padr√£o, jobs em est√°gios posteriores baixam os artefatos de todos os jobs de est√°gios anteriores. Especificar `dependencies: []` desabilita explicitamente esse comportamento, sendo uma otimiza√ß√£o importante para jobs que s√£o independentes (como um job de `lint`, que s√≥ precisa do c√≥digo-fonte).<br/><br/>**Feynman/Dica üéØ:** Pense nos artefatos como uma "mochila" que vai passando de est√°gio em est√°gio, ficando mais pesada. O job que diz `dependencies: []` √© aquele que fala: "N√£o preciso de nada da mochila, pode deixar ela a√≠. Eu me viro sozinho." Isso o torna mais leve e r√°pido.                                                                                                                                                                                                                |
| 72  | A funcionalidade de "CI/CD for External Repos" do GitLab permite configurar um pipeline para um reposit√≥rio hospedado em outra plataforma, como GitHub ou Bitbucket. Neste modo, o GitLab atua exclusivamente como o motor de CI/CD, enquanto o SCM (Source Code Management), os Merge Requests e a revis√£o de c√≥digo continuam a ocorrer na plataforma externa.                                                                                                                                | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente o caso de uso para "CI/CD for external repos". O GitLab pode ser usado puramente como uma poderosa ferramenta de automa√ß√£o, conectando-se a reposit√≥rios externos via espelhamento (mirroring). Isso permite que organiza√ß√µes que n√£o podem ou n√£o querem migrar seu SCM ainda se beneficiem da maturidade do GitLab CI/CD.<br/><br/>**Feynman/Dica üéØ:** O GitLab se oferece para ser o "chef de cozinha" (`CI/CD`) para um restaurante que j√° tem sua pr√≥pria despensa e sal√£o (`GitHub`). O GitLab n√£o toma conta do restaurante inteiro, ele apenas entra na cozinha, prepara os pratos conforme pedido e vai embora. √â uma forma de "terceirizar" a automa√ß√£o.                                                                                                                                                                                                                                               |
| 73  | A palavra-chave `trigger` √© usada para iniciar um pipeline downstream. Se o pipeline downstream falhar, por padr√£o, o job `trigger` no pipeline upstream tamb√©m falhar√°, criando uma depend√™ncia de sucesso. Para desvincular os resultados, pode-se usar a diretiva `strategy: depend`, que faz com que o job upstream espere pelo downstream, mas seja bem-sucedido independentemente do resultado do √∫ltimo.                                                                                 | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o inverte o significado da diretiva `strategy`. Por padr√£o (`strategy: depend`), o job de trigger **espelha o status** do pipeline downstream (se o filho falha, o pai falha). Para desvincular os resultados e fazer com que o job de trigger seja bem-sucedido assim que o pipeline downstream √© iniciado (sem esperar por ele), a diretiva correta √© **`strategy: trigger`**. A banca trocou os significados.<br/><br/>**Feynman/Dica üéØ:** `strategy: depend` significa "Eu dependo de voc√™. Se voc√™ cair, eu caio junto." `strategy: trigger` significa "Eu s√≥ vou apertar o gatilho. O que acontece com a bala depois n√£o √© problema meu." A afirma√ß√£o descreveu o primeiro comportamento e deu o nome do segundo. Pegadinha de terminologia.                                                                                                                                                                                       |
| 74  | Ao configurar um GitLab Runner, √© poss√≠vel definir limites de concorr√™ncia (`concurrency`) e de jobs por runner (`limit`). A configura√ß√£o `concurrency = 10` em um runner significa que este runner pode executar at√© 10 jobs simultaneamente. Esta configura√ß√£o √© particularmente relevante para executores como `docker` ou `kubernetes`, que podem gerenciar m√∫ltiplos ambientes de execu√ß√£o paralelos.                                                                                      | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente o prop√≥sito da configura√ß√£o `concurrency` no arquivo `config.toml` do GitLab Runner. Ela define o n√∫mero m√°ximo de jobs que um √∫nico processo do runner pode gerenciar ao mesmo tempo. Isso √© fundamental para controlar o uso de recursos e o paralelismo em runners que n√£o s√£o limitados por um √∫nico shell.<br/><br/>**Feynman/Dica üéØ:** `concurrency` √© o n√∫mero de "bra√ßos" que o seu rob√¥-runner tem. Se `concurrency = 10`, ele consegue fazer 10 tarefas ao mesmo tempo. Se voc√™ s√≥ der um bra√ßo (`concurrency = 1`), ele ter√° que fazer uma tarefa de cada vez, mesmo que tenha capacidade para mais. √â o controle de "multitarefa" do runner.                                                                                                                                                                                                                                                         |
| 75  | A An√°lise de Cobertura de Testes (Test Coverage Parsing) do GitLab √© uma funcionalidade que extrai o percentual de cobertura de testes da sa√≠da de log de um job. O resultado √© ent√£o usado para gerar um gr√°fico de tend√™ncia hist√≥rico, mas o pipeline prosseguir√° com sucesso independentemente do valor da cobertura, pois o GitLab n√£o possui um mecanismo para fazer um pipeline falhar com base em um limiar m√≠nimo de cobertura.                                                        | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° quase toda correta, mas a parte final √© falsa e constitui a pegadinha. O GitLab, de fato, **possui** um mecanismo para for√ßar a falha com base na cobertura. Nas configura√ß√µes de Merge Request de um projeto, voc√™ pode definir um "Coverage check", que far√° com que o MR seja bloqueado e o pipeline seja considerado falho se a cobertura de testes de uma nova mudan√ßa diminuir ou n√£o atingir um m√≠nimo.<br/><br/>**Feynman/Dica üéØ:** A banca te diz que o GitLab √© bom em "mostrar a nota" da sua prova (`cobertura de testes`), mas que ele n√£o pode te "reprovar" se a nota for muito baixa. Isso √© falso. O GitLab pode, sim, atuar como um professor rigoroso e te reprovar (`falhar o pipeline`) se voc√™ n√£o atingir a nota m√≠nima.                                                                                                                                                                                   |
| 76  | (Adaptada - CESPE/2022) O formato YAML (YAML Ain't Markup Language), utilizado para escrever arquivos `.gitlab-ci.yml`, √© um formato de serializa√ß√£o de dados leg√≠vel por humanos que se baseia em indenta√ß√£o com espa√ßos para definir sua estrutura. A utiliza√ß√£o de caracteres de tabula√ß√£o (`tab`) em vez de espa√ßos √© permitida e tratada como equivalente a 2 espa√ßos pela maioria dos parsers YAML, incluindo o do GitLab.                                                                | F                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma pegadinha t√©cnica fatal para quem escreve YAML. A especifica√ß√£o do YAML **pro√≠be estritamente** o uso de caracteres de tabula√ß√£o para indenta√ß√£o. A estrutura deve ser definida exclusivamente com espa√ßos. Um arquivo `.gitlab-ci.yml` que contenha tabs resultar√° em um erro de sintaxe (lint error) e n√£o ser√° executado pelo GitLab.<br/><br/>**Feynman/Dica üéØ:** Em YAML, "espa√ßos" s√£o os cidad√£os de primeira classe, e "tabs" s√£o ilegais e procurados pela pol√≠cia. Usar um tab √© um erro que quebra o sistema. A banca tenta te convencer de que a pol√≠cia √© boazinha e vai aceitar o tab como se fosse um espa√ßo. N√£o vai. **YAML = Espa√ßos; Tabs = Proibido**.                                                                                                                                                                                                                                                              |
| 77  | O conceito de "ChatOps" pode ser implementado com o GitLab integrando-o a plataformas de comunica√ß√£o como Slack ou Microsoft Teams. Atrav√©s de comandos de barra (`/gitlab`), um usu√°rio pode executar a√ß√µes de CI/CD, como fazer deploy de um branch para produ√ß√£o, diretamente da interface de chat, com o GitLab tratando da autentica√ß√£o e execu√ß√£o do job correspondente.                                                                                                                  | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve um caso de uso real e poderoso do ChatOps com o GitLab. Ao trazer as opera√ß√µes para dentro das ferramentas de conversa√ß√£o onde as equipes j√° est√£o colaborando, o GitLab reduz o atrito e a necessidade de mudan√ßa de contexto, permitindo a√ß√µes r√°pidas e audit√°veis diretamente do chat.<br/><br/>**Feynman/Dica üéØ:** ChatOps transforma seu Slack em um "controle remoto" para o GitLab. Em vez de ir at√© a "sala de m√°quinas" (`interface do GitLab`) para apertar o bot√£o de deploy, voc√™ pode apert√°-lo diretamente do seu "sof√°" (`canal do Slack`), e tudo fica registrado.                                                                                                                                                                                                                                                                                                                                           |
| 78  | A diretiva `cache:policy` no `.gitlab-ci.yml` pode ser definida como `pull-push` (o padr√£o), `pull` ou `push`. Se um job for configurado com `policy: push`, ele ir√° compactar e enviar os arquivos definidos em `cache:paths` para o armazenamento de cache no final de sua execu√ß√£o, mas n√£o ir√° baixar nenhum conte√∫do de cache no in√≠cio. Esta configura√ß√£o √© √∫til para jobs que apenas produzem cache para outros consumirem.                                                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o o comportamento da pol√≠tica de cache `push`. Ela serve para desacoplar a produ√ß√£o do consumo de cache. Um job pode ser dedicado a criar um cache "quente" (ex: baixar todas as depend√™ncias), e outros jobs subsequentes podem usar a pol√≠tica `pull` para apenas consumir esse cache, sem tentar atualiz√°-lo.<br/><br/>**Feynman/Dica üéØ:** Pense na pol√≠tica de cache como as regras de uma cozinha comunit√°ria. `pull-push` √© "pegue o que precisar e deixe o que sobrou". `pull` √© "s√≥ pegue, n√£o deixe nada". `push` √© "s√≥ deixe, n√£o pegue nada". A afirma√ß√£o descreve corretamente o comportamento do cozinheiro que s√≥ prepara a comida para os outros.                                                                                                                                                                                                                                                   |
| 79  | O GitLab possui um Terraform Provider oficial que permite gerenciar recursos do pr√≥prio GitLab (como projetos, usu√°rios, grupos e permiss√µes) como c√≥digo, seguindo os princ√≠pios de IaC (Infrastructure as Code). No entanto, este provider n√£o pode ser usado para gerenciar configura√ß√µes de CI/CD, como a cria√ß√£o de Runners ou a defini√ß√£o de CI/CD Variables.                                                                                                                             | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° na limita√ß√£o imposta. O Terraform Provider do GitLab √© bastante completo e permite, sim, gerenciar recursos de CI/CD. Voc√™ pode declarar Runners de projeto/grupo, CI/CD Variables, proteger branches e configurar muitas outras facetas do GitLab de forma declarativa, o que √© extremamente poderoso para padronizar a configura√ß√£o de novos projetos.<br/><br/>**Feynman/Dica üéØ:** A banca te diz que sua chave de fenda el√©trica (`Terraform Provider`) serve para montar todos os m√≥veis da casa (`projetos, usu√°rios`), mas n√£o serve para apertar os parafusos da TV (`CI/CD Variables`). Isso √© falso. A ferramenta √© mais vers√°til do que a afirmado, e a capacidade de gerenciar o CI/CD como c√≥digo √© um de seus grandes trunfos.                                                                                                                                                                                      |
| 80  | A utiliza√ß√£o de um "Security Gateway" no pipeline de CI/CD, implementado como um job manual que requer aprova√ß√£o de um time de seguran√ßa antes do deploy em produ√ß√£o, √© uma pr√°tica que, embora adicione um passo humano, ajuda a alinhar os princ√≠pios do DevSecOps com requisitos de conformidade que exigem uma revis√£o de seguran√ßa final antes de um release.                                                                                                                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve um padr√£o de governan√ßa pragm√°tico e comum em ambientes regulados. Embora a automa√ß√£o total seja o ideal do DevOps, a realidade de muitas organiza√ß√µes exige port√µes de qualidade (gates) formais. Um job manual de aprova√ß√£o de seguran√ßa √© um excelente meio-termo, pois mant√©m o processo dentro do pipeline rastre√°vel, mas insere o ponto de verifica√ß√£o humano exigido pela pol√≠tica.<br/><br/>**Feynman/Dica üéØ:** Mesmo na f√°brica mais automatizada do mundo, √†s vezes h√° um inspetor de qualidade humano que d√° o selo final no produto antes de ele ir para a loja. O "Security Gateway" √© esse inspetor no seu pipeline. Ele n√£o contradiz a automa√ß√£o, ele a complementa com governan√ßa.                                                                                                                                                                                                                          |
| 81  | (Adaptada - FUNDATEC/2021) O DAST (Dynamic Application Security Testing) e o SAST (Static Application Security Testing) s√£o abordagens concorrentes para a seguran√ßa de aplica√ß√µes, sendo recomendado que a organiza√ß√£o escolha e implemente apenas uma delas em seu pipeline de DevSecOps para evitar a redund√¢ncia de alertas e a complexidade de gerenciamento.                                                                                                                              | F                                                                                                                                                                                                                                                                                                             | **Formal:** SAST e DAST s√£o abordagens **complementares**, n√£o concorrentes. Elas encontram tipos diferentes de vulnerabilidades. SAST (white-box) analisa o c√≥digo-fonte em busca de falhas de programa√ß√£o, enquanto DAST (black-box) testa a aplica√ß√£o em execu√ß√£o em busca de falhas de configura√ß√£o e de tempo de execu√ß√£o. A melhor pr√°tica de DevSecOps √© usar **ambas** em camadas para uma cobertura de seguran√ßa mais profunda.<br/><br/>**Feynman/Dica üéØ:** A banca sugere que voc√™ s√≥ precisa de um m√©dico: ou um cl√≠nico geral que l√™ seus exames de sangue (`SAST`) ou um especialista que te observa andando e respirando (`DAST`). Na verdade, para um check-up completo, voc√™ precisa dos dois. Eles olham para coisas diferentes e juntos te d√£o um quadro de sa√∫de muito mais completo.                                                                                                                                                      |
| 82  | A funcionalidade de "DAG (Directed Acyclic Graph) Pipelines", habilitada pela diretiva `needs`, permite que a execu√ß√£o dos jobs quebre a ordem sequencial dos est√°gios. No entanto, se um job utiliza `needs`, ele n√£o pode mais usar a diretiva `dependencies`, pois o mecanismo de depend√™ncia expl√≠cito do `needs` substitui o mecanismo de download de artefatos.                                                                                                                           | F                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma pegadinha t√©cnica sutil. Um job que usa `needs` **pode e frequentemente usa** `dependencies` tamb√©m. Por padr√£o, `needs` baixa os artefatos dos jobs listados. A diretiva `dependencies` pode ser usada para refinar esse comportamento, por exemplo, se voc√™ precisa depender de um job (`needs`) para fins de ordena√ß√£o, mas n√£o precisa dos seus artefatos (`dependencies: []`), ou se voc√™ precisa dos artefatos de um job que n√£o est√° na sua lista de `needs`.<br/><br/>**Feynman/Dica üéØ:** `needs` define a "ordem na fila". `dependencies` define "o que voc√™ pega" dos outros que j√° foram atendidos. S√£o controles relacionados, mas ortogonais. Voc√™ pode estar atr√°s de algu√©m na fila (`needs`) e ainda assim decidir n√£o pegar o panfleto (`artefato`) que ele est√° distribuindo (`dependencies: []`).                                                                                                                    |
| 83  | O GitLab armazena o cache de CI/CD em um armazenamento de objetos (como AWS S3 ou Google Cloud Storage). Para otimizar a performance, se um Runner executa um job que precisa de um cache que j√° foi baixado por um job anterior no mesmo Runner, ele reutilizar√° os arquivos do disco local do Runner em vez de baixar o arquivo de cache do armazenamento de objetos novamente.                                                                                                               | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente o comportamento de otimiza√ß√£o de cache do GitLab Runner. Ele mant√©m uma c√≥pia local dos caches que baixa. Antes de iniciar um download do armazenamento de objetos remoto, ele verifica se o cache com a mesma chave (`key`) j√° existe localmente, evitando transfer√™ncias de rede desnecess√°rias e acelerando significativamente o in√≠cio dos jobs.<br/><br/>**Feynman/Dica üéØ:** O Runner √© esperto. Antes de ir ao "supermercado central" (`S3`) para buscar um ingrediente, ele primeiro olha na sua "geladeira local" (`disco do runner`). Se o ingrediente com a mesma data de validade (`cache key`) j√° estiver l√°, ele o usa, economizando tempo e a viagem.                                                                                                                                                                                                                                              |
| 84  | No contexto do `docker-compose.yml`, a diretiva `depends_on` estabelece uma ordem de inicializa√ß√£o entre os servi√ßos. No entanto, ela apenas garante que o cont√™iner do banco de dados `db` seja iniciado antes do cont√™iner da `api`. Ela n√£o garante que o servi√ßo de banco de dados dentro do cont√™iner `db` esteja pronto para aceitar conex√µes. Para isso, o mecanismo de `healthcheck` deve ser usado em conjunto com uma l√≥gica de retry na aplica√ß√£o.                                   | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma das fontes de confus√£o mais comuns ao usar Docker Compose e a afirma√ß√£o a esclarece corretamente. `depends_on` controla apenas a ordem de `start` dos cont√™ineres. A aplica√ß√£o `api` pode iniciar e tentar se conectar ao `db` antes que o processo do PostgreSQL dentro do cont√™iner `db` esteja totalmente inicializado e pronto, causando uma falha. A solu√ß√£o completa envolve `healthcheck` e resili√™ncia na aplica√ß√£o cliente.<br/><br/>**Feynman/Dica üéØ:** `depends_on` garante que o seu vizinho (`db`) acordou e levantou da cama. N√£o garante que ele j√° escovou os dentes e est√° pronto para conversar (`aceitar conex√µes`). Para saber se ele est√° pronto, voc√™ precisa ficar batendo na porta dele (`retry`) at√© ele responder que est√° pronto (`healthcheck passa`).                                                                                                                                                      |
| 85  | O GitLab Secret Detection √© uma funcionalidade que escaneia o hist√≥rico de commits de um reposit√≥rio em busca de segredos comitados acidentalmente. Ele opera de forma s√≠ncrona durante o `git push`, rejeitando o push se um segredo for encontrado, prevenindo assim que o segredo chegue ao reposit√≥rio remoto.                                                                                                                                                                              | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° no modo de opera√ß√£o. O Secret Detection do GitLab opera de forma **ass√≠ncrona**. Ele escaneia os commits *depois* que eles chegam ao reposit√≥rio. Se um segredo √© encontrado, ele cria um alerta de seguran√ßa, mas **n√£o bloqueia o push**. O bloqueio de push com base em conte√∫do √© uma funcionalidade diferente e mais complexa (push rules), n√£o o comportamento padr√£o do Secret Detection.<br/><br/>**Feynman/Dica üéØ:** O Secret Detection √© o "auditor" que revisa os livros depois que as transa√ß√µes j√° foram feitas. Ele te avisa se encontrar uma fraude (`segredo`), mas n√£o impediu a transa√ß√£o (`push`) de acontecer. A afirma√ß√£o sugere que ele √© um "guarda de seguran√ßa" que barra a transa√ß√£o na porta, o que √© falso para esta funcionalidade espec√≠fica.                                                                                                                                                       |
| 86  | O GitLab Runner pode ser configurado para usar um "helper image", que √© uma imagem Docker utilizada para preparar o ambiente do job, por exemplo, clonando o reposit√≥rio Git e restaurando o cache. Esta imagem √© configur√°vel e pode ser customizada por raz√µes de seguran√ßa, para evitar puxar imagens do Docker Hub p√∫blico em ambientes restritos.                                                                                                                                          | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o uma configura√ß√£o avan√ßada e importante para seguran√ßa e performance do GitLab Runner. A "helper image" √© um detalhe de implementa√ß√£o crucial, e a capacidade de especific√°-la (`helper_image` no `config.toml`) √© essencial para organiza√ß√µes que precisam de controle total sobre as imagens Docker executadas em sua infraestrutura, evitando depend√™ncias externas como o Docker Hub.<br/><br/>**Feynman/Dica üéØ:** Antes do "ator principal" (`job image`) entrar no palco, um "ajudante de palco" (`helper image`) arruma tudo: traz os adere√ßos (`c√≥digo Git`) e coloca os m√≥veis no lugar (`cache`). O GitLab te deixa escolher quem ser√° esse ajudante, o que √© √≥timo se voc√™ tem regras r√≠gidas sobre quem pode entrar no seu teatro (`ambiente seguro`).                                                                                                                                                |
| 87  | A utiliza√ß√£o de `tags` em jobs e runners √© um mecanismo de correspond√™ncia. Um job com a tag `[docker, linux, gpu]` ser√° executado em qualquer runner que possua pelo menos uma dessas tr√™s tags, seguindo uma l√≥gica OR para maximizar a disponibilidade de runners.                                                                                                                                                                                                                           | F                                                                                                                                                                                                                                                                                                             | **Formal:** A l√≥gica de correspond√™ncia de tags √© **AND**, n√£o OR. Um job com m√∫ltiplas tags s√≥ ser√° executado por um runner que possua **TODAS** as tags especificadas. Isso garante que o job rode em um ambiente com todas as capacidades necess√°rias (ex: um runner que √© Linux, tem Docker E tem uma GPU). A afirma√ß√£o descreve a l√≥gica inversa, que seria insegura e imprevis√≠vel.<br/><br/>**Feynman/Dica üéØ:** Pense nas tags como os requisitos de uma vaga de emprego. Se a vaga pede "Fluente em Ingl√™s, Alem√£o e Japon√™s" (`tags`), n√£o adianta aparecer um candidato que s√≥ fala Ingl√™s. O candidato (`runner`) precisa ter todas as qualifica√ß√µes (`tags`) para conseguir o emprego (`job`). A l√≥gica √© E, n√£o OU.                                                                                                                                                                                                                               |
| 88  | O "GitLab Kubernetes Agent" (KAS) estabelece uma conex√£o segura entre o GitLab e um cluster Kubernetes. Para deploys baseados em pull (GitOps), o componente `agentk` √© instalado no cluster, enquanto para deploys baseados em push (CI/CD), a integra√ß√£o √© feita atrav√©s do componente `kas`, que exp√µe uma API para os jobs do GitLab se autenticarem.                                                                                                                                       | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente a arquitetura de dois componentes do GitLab Agent. O `agentk` √© o agente que vive no cluster e opera o modelo "pull" do GitOps. O `kas` (Kubernetes Agent Server) √© o componente que fica do lado do GitLab e serve como um proxy seguro para que os pipelines de CI/CD (modelo "push") possam interagir com a API do Kubernetes sem precisar de credenciais diretas, apenas atrav√©s do token do Agent.<br/><br/>**Feynman/Dica üéØ:** O Agente do GitLab tem dois modos de trabalho. No modo GitOps, ele tem um "olheiro" (`agentk`) dentro do seu castelo (`cluster`) que busca por novidades. No modo CI/CD, ele tem um "porteiro" (`kas`) no port√£o principal do castelo que recebe as entregas do GitLab de forma segura. A afirma√ß√£o descreve corretamente essas duas fun√ß√µes.                                                                                                                               |
| 89  | O recurso "Dynamic Environments" do GitLab, utilizado em Review Apps, permite criar um ambiente com um nome baseado em vari√°veis de CI, como o nome do branch. Uma vez que o branch √© exclu√≠do, o GitLab automaticamente executa o job definido em `environment:on_stop` e, ap√≥s a conclus√£o bem-sucedida deste job, remove o ambiente da lista na UI, mantendo o hist√≥rico de deploys por um per√≠odo configur√°vel.                                                                             | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o o ciclo de vida completo de um ambiente din√¢mico no GitLab. A cria√ß√£o, a a√ß√£o de parada (`on_stop`) vinculada ao ciclo de vida do branch e a subsequente limpeza da UI (enquanto preserva o hist√≥rico para auditoria) s√£o as caracter√≠sticas que tornam as Review Apps uma ferramenta de fluxo de trabalho t√£o poderosa.<br/><br/>**Feynman/Dica üéØ:** A Review App √© como alugar um carro (`ambiente`). Voc√™ usa enquanto precisa (`vida do MR`). Quando voc√™ devolve a chave (`merge/delete do branch`), a locadora executa um procedimento de limpeza (`on_stop`) e depois remove o carro do p√°tio (`UI`), mas mant√©m o registro de que voc√™ o alugou (`hist√≥rico`).                                                                                                                                                                                                                                           |
| 90  | (Adaptada - IBADE/2019) O Git, sendo um Sistema de Controle de Vers√£o Distribu√≠do (DVCS), permite que cada desenvolvedor tenha uma c√≥pia completa do reposit√≥rio, incluindo todo o seu hist√≥rico. No entanto, para fazer um `commit`, o desenvolvedor precisa estar conectado ao reposit√≥rio central (remoto), pois o commit √© uma opera√ß√£o que sincroniza as altera√ß√µes locais com as remotas.                                                                                                 | F                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma pegadinha fundamental sobre a natureza dos DVCS. A opera√ß√£o de `commit` √© puramente **local**. Um desenvolvedor pode fazer dezenas de commits em seu reposit√≥rio local sem nenhuma conex√£o de rede. A opera√ß√£o que requer conectividade com o reposit√≥rio remoto √© o `push` (para enviar os commits) ou o `fetch`/`pull` (para receber altera√ß√µes).<br/><br/>**Feynman/Dica üéØ:** `commit` √© como salvar um documento no seu pr√≥prio computador. Voc√™ pode fazer isso quantas vezes quiser, mesmo offline. `push` √© como anexar esse documento a um e-mail e envi√°-lo para seus colegas. Para isso, voc√™ precisa de internet. A banca confundiu "salvar o arquivo" com "enviar o e-mail".                                                                                                                                                                                                                                                |
| 91  | No `.gitlab-ci.yml`, √© poss√≠vel usar a diretiva `include:local` para importar um arquivo YAML do mesmo reposit√≥rio. Este mecanismo pode ser combinado com vari√°veis de CI para incluir templates dinamicamente, como em `include: "templates/${CI_COMMIT_BRANCH}.yml"`, permitindo que cada branch utilize um pipeline fundamentalmente diferente.                                                                                                                                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve uma t√©cnica avan√ßada e poderosa de pipeline din√¢mico. O uso de vari√°veis na cl√°usula `include` permite que a pr√≥pria estrutura do pipeline seja determinada em tempo de execu√ß√£o com base no contexto (como o nome do branch), oferecendo um n√≠vel extremo de flexibilidade para fluxos de trabalho complexos.<br/><br/>**Feynman/Dica üéØ:** √â como ter um livro de receitas "escolha sua pr√≥pria aventura". Dependendo do cap√≠tulo que voc√™ est√° (`branch`), o livro te manda para uma p√°gina de receita (`template YAML`) completamente diferente. Isso permite que a mesma "cozinha" (`pipeline`) produza pratos totalmente distintos.                                                                                                                                                                                                                                                                                      |
| 92  | O "GitLab Flow" simplifica o Git Flow, mas mant√©m o uso de `hotfixes` como branches criados a partir do `main` para corre√ß√µes urgentes. Ap√≥s o teste, um `hotfix` deve ser mesclado de volta tanto no `main` quanto no branch `develop` para garantir a consist√™ncia, um processo id√™ntico ao do Git Flow.                                                                                                                                                                                      | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° em atribuir uma caracter√≠stica do Git Flow ao GitLab Flow. No GitLab Flow puro, n√£o existe um branch `develop` de longa dura√ß√£o. Um `hotfix` √© criado a partir do `main` (ou de um branch de ambiente de produ√ß√£o), e ap√≥s a corre√ß√£o, ele √© mesclado de volta no `main` e, em seguida, o `main` √© "cherry-picked" ou mesclado nos branches de feature ativos, se necess√°rio. N√£o h√° um `develop` para o qual ele precise ser mesclado.<br/><br/>**Feynman/Dica üéØ:** O GitLab Flow simplificou a casa e jogou fora o "quarto da bagun√ßa" (`develop`). A afirma√ß√£o diz que, para consertar um vazamento urgente (`hotfix`), voc√™ precisa levar o cano novo para o quarto principal (`main`) e tamb√©m para o quarto da bagun√ßa que n√£o existe mais. A l√≥gica est√° quebrada.                                                                                                                                                         |
| 93  | A funcionalidade "Secure Files" do GitLab (tier Premium/Ultimate) permite o upload de arquivos bin√°rios, como certificados de provisionamento m√≥vel ou keystores Java, para o GitLab. Esses arquivos s√£o baixados de forma segura em jobs de CI/CD, resolvendo o problema de como gerenciar arquivos de assinatura de c√≥digo que n√£o podem ser armazenados em texto no reposit√≥rio Git.                                                                                                         | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve perfeitamente o prop√≥sito e a solu√ß√£o fornecida pela funcionalidade "Secure Files". Ela preenche uma lacuna importante no gerenciamento de segredos, que √© lidar com arquivos bin√°rios sens√≠veis necess√°rios durante o processo de build e assinatura, de uma forma segura e integrada ao CI/CD.<br/><br/>**Feynman/Dica üéØ:** Pense em "Secure Files" como o "cofre de objetos" do GitLab. As "CI/CD Variables" guardam senhas (`texto`). O cofre de objetos guarda suas joias e documentos f√≠sicos (`arquivos bin√°rios`). Voc√™ precisa de ambos para uma seguran√ßa completa.                                                                                                                                                                                                                                                                                                                                                 |
| 94  | (Adaptada - VUNESP/2020) A orquestra√ß√£o de cont√™ineres com Kubernetes em um pipeline de CI/CD envolve a manipula√ß√£o de recursos atrav√©s de arquivos de manifesto YAML. O comando `kubectl apply -f manifest.yml` √© idempotente e ir√° criar o recurso se ele n√£o existir, ou atualizar o recurso existente se o manifesto foi alterado. No entanto, se um recurso for removido do arquivo de manifesto, um novo `kubectl apply` n√£o ir√° remover o recurso do cluster.                            | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° correta e destaca uma nuance importante do `kubectl apply`. Ele √© √≥timo para criar e atualizar, mas n√£o lida com a remo√ß√£o de recursos que foram "esquecidos" nos arquivos (um problema conhecido como "drift"). Para uma gest√£o declarativa que tamb√©m lida com remo√ß√µes, s√£o necess√°rias ferramentas de n√≠vel superior como Helm ou Kustomize, ou o uso de `kubectl apply --prune`.<br/><br/>**Feynman/Dica üéØ:** `kubectl apply` √© como uma lista de convidados para uma festa. Ele garante que todos que est√£o na lista entrem. Se voc√™ risca algu√©m da lista, ele n√£o vai l√° e expulsa a pessoa que j√° entrou. Ele s√≥ para de convid√°-la no futuro. A remo√ß√£o precisa de uma a√ß√£o expl√≠cita (`prune` ou `delete`).                                                                                                                                                                                                            |
| 95  | A diretiva `image:entrypoint` em um job do `.gitlab-ci.yml` permite sobrescrever o `ENTRYPOINT` padr√£o da imagem Docker utilizada. No entanto, o `ENTRYPOINT` original da imagem ainda √© executado primeiro, e o `entrypoint` do GitLab √© executado subsequentemente, permitindo a composi√ß√£o de ambos.                                                                                                                                                                                         | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve o comportamento de forma incorreta. A diretiva `image:entrypoint` **substitui completamente** o `ENTRYPOINT` da imagem Docker. O `ENTRYPOINT` original n√£o √© executado. Isso √© feito para que o GitLab Runner tenha controle total sobre como o shell √© iniciado dentro do cont√™iner, permitindo a execu√ß√£o do `before_script` e `script`.<br/><br/>**Feynman/Dica üéØ:** Pense no `ENTRYPOINT` como o "motorista" do carro (`imagem`). A diretiva do GitLab n√£o senta no banco do passageiro, ela **tira o motorista original do carro e assume o volante**. √â uma substitui√ß√£o, n√£o uma adi√ß√£o.                                                                                                                                                                                                                                                                                                                               |
| 96  | A API (Application Programming Interface) GraphQL do GitLab oferece uma alternativa mais flex√≠vel e eficiente √† API REST. Com GraphQL, um cliente pode solicitar exatamente os dados de que precisa em uma √∫nica requisi√ß√£o, evitando tanto o "over-fetching" (receber dados demais) quanto o "under-fetching" (ter que fazer m√∫ltiplas requisi√ß√µes) comuns em APIs REST.                                                                                                                       | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o as vantagens do GraphQL e o fato de que o GitLab oferece uma API GraphQL robusta ao lado de sua API REST tradicional, permitindo que os desenvolvedores escolham a melhor ferramenta para a tarefa de automa√ß√£o.<br/><br/>**Feynman/Dica üéØ:** A API REST √© como pedir um "combo" no restaurante; vem tudo o que est√° no menu daquele combo, mesmo que voc√™ s√≥ quisesse o hamb√∫rguer. A API GraphQL √© como pedir "√† la carte"; voc√™ monta seu prato exatamente com o que quer, nem mais, nem menos, e o gar√ßom te traz tudo de uma vez.                                                                                                                                                                                                                                                                                                                                                                           |
| 97  | Um "release" no GitLab √© conceitualmente id√™ntico a uma "tag" Git. A cria√ß√£o de um release na interface do GitLab √© apenas um atalho visual para executar o comando `git tag` no reposit√≥rio, sem adicionar nenhuma funcionalidade ou metadado adicional.                                                                                                                                                                                                                                       | F                                                                                                                                                                                                                                                                                                             | **Formal:** Um "Release" no GitLab √© uma "tag" **enriquecida**. Ele √© um objeto de primeira classe associado a uma tag Git, mas que pode conter metadados adicionais muito importantes, como notas de lan√ßamento (changelog), marcos (milestones) associados e, crucialmente, os artefatos de build (bin√°rios, pacotes) daquele release. √â muito mais do que um simples ponteiro Git.<br/><br/>**Feynman/Dica üéØ:** Uma `tag` Git √© uma etiqueta de pre√ßo. Um `Release` GitLab √© a caixa completa do produto, com a etiqueta de pre√ßo, o manual de instru√ß√µes (`notas de lan√ßamento`) e o produto em si dentro da caixa (`artefatos`). A afirma√ß√£o diz que a caixa e a etiqueta s√£o a mesma coisa.                                                                                                                                                                                                                                                              |
| 98  | A diretiva `allow_failure:exit_codes` em um job permite um controle mais granular sobre quando um job pode falhar. Por exemplo, uma ferramenta de lint pode sair com c√≥digo `1` para erros de linting e `2` para erros de configura√ß√£o. Com `allow_failure:exit_codes: [2]`, o pipeline continuaria se a ferramenta falhasse por um erro de configura√ß√£o, mas falharia se encontrasse um erro de linting.                                                                                       | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente uma funcionalidade avan√ßada e √∫til da diretiva `allow_failure`. Ela permite tratar diferentes tipos de falha de um script de maneiras diferentes, tornando o pipeline mais inteligente e resiliente, em vez de tratar todas as falhas como catastr√≥ficas.<br/><br/>**Feynman/Dica üéØ:** √â como um juiz de futebol. Normalmente, qualquer falta grave (`exit code` diferente de 0) resulta em cart√£o vermelho (`pipeline falha`). Com `allow_failure:exit_codes`, voc√™ pode dizer ao juiz: "Olha, se a falta for deste tipo espec√≠fico (`exit code 2`), pode dar s√≥ um cart√£o amarelo (`pipeline continua`), mas para todas as outras, √© vermelho direto."                                                                                                                                                                                                                                                         |
| 99  | A Governan√ßa de TI, conforme frameworks como o COBIT (Control Objectives for Information and Related Technologies) 2019, enfatiza a separa√ß√£o de responsabilidades e a auditabilidade. O GitLab suporta este princ√≠pio atrav√©s da combina√ß√£o de "Protected Branches", que impede que desenvolvedores fa√ßam merge em `main`, e "Merge Request Approvals", que exige a aprova√ß√£o de um gerente ou l√≠der t√©cnico, criando um rastro de auditoria que demonstra o controle de mudan√ßas.             | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o faz uma conex√£o precisa e de alto n√≠vel entre os requisitos de um framework de governan√ßa de TI l√≠der de mercado e as funcionalidades espec√≠ficas do GitLab que ajudam a implement√°-lo. A capacidade de for√ßar a revis√£o e aprova√ß√£o por diferentes pap√©is √© um controle fundamental exigido pelo COBIT.<br/><br/>**Feynman/Dica üéØ:** O COBIT desenha as "leis" de como a TI deve ser gerenciada. O GitLab fornece as "ferramentas" para construir uma cidade que segue essas leis. As "ruas de m√£o √∫nica" (`Protected Branches`) e os "sinais de pare e autoriza√ß√£o" (`Approvals`) s√£o exemplos de como a ferramenta implementa a lei.                                                                                                                                                                                                                                                                                                |
| 100 | Em um pipeline GitLab, o `before_script` e o `script` de um job s√£o concatenados e executados como um √∫nico script cont√≠nuo pelo runner. Consequentemente, uma vari√°vel de ambiente exportada no `before_script` estar√° dispon√≠vel para os comandos no `script`.                                                                                                                                                                                                                                | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente como o GitLab Runner executa os scripts. Ele n√£o os executa em shells separados. O `before_script` serve para a prepara√ß√£o do ambiente (setup), e quaisquer modifica√ß√µes nesse ambiente, como a exporta√ß√£o de vari√°veis, persistem para a execu√ß√£o do `script` principal. √â um detalhe de implementa√ß√£o importante para entender o fluxo de dados dentro de um job.<br/><br/>**Feynman/Dica üéØ:** Pense no job como um √∫nico ato de uma pe√ßa. O `before_script` √© o ator arrumando o cen√°rio no escuro. O `script` √© o ator atuando sob os holofotes. √â a mesma pessoa (`shell`), no mesmo palco, ent√£o o que ele arrumou no escuro ainda est√° l√° quando a luz acende.                                                                                                                                                                                                                                            |
| 101 | (Adaptada - FEPESE/2019) O RabbitMQ, um popular message broker, utiliza o protocolo AMQP (Advanced Message Queuing Protocol). Em um pipeline de testes de integra√ß√£o do GitLab, um servi√ßo do RabbitMQ pode ser iniciado, e a aplica√ß√£o pode ser testada para garantir que ela publica mensagens em `exchanges` e consome de `queues` corretamente, validando a l√≥gica de comunica√ß√£o ass√≠ncrona.                                                                                               | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve um cen√°rio de teste de integra√ß√£o perfeitamente v√°lido e comum. A capacidade do GitLab CI de iniciar servi√ßos de depend√™ncia como o RabbitMQ √© crucial para testar aplica√ß√µes que dependem de comunica√ß√£o ass√≠ncrona, garantindo que os contratos de mensagem e a l√≥gica de processamento estejam corretos.<br/><br/>**Feynman/Dica üéØ:** Testar uma aplica√ß√£o que usa RabbitMQ sem o RabbitMQ √© como testar um telefone sem uma linha telef√¥nica. O GitLab te d√° uma "linha telef√¥nica" tempor√°ria (`servi√ßo RabbitMQ`) para que voc√™ possa fazer a liga√ß√£o (`teste`) e ver se a mensagem chega do outro lado corretamente.                                                                                                                                                                                                                                                                                                   |
| 102 | A funcionalidade de "CI/CD Tunnel" do GitLab, habilitada pelo Kubernetes Agent, permite que um job de CI/CD acesse servi√ßos expostos dentro de um cluster Kubernetes que n√£o s√£o publicamente acess√≠veis na internet. Isso √© feito criando um t√∫nel reverso seguro do cluster para o job, permitindo, por exemplo, que um job de teste se conecte a um banco de dados de `staging` que est√° dentro da rede privada do cluster.                                                                  | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o a capacidade e o caso de uso do "CI/CD Tunnel", uma funcionalidade poderosa do GitLab Agent. Ela resolve o problema de como conectar o ambiente ef√™mero do Runner a servi√ßos em uma rede privada de forma segura, sem expor esses servi√ßos ou gerenciar regras de firewall complexas.<br/><br/>**Feynman/Dica üéØ:** O CI/CD Tunnel √© como um "t√∫nel secreto de teletransporte" que o Agente abre. O seu `job`, que est√° fora do castelo (`cluster`), pode usar esse t√∫nel para conversar diretamente com algu√©m que est√° l√° dentro (`banco de dados`), sem precisar passar pelo port√£o principal ou pelos guardas.                                                                                                                                                                                                                                                                                                |
| 103 | O GitLab Pages suporta apenas um √∫nico dom√≠nio personalizado por inst√¢ncia GitLab. Se m√∫ltiplos projetos em uma mesma inst√¢ncia precisarem de dom√≠nios personalizados, eles devem ser configurados como subdom√≠nios do dom√≠nio principal configurado pelo administrador.                                                                                                                                                                                                                        | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o √© falsa. O GitLab Pages √© bastante flex√≠vel. Um administrador de uma inst√¢ncia Self-Hosted pode configurar um dom√≠nio wildcard para os projetos (ex: `*.pages.example.com`), mas cada projeto individual pode, adicionalmente, configurar seu pr√≥prio dom√≠nio personalizado completamente diferente (ex: `www.meuprojeto.com`), incluindo a gest√£o de certificados TLS/SSL, atrav√©s de suas pr√≥prias configura√ß√µes de projeto.<br/><br/>**Feynman/Dica üéØ:** A banca diz que todos os moradores de um pr√©dio (`inst√¢ncia GitLab`) que querem uma caixa de correio personalizada (`dom√≠nio`) precisam usar o sobrenome do pr√©dio. Na verdade, cada morador pode registrar sua pr√≥pria caixa postal nos Correios com o nome que quiser. A flexibilidade √© por projeto.                                                                                                                                                                    |
| 104 | A diretiva `extends` no `.gitlab-ci.yml` √© um mecanismo de composi√ß√£o que permite que um job herde a configura√ß√£o de uma defini√ß√£o de job "template" oculta (que come√ßa com um `.`). No entanto, `extends` n√£o pode ser usado em conjunto com `rules`, pois a l√≥gica de inclus√£o do `extends` entra em conflito com a l√≥gica de decis√£o do `rules`.                                                                                                                                             | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o imp√µe uma limita√ß√£o que n√£o existe. √â perfeitamente v√°lido e muito comum usar `extends` e `rules` juntos. Um job pode herdar a maior parte de sua configura√ß√£o (script, imagem, etc.) de um template usando `extends`, e ent√£o definir sua pr√≥pria cl√°usula `rules` para especificar as condi√ß√µes exatas sob as quais esta vers√£o particular do job deve ser executada. O `rules` do job espec√≠fico sobrescreve o do template.<br/><br/>**Feynman/Dica üéØ:** `extends` √© como usar uma "forma de bolo" (`template`) para fazer seu bolo (`job`). `rules` √© a sua decis√£o de "quando" voc√™ vai usar essa forma (s√≥ aos domingos, s√≥ se tiver chocolate, etc.). As duas coisas s√£o perfeitamente compat√≠veis. Voc√™ pode decidir quando usar a sua forma de bolo favorita.                                                                                                                                                                 |
| 105 | (Adaptada - QUADRIX/2022) O Prometheus, uma ferramenta de monitoramento, opera em um modelo "pull", onde ele periodicamente busca (scrape) m√©tricas de endpoints HTTP expostos pelos alvos. O Grafana, por sua vez, √© uma plataforma de visualiza√ß√£o que pode ser configurada para usar o Prometheus como uma fonte de dados (datasource) para criar pain√©is e gr√°ficos.                                                                                                                        | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o a rela√ß√£o e a arquitetura padr√£o entre Prometheus e Grafana. Prometheus coleta e armazena os dados, e Grafana os consulta e exibe de forma bonita e √∫til. Eles s√£o duas pe√ßas que se encaixam perfeitamente para formar uma solu√ß√£o de monitoramento completa.<br/><br/>**Feynman/Dica üéØ:** Prometheus √© o "bibliotec√°rio" que organiza e armazena todos os livros (`m√©tricas`). Grafana √© o "designer" que pega esses livros e cria uma exposi√ß√£o incr√≠vel na vitrine da biblioteca (`pain√©is`), tornando a informa√ß√£o f√°cil de ser consumida.                                                                                                                                                                                                                                                                                                                                                                  |
| 106 | A funcionalidade de "Environments" no GitLab √© puramente informacional, servindo como um log visual para rastrear quais commits foram implantados em cada ambiente. Ela n√£o possui nenhuma funcionalidade ativa, como a capacidade de acionar rollbacks ou parar ambientes.                                                                                                                                                                                                                     | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o subestima drasticamente a funcionalidade. Os Ambientes s√£o objetos ativos e centrais para o Continuous Delivery no GitLab. A partir da UI de Ambientes, um usu√°rio com as permiss√µes corretas pode: 1) Re-executar um deploy antigo (efetivamente fazendo um **rollback**), 2) **Parar** um ambiente (o que aciona o job `on_stop`), 3) Acessar um terminal web para o ambiente (se configurado), e 4) Ver as m√©tricas de monitoramento associadas.<br/><br/>**Feynman/Dica üéØ:** A banca diz que a p√°gina de Ambientes √© um "√°lbum de fotos" est√°tico do passado. Na verdade, √© um "painel de controle" interativo com bot√µes que afetam o presente e o futuro, incluindo um grande bot√£o vermelho de "ejetar" (`rollback`).                                                                                                                                                                                                           |
| 107 | O arquivo de configura√ß√£o do GitLab Runner (`config.toml`) suporta a defini√ß√£o de vari√°veis de ambiente globais que ser√£o injetadas em todos os jobs executados por aquele runner. No entanto, se uma vari√°vel com o mesmo nome for definida nas CI/CD Variables do projeto no GitLab, o valor definido no `config.toml` do runner ter√° preced√™ncia, por ser uma configura√ß√£o de infraestrutura mais pr√≥xima da execu√ß√£o.                                                                       | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve a regra de preced√™ncia de vari√°veis de forma invertida. O GitLab possui uma hierarquia de preced√™ncia bem definida, e as vari√°veis definidas no n√≠vel do projeto/grupo na UI do GitLab **sempre sobrescrevem** as definidas no `config.toml` do runner. Isso garante que a configura√ß√£o do projeto tenha autoridade sobre a configura√ß√£o gen√©rica do runner.<br/><br/>**Feynman/Dica üéØ:** Pense nas vari√°veis como ordens. A ordem do "General" (`UI do GitLab`) √© sempre mais forte que a ordem do "Capit√£o" (`config.toml do runner`). Se o General diz "ataquem pelo norte" e o Capit√£o diz "ataquem pelo sul", a tropa (`job`) vai atacar pelo norte. A preced√™ncia vem de cima para baixo.                                                                                                                                                                                                                               |
| 108 | A API REST do GitLab utiliza c√≥digos de status HTTP para indicar o resultado de uma opera√ß√£o. Uma requisi√ß√£o `POST` para criar um recurso que √© bem-sucedida retornar√° um status `200 OK`, enquanto uma requisi√ß√£o `GET` para um recurso que n√£o existe retornar√° `404 Not Found`. Uma tentativa de exclus√£o de um recurso sem permiss√£o adequada retornar√° `403 Forbidden`.                                                                                                                    | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° quase toda correta, seguindo as conven√ß√µes REST, mas h√° um erro sutil e comum. Uma requisi√ß√£o `POST` bem-sucedida que **cria** um novo recurso deve, semanticamente, retornar o c√≥digo de status **`201 Created`**, e n√£o `200 OK`. O `200 OK` √© mais apropriado para uma requisi√ß√£o `GET` ou `PUT`/`PATCH` bem-sucedida. A banca testa o conhecimento preciso dos c√≥digos de status HTTP.<br/><br/>**Feynman/Dica üéØ:** Pense nos c√≥digos de status como respostas a um pedido. `200 OK` √© "Sim, entendi seu pedido e aqui est√° a resposta". `201 Created` √© "Sim, entendi seu pedido e criei uma coisa nova para voc√™, como pediu". `404` √© "Procurei, mas n√£o achei". `403` √© "Eu sei o que voc√™ quer, mas voc√™ n√£o tem permiss√£o". A afirma√ß√£o usou a resposta errada para a a√ß√£o de criar.                                                                                                                                    |
| 109 | (Adaptada - CEBRASPE/2021) Em um sistema de controle de vers√£o como o Git, um `merge` recursivo √© a estrat√©gia padr√£o para combinar dois branches. Se a mesma se√ß√£o de um arquivo foi alterada em ambos os branches, o Git tentar√° mesclar as mudan√ßas automaticamente, mas se as altera√ß√µes forem na mesma linha, ocorrer√° um conflito de merge que deve ser resolvido manualmente pelo desenvolvedor.                                                                                         | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o o comportamento padr√£o do `git merge` e a natureza de um conflito de merge. O Git √© inteligente para mesclar mudan√ßas em diferentes partes de um arquivo, mas quando as altera√ß√µes s√£o concorrentes na mesma linha (ou linhas adjacentes), ele n√£o pode adivinhar a inten√ß√£o e, corretamente, pausa o processo e pede a interven√ß√£o humana para resolver a ambiguidade.<br/><br/>**Feynman/Dica üéØ:** O Git √© como duas pessoas tentando escrever em um mesmo documento. Se uma escreve no come√ßo e a outra no final, tudo bem. Mas se as duas tentam reescrever a mesma frase ao mesmo tempo, elas precisam parar, conversar e decidir qual vers√£o da frase fica. Esse "parar para conversar" √© o conflito de merge.                                                                                                                                                                                             |
| 110 | O GitLab suporta a autentica√ß√£o de dois fatores (2FA) para aumentar a seguran√ßa da conta do usu√°rio. Uma vez que o 2FA √© ativado para uma conta, ele √© exigido para o login na interface web. No entanto, para opera√ß√µes Git sobre HTTPS, o usu√°rio pode continuar a usar sua senha de login normal, pois o 2FA se aplica apenas √† sess√£o web.                                                                                                                                                  | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o √© perigosamente falsa. Quando o 2FA est√° ativado, a senha de login do usu√°rio **n√£o pode mais ser usada** para opera√ß√µes Git sobre HTTPS. O usu√°rio √© obrigado a criar um **Personal Access Token (PAT)** com os escopos apropriados (`read_repository`, `write_repository`) e usar o PAT no lugar da senha ao clonar, puxar ou empurrar via HTTPS. Esta √© uma medida de seguran√ßa fundamental.<br/><br/>**Feynman/Dica üéØ:** Com o 2FA, sua senha principal vira a "chave de casa". O Personal Access Token √© a "chave do carro". Para dirigir o carro (`opera√ß√µes Git`), voc√™ precisa usar a chave do carro, a chave de casa n√£o vai funcionar. A banca quer que voc√™ pense que a chave de casa serve para tudo, o que criaria uma falha de seguran√ßa.                                                                                                                                                                                |
| 111 | No job `build docker image`, a utiliza√ß√£o da vari√°vel `$NOCACHE` no comando `docker build` sugere uma estrat√©gia de build condicional, onde a vari√°vel pode ser definida em execu√ß√µes manuais do pipeline para for√ßar a reconstru√ß√£o de todas as camadas da imagem, ignorando qualquer cache do Docker, seja local ou remoto.                                                                                                                                                                   | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente um padr√£o comum para depura√ß√£o e for√ßar builds limpos. A vari√°vel `$NOCACHE` provavelmente conteria a flag `--no-cache`. Ao n√£o defini-la por padr√£o, o build usa o cache. Ao defini-la manualmente ao iniciar um pipeline, o desenvolvedor pode "invalidar" o cache para investigar problemas de build inconsistentes. √â um mecanismo de "escape hatch".<br/><br/>**Feynman/Dica üéØ:** Pense no `$NOCACHE` como um bot√£o de "limpeza geral" na sua cozinha. Normalmente, voc√™ reutiliza as panelas limpas (`cache`). Mas se uma receita est√° dando errado, voc√™ aperta o bot√£o para que o rob√¥-cozinheiro lave tudo e comece do zero (`--no-cache`), garantindo que n√£o h√° nenhum res√≠duo antigo causando o problema.                                                                                                                                                                                            |
| 112 | O job `build docker image` utiliza a diretiva `tags` com o valor `DOCKERBUILD`, o que indica que este job s√≥ pode ser executado por um runner espec√≠fico que foi registrado com esta mesma tag. Este runner provavelmente possui o daemon Docker instalado e as permiss√µes necess√°rias para construir e enviar imagens, enquanto os jobs de deploy utilizam runners `shared`, que s√£o de prop√≥sito geral.                                                                                       | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o interpreta com precis√£o a l√≥gica de direcionamento de jobs. O uso de uma tag espec√≠fica (`DOCKERBUILD`) para o job de build √© uma pr√°tica de seguran√ßa e gest√£o de recursos recomendada, isolando a tarefa de constru√ß√£o de imagens em runners preparados para isso. A utiliza√ß√£o de runners `shared` para o deploy, que apenas executam scripts SSH, demonstra uma separa√ß√£o de responsabilidades clara entre os runners.<br/><br/>**Feynman/Dica üéØ:** A empresa tem dois tipos de funcion√°rios: os "construtores" especializados (`runner DOCKERBUILD`) que trabalham na f√°brica, e os "entregadores" gen√©ricos (`runner shared`) que levam o produto para o cliente. A tag √© o crach√° que diz "s√≥ construtores nesta √°rea".                                                                                                                                                                                                         |
| 113 | O template oculto `.deploy-script` utiliza o comando `sed` para substituir placeholders (como `__VERSAO__`) em um arquivo de manifesto (`$YAMLDEPLOY`). A utiliza√ß√£o do delimitador `~` em vez da tradicional `/` no primeiro `sed` √© necess√°ria porque a vari√°vel `$CI_REGISTRY_IMAGE` cont√©m barras (`/`), o que quebraria o comando `sed` se a barra tamb√©m fosse usada como delimitador.                                                                                                    | V                                                                                                                                                                                                                                                                                                             | **Formal:** Esta √© uma an√°lise t√©cnica precisa de um detalhe pr√°tico de scripting em shell. A flexibilidade do `sed` em permitir a troca de delimitadores √© uma caracter√≠stica fundamental que √© frequentemente usada para evitar o "inferno de escaping" ao manipular strings que cont√™m o caractere delimitador padr√£o, como URLs ou caminhos de arquivo.<br/><br/>**Feynman/Dica üéØ:** √â uma "mal√≠cia" de quem programa em shell. Se voc√™ est√° tentando cortar um tomate (`string`) com uma faca de tomate (`delimitador /`), n√£o vai funcionar. O `sed` te deixa pegar outra faca, como uma faca de queijo (`delimitador ~`), para fazer o corte sem problemas. A afirma√ß√£o reconhece essa troca de ferramenta.                                                                                                                                                                                                                                             |
| 114 | No job `deploy to hml`, a diretiva `dependencies: []` √© utilizada para otimizar o job, impedindo o download de artefatos. No entanto, esta configura√ß√£o √© redundante e sem efeito pr√°tico, pois o job `build docker image` n√£o define uma cl√°usula `artifacts`, significando que n√£o h√° artefatos a serem baixados de qualquer maneira.                                                                                                                                                         | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° correta. A diretiva `dependencies` controla o download de artefatos criados com `artifacts`. Como o √∫nico job no est√°gio anterior (`build docker image`) n√£o produz artefatos para o pipeline (ele produz uma imagem Docker enviada a um registro externo), a declara√ß√£o `dependencies: []` √© funcionalmente in√≥cua. Embora n√£o cause erro, ela n√£o otimiza nada neste contexto espec√≠fico. A banca testa se voc√™ entende a rela√ß√£o entre `artifacts` e `dependencies`.<br/><br/>**Feynman/Dica üéØ:** √â como trancar uma porta que n√£o tem fechadura. A inten√ß√£o (`otimizar`) √© boa, mas a a√ß√£o (`dependencies: []`) n√£o tem efeito porque n√£o h√° nada para ser baixado. Voc√™ precisa que um job *crie* um artefato para que outro possa *depender* dele.                                                                                                                                                                          |
| 115 | A l√≥gica de `rules` no job `build docker image` define a vari√°vel `VERSAO` de tr√™s maneiras diferentes. A terceira regra (`if: $CI_COMMIT_TAG && $CI_COMMIT_TAG !~ /.*-hml$$/ && $CI_PIPELINE_SOURCE == "web"`) garante que um deploy de produ√ß√£o, acionado por uma tag, s√≥ possa ser iniciado manualmente atrav√©s da interface web do GitLab.                                                                                                                                                  | V                                                                                                                                                                                                                                                                                                             | **Formal:** A an√°lise da terceira regra est√° correta. A condi√ß√£o `$CI_PIPELINE_SOURCE == "web"` √© a chave. Ela garante que o pipeline s√≥ ser√° criado para a tag de produ√ß√£o se algu√©m for na UI do GitLab e clicar em "Run pipeline" para aquela tag espec√≠fica, fornecendo um port√£o de controle humano expl√≠cito para releases de produ√ß√£o, mesmo que a tag j√° tenha sido empurrada para o reposit√≥rio.<br/><br/>**Feynman/Dica üéØ:** Para lan√ßar o foguete de produ√ß√£o üöÄ, n√£o basta apenas a chave ser inserida (`git push --tags`). Algu√©m na torre de controle (`UI do GitLab`) precisa apertar o bot√£o vermelho (`Run pipeline`). A regra `$CI_PIPELINE_SOURCE == "web"` √© esse bot√£o vermelho, adicionando uma camada extra de seguran√ßa deliberada.                                                                                                                                                                                                    |
| 116 | A reutiliza√ß√£o de c√≥digo no pipeline √© alcan√ßada atrav√©s da diretiva `extends: .deploy-script`. Os jobs `deploy to hml` e `deploy to prod` herdam o `script` completo do template `.deploy-script` e, em seguida, sobrescrevem ou adicionam vari√°veis espec√≠ficas para cada ambiente, como `$SPPEA_DEPLOY_SERVER`.                                                                                                                                                                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente o uso do mecanismo de heran√ßa (`extends`) do GitLab CI/CD. √â uma das melhores pr√°ticas para reduzir a duplica√ß√£o de c√≥digo (princ√≠pio DRY - Don't Repeat Yourself) em pipelines, permitindo que a l√≥gica de deploy comum seja definida uma vez e customizada para cada ambiente atrav√©s de vari√°veis.<br/><br/>**Feynman/Dica üéØ:** `.deploy-script` √© a "receita base" de um bolo. Os jobs de `hml` e `prod` s√£o as varia√ß√µes. Ambos usam a mesma receita base (`extends`), mas um adiciona cobertura de chocolate (`vari√°veis de HML`) e o outro adiciona cobertura de morango (`vari√°veis de PROD`).                                                                                                                                                                                                                                                                                                           |
| 117 | O comando `ssh -o StrictHostKeyChecking=no ...` √© utilizado para se conectar a um servidor remoto. A op√ß√£o `-o StrictHostKeyChecking=no` √© uma pr√°tica de seguran√ßa recomendada em pipelines de CI/CD, pois garante que o runner verifique a chave de host do servidor remoto contra seu arquivo `known_hosts`, prevenindo ataques "man-in-the-middle".                                                                                                                                         | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o √© perigosamente falsa e descreve o exato oposto do que a op√ß√£o faz. `StrictHostKeyChecking=no` **desabilita** a verifica√ß√£o da chave do host. Isso √© comumente feito em ambientes ef√™meros de CI para evitar a complexidade de gerenciar o arquivo `known_hosts`, mas √© uma pr√°tica que **degrada a seguran√ßa** ao tornar o pipeline vulner√°vel a ataques "man-in-the-middle". A afirma√ß√£o rotula uma pr√°tica de conveni√™ncia insegura como uma pr√°tica de seguran√ßa recomendada.<br/><br/>**Feynman/Dica üéØ:** `StrictHostKeyChecking` √© o seu celular te perguntando: "Voc√™ confia nesta rede Wi-Fi?". A op√ß√£o `no` √© como clicar em "Conectar Mesmo Assim" sem se importar se a rede √© segura. √â pr√°tico, mas arriscado. A banca colocou uma etiqueta de "Seguro" em um comportamento de risco.                                                                                                                                      |
| 118 | A sequ√™ncia de comandos no `script` de `.deploy-script` implementa um deploy Blue/Green. O comando `docker compose ... down` desliga a vers√£o `blue`, e o comando `docker compose ... up -d` inicia a nova vers√£o `green`, resultando em um breve per√≠odo de downtime durante a troca.                                                                                                                                                                                                          | F                                                                                                                                                                                                                                                                                                             | **Formal:** O script implementa uma estrat√©gia de deploy de **re-cria√ß√£o (recreate)** ou "rolling update" simples, n√£o Blue/Green. Um deploy Blue/Green verdadeiro exigiria que a nova vers√£o fosse iniciada e ficasse pronta *antes* de a vers√£o antiga ser desligada, com o tr√°fego sendo chaveado instantaneamente por um load balancer. O script claramente desliga a vers√£o antiga (`down`) antes de ligar a nova (`up`), o que causa downtime.<br/><br/>**Feynman/Dica üéØ:** A banca te mostrou um Fusca e disse que √© uma Ferrari. O script faz um "desliga-e-liga", que √© simples e funcional, mas causa uma interrup√ß√£o. Blue/Green √© uma manobra muito mais sofisticada, como dois carros andando lado a lado e o passageiro pulando de um para o outro sem que nenhum dos dois pare.                                                                                                                                                                 |
| 119 | O comando `(docker compose ... down && sleep 4)                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                               | echo 0` √© projetado para ser resiliente. Se o comando `docker compose ... down` falhar (por exemplo, porque n√£o havia nenhum servi√ßo rodando), o `                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              || echo 0` garante que o script n√£o saia com um c√≥digo de erro, permitindo que o pipeline continue para o pr√≥ximo passo, que √© iniciar os novos cont√™ineres. | V | **Formal:** A afirma√ß√£o analisa corretamente a l√≥gica de controle de fluxo do shell. O operador `||` (OR) executa o comando √† sua direita apenas se o comando √† sua esquerda falhar (retornar um exit code diferente de zero). Ao usar `echo 0` (que retorna um exit code de sucesso), o script garante que esta linha inteira sempre termine com sucesso, tornando o passo de "desligar" opcional e √† prova de falhas.<br/><br/>**Feynman/Dica üéØ:** √â como tentar desligar uma TV. Se ela j√° estiver desligada e o bot√£o n√£o fizer nada, voc√™ n√£o quer que isso seja um "erro". O `|| echo 0` √© o ato de dizer "se a TV n√£o desligar porque j√° estava desligada, tudo bem, bola pra frente". √â uma forma de tratar um "n√£o-evento" como um sucesso. |
| 120 | No job `deploy to prod`, a vari√°vel `SPPEA_DEPLOY_SERVER` √© definida com um endere√ßo IP (`10.220.63.158`) em vez de um nome de dom√≠nio, com um coment√°rio indicando que o dom√≠nio est√° atr√°s de um WAF (Web Application Firewall). Isso sugere que a conex√£o SSH para deploy precisa contornar o WAF, conectando-se diretamente ao IP interno do servidor, o que implica que o runner que executa este job deve ter acesso √† rede interna onde este IP √© rote√°vel.                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o faz uma infer√™ncia correta e profunda sobre a arquitetura de rede subjacente, baseada nos detalhes do c√≥digo e dos coment√°rios. A necessidade de usar um IP privado para o deploy via SSH enquanto o servi√ßo p√∫blico est√° atr√°s de um WAF √© um cen√°rio de rede corporativa muito realista e indica que o runner `shared` (se for o caso) precisa de uma configura√ß√£o de rede especial (como um peering ou VPN) para alcan√ßar a rede de produ√ß√£o.<br/><br/>**Feynman/Dica üéØ:** O coment√°rio no c√≥digo √© a "dica do detetive" üïµÔ∏è. O endere√ßo p√∫blico √© a "porta da frente" com muitos seguran√ßas (`WAF`). Para fazer o trabalho de manuten√ß√£o (`deploy`), o funcion√°rio (`runner`) usa a "porta dos fundos" (`IP interno`), que requer uma chave especial (`acesso √† rede interna`).                                                                                                                                                    |
| 121 | Os comandos `sed` no script de deploy modificam o arquivo `$YAMLDEPLOY` no reposit√≥rio Git e, em seguida, o `scp` envia a vers√£o modificada para o servidor. Esta √© a pr√°tica recomendada, pois garante que o manifesto de deploy usado no servidor esteja sempre sincronizado com o estado mais recente do c√≥digo-fonte.                                                                                                                                                                       | F                                                                                                                                                                                                                                                                                                             | **Formal:** A pegadinha est√° em onde a modifica√ß√£o ocorre. O script modifica uma c√≥pia do arquivo `$YAMLDEPLOY` **dentro do ambiente de execu√ß√£o do runner do GitLab**, e n√£o no reposit√≥rio Git. O pipeline clona o reposit√≥rio, modifica o arquivo na mem√≥ria/disco do runner e envia essa vers√£o modificada. O arquivo original no Git permanece intocado. A pr√°tica √© correta para deploy, mas a afirma√ß√£o descreve incorretamente que o reposit√≥rio Git √© alterado.<br/><br/>**Feynman/Dica üéØ:** O pipeline tira uma "fotoc√≥pia" do seu documento original (`arquivo no Git`), rabisca nela (`sed`) e envia a fotoc√≥pia rabiscada por fax (`scp`). O seu documento original na sua gaveta (`reposit√≥rio`) continua limpo e sem altera√ß√µes. A banca disse que o rabisco foi feito no original.                                                                                                                                                             |
| 122 | O comando `ssh ... "echo -n $SPPEA_AATI_READ_REGISTRY_TOKEN                                                                                                                                                                                                                                                                                                                                                                                                                                     | docker login ..."` demonstra uma passagem segura de segredos. O token √© passado via `stdin` para o `docker login` no servidor remoto, o que evita que o segredo apare√ßa na lista de processos do servidor (como aconteceria se fosse passado como um argumento de linha de comando) ou no hist√≥rico do shell. | V                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | **Formal:** A afirma√ß√£o descreve uma t√©cnica de seguran√ßa de shell muito importante. Usar um pipe (`|`) e a op√ß√£o `--password-stdin` √© a forma can√¥nica e segura de fazer login em registros Docker em scripts automatizados, pois o segredo transita por um canal `stdin` e n√£o fica exposto em texto claro no hist√≥rico ou na √°rvore de processos do sistema.<br/><br/>**Feynman/Dica üéØ:** Passar a senha como argumento √© como gritar a senha em uma sala cheia de gente. Algu√©m pode ouvir (`ver no ps`). Passar via `--password-stdin` √© como sussurrar a senha no ouvido do seguran√ßa (`processo docker login`). √â muito mais discreto e seguro. |
| 123 | A l√≥gica de `rules` no job `build docker image` √© processada sequencialmente. Se a condi√ß√£o `$CI_COMMIT_TAG` for `v1.0.0-hml`, tanto a segunda regra (`if: $CI_COMMIT_TAG =~ /.*-hml$$/`) quanto a primeira (`if: $CI_COMMIT_BRANCH`, que √© falso) ser√£o avaliadas. Como a segunda regra corresponde, a vari√°vel `VERSAO` ser√° definida como `v1.0.0-hml` e o processamento de regras para, resultando na execu√ß√£o do job.                                                                      | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve corretamente o fluxo de avalia√ß√£o de `rules`. O GitLab avalia as regras na ordem em que aparecem. A primeira regra que corresponder determina se o job ser√° inclu√≠do no pipeline e quais vari√°veis ser√£o definidas. Como a tag `v1.0.0-hml` casa com a segunda regra, essa √© a que "vence", e as regras subsequentes n√£o s√£o mais avaliadas para este job.<br/><br/>**Feynman/Dica üéØ:** As `rules` s√£o como um seguran√ßa com uma lista de permiss√µes, de cima para baixo. Ele olha para o seu crach√° (`contexto do commit`). Se o seu crach√° bate com a primeira regra da lista, ele te deixa entrar (ou n√£o) e o trabalho dele acaba. Se n√£o, ele vai para a segunda regra, e assim por diante, at√© encontrar a primeira que se aplica a voc√™.                                                                                                                                                                               |
| 124 | O job `build docker image` define `DOCKER_BUILDKIT: 1`. Esta vari√°vel de ambiente habilita o BuildKit, o motor de build de pr√≥xima gera√ß√£o do Docker. Isso permite funcionalidades avan√ßadas como a constru√ß√£o paralela de est√°gios e um melhor gerenciamento de cache, o que pode acelerar significativamente o tempo de constru√ß√£o da imagem Docker, mesmo sem a flag `--no-cache`.                                                                                                           | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o est√° correta. Habilitar o BuildKit √© uma das melhores pr√°ticas modernas para a constru√ß√£o de imagens Docker. Ele oferece um backend de build completamente novo com um planejador de depend√™ncias mais inteligente e melhorias de performance significativas em rela√ß√£o ao motor de build legado.<br/><br/>**Feynman/Dica üéØ:** Pense no motor de build antigo como um cozinheiro que segue a receita linha por linha. O BuildKit √© um chef moderno que l√™ a receita inteira, percebe que pode colocar a √°gua para ferver enquanto corta os legumes (`paralelismo`) e otimiza todo o processo, entregando o prato muito mais r√°pido.                                                                                                                                                                                                                                                                                                    |
| 125 | Os comandos `sed` no `.deploy-script` s√£o a √∫nica forma de customizar o deploy para cada ambiente. O `docker-compose-frontend.yml` n√£o pode conter vari√°veis de ambiente, pois o Docker Compose n√£o as suporta nativamente, exigindo essa pr√©-substitui√ß√£o de texto.                                                                                                                                                                                                                            | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o √© fundamentalmente falsa. O Docker Compose suporta nativamente e extensivamente o uso de vari√°veis de ambiente para customiza√ß√£o. Um arquivo `docker-compose.yml` pode conter placeholders como `${VERSAO}` ou `${SERVER_PORT}`. Se essas vari√°veis estiverem definidas no ambiente onde o `docker-compose` √© executado (ou em um arquivo `.env`), elas ser√£o substitu√≠das. A substitui√ß√£o via `sed` √© uma abordagem, mas est√° longe de ser a √∫nica ou a mais limpa.<br/><br/>**Feynman/Dica üéØ:** A banca te diz que a √∫nica forma de mudar o sabor do seu caf√© √© adicionando a√ß√∫car (`sed`) antes de servir. Isso √© falso. O pr√≥prio caf√© (`Docker Compose`) pode ser feito com gr√£os diferentes (`vari√°veis de ambiente`) para mudar o sabor desde o in√≠cio. O `sed` √© uma forma de customiza√ß√£o, mas n√£o a √∫nica.                                                                                                                   |
| 126 | O comando `docker logout $CI_REGISTRY` ao final do `script` de deploy √© uma etapa de seguran√ßa crucial. Ele remove as credenciais de login do GitLab Container Registry do arquivo de configura√ß√£o do Docker no servidor remoto, garantindo que o token de curta dura√ß√£o n√£o permane√ßa no disco, minimizando a janela de exposi√ß√£o em caso de comprometimento do servidor.                                                                                                                      | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve uma excelente pr√°tica de higiene de seguran√ßa. Embora os tokens usados possam ser de curta dura√ß√£o, √© sempre melhor remover explicitamente as credenciais de qualquer lugar onde elas n√£o s√£o mais necess√°rias. Fazer o `logout` garante uma limpeza imediata, em vez de depender da expira√ß√£o do token ou da limpeza de arquivos de configura√ß√£o.<br/><br/>**Feynman/Dica üéØ:** √â como sair de casa e ter certeza de que voc√™ n√£o apenas fechou a porta, mas tamb√©m a trancou. O `docker logout` √© o ato de "trancar a porta", garantindo que ningu√©m que encontre a chave (`token`, se ele vazar de alguma forma) consiga entrar depois que voc√™ j√° foi embora.                                                                                                                                                                                                                                                              |
| 127 | O job `deploy to prod` herda o `script` de `.deploy-script`, que executa o `docker compose up -d`. Isso significa que todos os servi√ßos definidos no `docker-compose-frontend.yml`, como GeoServer, RabbitMQ e Prometheus, s√£o implantados no servidor de produ√ß√£o, mesmo que o pipeline atual tenha sido acionado apenas por uma mudan√ßa no c√≥digo da API frontend.                                                                                                                            | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o analisa corretamente a consequ√™ncia do design do pipeline. Como o deploy opera no n√≠vel do arquivo `docker-compose`, ele ir√° reconciliar o estado de **toda** a stack definida naquele arquivo. O pipeline n√£o possui uma l√≥gica granular para fazer deploy apenas do servi√ßo que mudou. Ele implanta ou atualiza o conjunto inteiro de servi√ßos, o que √© uma caracter√≠stica (e uma limita√ß√£o) dessa abordagem de deploy.<br/><br/>**Feynman/Dica üéØ:** O script de deploy √© como um "plano de montagem" de um kit de Lego inteiro. Mesmo que voc√™ s√≥ tenha recebido uma pecinha nova (`mudan√ßa no c√≥digo`), o manual manda voc√™ verificar e montar o kit inteiro de novo para garantir que tudo se encaixe. Ele n√£o tem um manual para trocar s√≥ uma pecinha.                                                                                                                                                                          |
| 128 | A estrutura de `rules` nos jobs de deploy cria uma associa√ß√£o estrita: branches sempre disparam deploy para homologa√ß√£o (`hml`), enquanto tags espec√≠ficas sempre disparam deploy para produ√ß√£o (`prod`). Este design impede que uma tag seja acidentalmente implantada em `hml` ou que um branch de feature seja implantado em `prod`, fornecendo uma separa√ß√£o clara de ambientes.                                                                                                            | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o interpreta com precis√£o a l√≥gica de governan√ßa implementada pelas regras. As condi√ß√µes s√£o mutuamente exclusivas e mapeiam rigorosamente o tipo de refer√™ncia Git (branch vs. tag) para o ambiente de destino. Este √© um padr√£o de design de pipeline robusto e seguro para controlar o fluxo de releases.<br/><br/>**Feynman/Dica üéØ:** As regras criam "corredores" bem definidos. O corredor dos "rascunhos" (`branches`) sempre leva para a sala de "ensaio" (`hml`). O corredor das "vers√µes finais" (`tags`) sempre leva para o "palco principal" (`prod`). √â imposs√≠vel pegar um corredor e sair na sala errada.                                                                                                                                                                                                                                                                                                                 |
| 129 | O uso da vari√°vel `$SSH_JENKINS_RSA_ID` para a chave SSH de deploy sugere uma poss√≠vel migra√ß√£o ou coexist√™ncia com um sistema Jenkins. O nome da vari√°vel indica que a mesma chave pode estar sendo usada por jobs do Jenkins, o que pode representar um risco de seguran√ßa se a chave n√£o tiver um escopo restrito e for compartilhada entre m√∫ltiplos sistemas de automa√ß√£o com diferentes n√≠veis de seguran√ßa.                                                                              | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o faz uma infer√™ncia de seguran√ßa e arquitetura muito perspicaz baseada apenas no nome de uma vari√°vel. A reutiliza√ß√£o de segredos entre sistemas diferentes (GitLab e Jenkins) √© geralmente desaconselhada, pois aumenta a "superf√≠cie de ataque". Se um sistema for comprometido, o segredo compartilhado pode ser usado para comprometer o outro. O nome da vari√°vel √© um "code smell" que indica um potencial ponto fraco na gest√£o de segredos.<br/><br/>**Feynman/Dica üéØ:** O nome da vari√°vel √© uma pista que o "detetive" da seguran√ßa n√£o pode ignorar. Se a chave da sua casa tamb√©m abre a casa do seu vizinho (`Jenkins`), e o seu vizinho √© meio descuidado com a seguran√ßa dele, um ladr√£o que entrar na casa dele pode usar a mesma chave para entrar na sua. Chaves (e segredos) devem ser √∫nicas sempre que poss√≠vel.                                                                                                   |
| 130 | A linha `before_script: - chmod 400 $SSH_JENKINS_RSA_ID` no `.deploy-script` √© necess√°ria porque o cliente SSH, por seguran√ßa, se recusa a usar uma chave privada que tenha permiss√µes muito abertas. A permiss√£o `400` (leitura apenas para o propriet√°rio) √© a mais restritiva poss√≠vel e √© o que o cliente SSH exige para considerar a chave segura.                                                                                                                                         | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o descreve com precis√£o um requisito de seguran√ßa fundamental do cliente OpenSSH. Se uma chave privada puder ser lida por outros usu√°rios no sistema, ela √© considerada comprometida. O comando `chmod 400` garante que as permiss√µes estejam corretas antes de tentar usar a chave, evitando um erro comum em ambientes de CI onde os arquivos s√£o criados com permiss√µes padr√£o.<br/><br/>**Feynman/Dica üéØ:** O SSH √© um seguran√ßa muito desconfiado. Se voc√™ entrega a ele a chave da porta principal (`chave privada`), mas ele percebe que c√≥pias dessa chave est√£o espalhadas pela recep√ß√£o (`permiss√µes abertas`), ele se recusa a usar a chave e n√£o abre a porta. Ele exige que a chave seja mantida em um local seguro, onde s√≥ voc√™ tem acesso (`permiss√£o 400`).                                                                                                                                                             |
| 131 | A presen√ßa de linhas comentadas como `# - scp ... $DOT_ENV ...` sugere que o pipeline pode ter sido adaptado ou que existem m√∫ltiplas estrat√©gias de configura√ß√£o. A decis√£o de comentar a c√≥pia do arquivo `.env` pode indicar que a configura√ß√£o agora √© gerenciada exclusivamente por vari√°veis de ambiente passadas para o comando `docker compose` no servidor, uma abordagem geralmente mais flex√≠vel.                                                                                    | V                                                                                                                                                                                                                                                                                                             | **Formal:** A an√°lise do c√≥digo comentado √© uma forma de "arqueologia de software" que revela a evolu√ß√£o do pipeline. A mudan√ßa de uma estrat√©gia baseada em arquivos de ambiente (`.env`) para uma baseada em vari√°veis de ambiente injetadas no comando `docker compose` √© uma transi√ß√£o comum. A abordagem de vari√°veis √© muitas vezes preferida em automa√ß√£o por ser mais expl√≠cita e n√£o deixar arquivos de configura√ß√£o sens√≠veis no disco do servidor de destino.<br/><br/>**Feynman/Dica üéØ:** O c√≥digo comentado √© o "rascunho" que o autor deixou para tr√°s. Ele nos conta que, no passado, eles pensaram em levar uma "mochila" de configura√ß√µes (`arquivo .env`). Agora, eles preferem dar as instru√ß√µes verbalmente (`vari√°veis de ambiente`) quando chegam ao destino. Isso mostra uma mudan√ßa de t√°tica.                                                                                                                                         |
| 132 | O comando `sed -i 's/VUE_APP_...` no job `build docker image` modifica o arquivo `.env.prod` no ambiente do runner antes do build da imagem. Isso implica que o Dockerfile subsequente provavelmente tem um comando `COPY .env.prod .env` ou similar, fazendo com que as configura√ß√µes modificadas sejam "assadas" (baked in) diretamente na imagem Docker.                                                                                                                                     | V                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o deduz corretamente o fluxo de dados impl√≠cito. A modifica√ß√£o de um arquivo de configura√ß√£o com `sed` s√≥ faz sentido se esse arquivo modificado for subsequentemente copiado para dentro da imagem durante o processo de `docker build`. Esta √© uma estrat√©gia para criar imagens auto-contidas para um ambiente espec√≠fico, embora a pr√°tica mais moderna seja criar imagens gen√©ricas e configur√°-las em tempo de execu√ß√£o.<br/><br/>**Feynman/Dica üéØ:** O pipeline age como um chef que altera a receita (`.env.prod`) *antes* de assar o bolo (`imagem Docker`). O resultado √© um bolo que j√° sai do forno com um sabor espec√≠fico (`configura√ß√£o de produ√ß√£o`). Ele n√£o √© um bolo gen√©rico que voc√™ tempera depois. A modifica√ß√£o antes do build √© a chave para essa dedu√ß√£o.                                                                                                                                                      |
| 133 | A l√≥gica de `rules` no job `deploy to prod` permite o deploy de qualquer tag Git. Isso representa um risco, pois uma tag criada em um commit antigo ou em um branch de feature poderia ser implantada em produ√ß√£o. Uma regra mais segura incluiria uma verifica√ß√£o adicional, como `if: '$CI_COMMIT_TAG && $CI_COMMIT_BRANCH == "main"'`, para garantir que a tag foi criada a partir do branch principal.                                                                                      | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o identifica um risco potencial, mas a premissa de que a regra `if: '$CI_COMMIT_TAG && $CI_COMMIT_BRANCH == "main"'` funcionaria √© falsa, e essa √© a pegadinha. Quando um pipeline roda para uma tag, a vari√°vel `$CI_COMMIT_BRANCH` fica **vazia**. Portanto, essa regra nunca seria satisfeita. A forma correta de restringir tags a um branch espec√≠fico √© usar "Protected Tags", que podem ser configuradas para permitir a cria√ß√£o apenas a partir de branches espec√≠ficos, como o `main`.<br/><br/>**Feynman/Dica üéØ:** A banca te oferece uma fechadura que parece segura, mas que na verdade n√£o funciona. A vari√°vel `$CI_COMMIT_BRANCH` e `$CI_COMMIT_TAG` s√£o como √°gua e √≥leo quando se trata de pipelines; elas geralmente n√£o coexistem. A solu√ß√£o para o risco apontado n√£o est√° no `.gitlab-ci.yml`, mas na configura√ß√£o do reposit√≥rio (`Protected Tags`). √â um teste de conhecimento profundo sobre as vari√°veis de CI. |
| 134 | A presen√ßa de um `sleep 4` no comando `(docker compose ... down && sleep 4)                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                               | echo 0` √© provavelmente uma medida de estabilidade. Ela for√ßa uma pausa de 4 segundos ap√≥s desligar os cont√™ineres e antes que o pr√≥ximo comando (o `up`) seja executado, para dar tempo ao sistema operacional e ao Docker daemon de liberarem recursos de rede, como portas, prevenindo erros de "porta j√° em uso".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | V | **Formal:** A afirma√ß√£o faz uma infer√™ncia t√©cnica muito prov√°vel e correta. Em sistemas complexos, recursos de rede n√£o s√£o sempre liberados instantaneamente. Adicionar um pequeno `sleep` √© uma "solu√ß√£o de batalha" comum e pragm√°tica para evitar condi√ß√µes de corrida (race conditions) durante um ciclo de `down`/`up`, garantindo que o sistema esteja em um estado limpo antes de tentar iniciar os novos cont√™ineres.<br/><br/>**Feynman/Dica üéØ:** √â como esperar alguns segundos depois de desligar um aparelho eletr√¥nico antes de lig√°-lo novamente para garantir que ele "zerou" completamente. O `sleep 4` √© essa pequena pausa de cortesia que voc√™ d√° ao sistema para ele respirar fundo antes da pr√≥xima tarefa, evitando que ele se engasgue. |
| 135 | A combina√ß√£o de `tags: [DOCKERBUILD]` e `extends: .deploy-script` em um mesmo job n√£o √© permitida pelo GitLab, pois a diretiva `tags` de um job sobrescreve completamente as tags do template herdado, e um template n√£o pode for√ßar a execu√ß√£o em um runner espec√≠fico que o job que o estende n√£o tenha permiss√£o para usar.                                                                                                                                                                  | F                                                                                                                                                                                                                                                                                                             | **Formal:** A afirma√ß√£o √© falsa. A heran√ßa com `extends` funciona perfeitamente com a diretiva `tags`. As tags do job que estende s√£o mescladas com (ou sobrescrevem) as tags do template, seguindo as regras de mesclagem de YAML. √â um cen√°rio v√°lido ter um script de deploy gen√©rico e cada job de deploy espec√≠fico (hml, prod) definir em qual runner (atrav√©s de tags) ele deve ser executado.<br/><br/>**Feynman/Dica üéØ:** A banca inventou uma regra que n√£o existe. O mecanismo de `extends` do GitLab √© projetado para ser flex√≠vel. Pense no template como um "conjunto de roupas" e a tag como o "local da festa". Voc√™ pode pegar o mesmo conjunto de roupas (`extends .deploy-script`) e decidir us√°-lo em uma festa na praia (`tags: [shared]`) ou em uma festa na montanha (`tags: [DOCKERBUILD]`). A combina√ß√£o √© totalmente permitida.                                                                                                      |

