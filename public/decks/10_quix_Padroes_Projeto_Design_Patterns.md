| id | afirma√ß√£o                                                                                                                                                                                                                                  | resposta | explica√ß√£o                                                                                                                                                                                                                                                              |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | O padr√£o de projeto Singleton assegura que uma classe possua m√∫ltiplas inst√¢ncias, cada uma com um ponto de acesso global distinto, sendo ideal para objetos que necessitam de v√°rios estados independentes.                               | F        | ‚ùå O Singleton garante **uma √∫nica inst√¢ncia** e um **√∫nico ponto de acesso global**. A ideia √© justamente controlar a instancia√ß√£o para ter apenas um objeto. Pegadinha: a banca inverteu o conceito de unicidade. (Cap. Singleton, p. 149)                             |
| 2  | No padr√£o Strategy, o contexto delega a execu√ß√£o de um algoritmo para um objeto estrat√©gia, sendo o contexto respons√°vel por selecionar a estrat√©gia apropriada com base em condicionais internas.                                         | F        | parcialmente. O contexto delega, mas a sele√ß√£o da estrat√©gia √© geralmente feita pelo **cliente** que passa a estrat√©gia desejada ao contexto. O contexto em si n√£o costuma ter a l√≥gica de sele√ß√£o. üí° (Cap. Strategy, p. 394)                                          |
| 3  | O padr√£o Factory Method define uma interface para criar objetos em uma superclasse, mas permite que as subclasses alterem o tipo de objetos que ser√£o criados, promovendo o desacoplamento.                                                | V        | ‚úÖ Correto! O Factory Method √© sobre delegar a instancia√ß√£o para subclasses, permitindo flexibilidade na cria√ß√£o de objetos sem que a superclasse precise conhecer os tipos concretos. (Cap. Factory Method, p. 83)                                                      |
| 4  | O Princ√≠pio de Invers√£o de Depend√™ncia (DIP) sugere que m√≥dulos de alto n√≠vel devem depender de m√≥dulos de baixo n√≠vel, e ambos devem depender de abstra√ß√µes para maior flexibilidade.                                                     | F        | ‚ùå O DIP postula que m√≥dulos de alto n√≠vel **n√£o devem** depender de m√≥dulos de baixo n√≠vel. **Ambos** devem depender de abstra√ß√µes. Detalhes devem depender de abstra√ß√µes. A banca inverteu a primeira parte! üîÑ (Cap. Princ√≠pio de invers√£o de depend√™ncia, p. 73)     |
| 5  | O padr√£o Decorator permite adicionar novos comportamentos a objetos dinamicamente, envolvendo-os em objetos especiais que possuem a mesma interface do objeto original, sem alterar sua estrutura interna.                                 | V        | ‚úÖ Perfeito! O Decorator "embrulha" objetos para adicionar funcionalidades de forma flex√≠vel, mantendo a interface. Pense em "vestir" o objeto com novas camadas. üß• (Cap. Decorator, p. 208)                                                                            |
| 6  | O padr√£o Adapter √© utilizado exclusivamente para converter dados entre formatos incompat√≠veis, como `XML` para `JSON`, e n√£o se aplica a cen√°rios de incompatibilidade de interfaces entre objetos.                                        | F        | ‚ùå O Adapter serve tanto para convers√£o de dados (ex: `XML` para `JSON`) quanto para fazer interfaces incompat√≠veis de objetos colaborarem. A afirma√ß√£o restringe indevidamente seu uso. üîå (Cap. Adapter, p. 165-166)                                                   |
| 7  | No padr√£o Memento, o objeto Originador √© respons√°vel por criar e restaurar seu pr√≥prio estado a partir de um Memento, enquanto o Cuidador armazena os Mementos sem modificar seu conte√∫do.                                                 | V        | ‚úÖ Exato! O Originador conhece seu estado e como salv√°-lo/restaur√°-lo. O Memento √© o "retrato" do estado. O Cuidador apenas guarda os retratos (Mementos) sem alter√°-los. üì∏ (Cap. Memento, p. 348)                                                                      |
| 8  | O padr√£o Composite permite tratar objetos individuais e composi√ß√µes de objetos de maneira uniforme, desde que todos os objetos na estrutura em √°rvore implementem m√©todos de `add()` e `remove()`.                                         | F        | ‚ùå A primeira parte est√° correta (tratamento uniforme). Contudo, nem todos os elementos (especialmente as "folhas") precisam implementar `add()`/`remove()`. For√ßar isso violaria o Princ√≠pio de Segrega√ß√£o de Interface. (Cap. Composite, p. 196, 205 - Pr√≥s e Contras) |
| 9  | O Princ√≠pio Aberto/Fechado (OCP) estabelece que entidades de software (classes, m√≥dulos) devem estar abertas para extens√£o, mas fechadas para modifica√ß√£o, significando que √© prefer√≠vel adicionar novo c√≥digo a alterar c√≥digo existente. | V        | ‚úÖ Correto! O OCP visa minimizar o risco de quebrar c√≥digo existente ao introduzir novas funcionalidades. Estende-se com novas classes/m√≥dulos, mas o c√≥digo original testado permanece intocado. üõ°Ô∏è (Cap. Princ√≠pio aberto/fechado, p. 59)                             |
| 10 | O padr√£o Observer define uma depend√™ncia um-para-muitos entre objetos, onde um objeto (o Sujeito/Publicador) notifica automaticamente todos os seus dependentes (Observadores/Assinantes) sobre quaisquer mudan√ßas de estado que ocorram.  | V        | ‚úÖ Perfeito! √â a ess√™ncia do Observer: um publicador notifica m√∫ltiplos assinantes sobre eventos ou mudan√ßas de estado, permitindo um acoplamento fraco. üì∞ (Cap. Observer, p. 361)                                                                                      |
| 11 | No cap√≠tulo "B√°sico da POO", a heran√ßa √© apresentada como um mecanismo onde uma subclasse herda apenas o comportamento (m√©todos) de sua superclasse, mas n√£o seu estado (campos).                                 | F        | ‚ùå Incorreto. A heran√ßa permite que subclasses herdem **tanto estado (campos) quanto comportamento (m√©todos)** de sua superclasse. A banca tentou te pegar na defini√ß√£o b√°sica! (Cap. B√°sico da POO, p. 16)                                                                                                      |
| 12 | Segundo o cap√≠tulo "Pilares da POO", o Polimorfismo √© a capacidade de um programa detectar a classe real de um objeto e chamar sua implementa√ß√£o espec√≠fica, mesmo quando o tipo real √© desconhecido no contexto. | V        | ‚úÖ Correto! Polimorfismo √© tratar objetos de diferentes classes de forma uniforme atrav√©s de uma interface comum, e o comportamento espec√≠fico da classe real √© invocado. üêæ (Cap. Pilares da POO, p. 24)                                                                                                        |
| 13 | Abstra√ß√£o, um dos pilares da POO, significa modelar objetos do programa com 100% de precis√£o em rela√ß√£o aos objetos do mundo real, incluindo todos os seus detalhes, independentemente do contexto.               | F        | ‚ùå Falso. A abstra√ß√£o foca em representar os **detalhes relevantes** para um contexto espec√≠fico, omitindo o resto. Modelar com 100% de precis√£o raramente √© necess√°rio ou vi√°vel. üéØ (Cap. Pilares da POO, p. 19)                                                                                               |
| 14 | O Encapsulamento, conforme descrito em "Pilares da POO", √© a habilidade de um objeto de expor todos os seus estados e comportamentos para outros objetos, facilitando a intera√ß√£o direta e irrestrita.            | F        | ‚ùå Ao contr√°rio! Encapsulamento visa **esconder** parte do estado e comportamento, expondo apenas uma interface limitada. A ideia √© proteger os dados internos. üõ°Ô∏è (Cap. Pilares da POO, p. 19-20)                                                                                                              |
| 15 | Em "Rela√ß√µes entre objetos", a Composi√ß√£o √© descrita como um tipo de associa√ß√£o onde o componente pode existir independentemente do cont√™iner e pode ser ligado a v√°rios cont√™ineres ao mesmo tempo.              | F        | ‚ùå Essa descri√ß√£o se encaixa melhor na **Agrega√ß√£o**. Na Composi√ß√£o, o componente s√≥ pode existir como parte de um cont√™iner e seu ciclo de vida √© gerenciado por ele. A banca trocou os conceitos! üîÑ (Cap. Rela√ß√µes entre objetos, p. 28)                                                                      |
| 16 | O cap√≠tulo "O que √© um padr√£o de projeto?" afirma que um padr√£o de projeto √© um peda√ßo de c√≥digo espec√≠fico que pode ser copiado e colado diretamente em qualquer programa para resolver um problema comum.       | F        | ‚ùå Incorreto. Um padr√£o de projeto √© um **conceito geral**, uma solu√ß√£o t√≠pica, e n√£o um c√≥digo pronto. Ele precisa ser adaptado e implementado de acordo com o contexto do programa. üõ†Ô∏è (Cap. O que √© um padr√£o de projeto?, p. 32)                                                                            |
| 17 | Os padr√µes criacionais, conforme a classifica√ß√£o apresentada, fornecem mecanismos para criar objetos de forma a aumentar a flexibilidade e a reutiliza√ß√£o do c√≥digo existente.                                    | V        | ‚úÖ Verdadeiro! Os padr√µes criacionais (Factory Method, Abstract Factory, Builder, Prototype, Singleton) focam em como os objetos s√£o instanciados, promovendo flexibilidade. üè≠ (Cap. Classifica√ß√£o dos padr√µes, p. 34)                                                                                          |
| 18 | O "Princ√≠pio de responsabilidade √∫nica" (SRP) estabelece que uma classe deve ter m√∫ltiplas raz√µes para mudar, desde que essas raz√µes estejam relacionadas ao mesmo dom√≠nio de neg√≥cio.                            | F        | ‚ùå Falso! O SRP preconiza que uma classe deve ter **apenas uma raz√£o para mudar**. M√∫ltiplas responsabilidades aumentam a complexidade e a chance de quebras. üéØ (Cap. Princ√≠pio de responsabilidade √∫nica, p. 57)                                                                                               |
| 19 | O princ√≠pio "Prefira composi√ß√£o sobre heran√ßa" sugere que a heran√ßa deve ser evitada a todo custo, mesmo quando representa uma clara rela√ß√£o "√© um(a)" e n√£o introduz acoplamento excessivo.                      | F        | ‚ùå Incorreto. O princ√≠pio sugere **preferir** composi√ß√£o, mas n√£o eliminar a heran√ßa. A heran√ßa ainda √© √∫til em cen√°rios apropriados. A composi√ß√£o √© uma alternativa para evitar problemas comuns da heran√ßa, como acoplamento forte e hierarquias r√≠gidas. ü§î (Cap. Prefira composi√ß√£o sobre heran√ßa, p. 52-53) |
| 20 | O Princ√≠pio de Substitui√ß√£o de Liskov (LSP) implica que objetos de uma superclasse devem ser substitu√≠veis por objetos de suas subclasses sem quebrar a corretude do programa.                                    | V        | ‚úÖ Correto! O LSP √© fundamental para garantir que a heran√ßa seja usada de forma consistente e que as subclasses possam realmente substituir suas superclasses sem causar comportamentos inesperados. üîÑ (Cap. Princ√≠pio de substitui√ß√£o de Liskov, p. 63)                                                        |
| 21 | No padr√£o Abstract Factory, as f√°bricas concretas devem, obrigatoriamente, retornar produtos que herdam de uma √∫nica classe base de produto, n√£o podendo utilizar interfaces para definir os produtos.            | F        | ‚ùå Falso. Os produtos retornados por uma Abstract Factory geralmente seguem **interfaces abstratas** de produto, permitindo maior flexibilidade e desacoplamento do que a heran√ßa de uma √∫nica classe base. üé® (Cap. Abstract Factory, p. 101-102)                                                               |
| 22 | O padr√£o Builder √© ideal para construir objetos simples com poucos par√¢metros de inicializa√ß√£o, pois sua principal vantagem √© a redu√ß√£o da complexidade em cen√°rios de constru√ß√£o diretos.                        | F        | ‚ùå Ao contr√°rio! O Builder brilha na constru√ß√£o de **objetos complexos** passo a passo, especialmente quando h√° muitos par√¢metros opcionais ou diferentes representa√ß√µes do mesmo objeto. üèóÔ∏è (Cap. Builder, p. 115)                                                                                             |
| 23 | O padr√£o Prototype permite copiar objetos existentes sem que o c√≥digo cliente dependa das classes concretas desses objetos, utilizando um m√©todo de clonagem geralmente presente na interface do prot√≥tipo.       | V        | ‚úÖ Verdadeiro! O Prototype delega a clonagem ao pr√≥prio objeto, e o cliente interage atrav√©s de uma interface de prot√≥tipo, evitando depend√™ncia de classes concretas. üêë (Cap. Prototype, p. 136)                                                                                                               |
| 24 | O padr√£o Bridge tem como objetivo principal fundir uma hierarquia de classes grande em uma √∫nica superclasse para simplificar a estrutura e facilitar a manuten√ß√£o.                                               | F        | ‚ùå O Bridge faz o oposto: ele **divide** uma classe grande ou um conjunto de classes intimamente ligadas em duas hierarquias separadas (abstra√ß√£o e implementa√ß√£o) para que possam evoluir independentemente. üåâ (Cap. Bridge, p. 179)                                                                           |
| 25 | O padr√£o Flyweight visa reduzir o uso de mem√≥ria ao compartilhar partes comuns do estado entre m√∫ltiplos objetos, sendo que o estado restante (extr√≠nseco) √© passado aos m√©todos do flyweight quando necess√°rio.  | V        | ‚úÖ Correto! O Flyweight √© uma otimiza√ß√£o para cen√°rios com muitos objetos similares, economizando mem√≥ria ao compartilhar o estado intr√≠nseco e tratar o estado extr√≠nseco externamente. üçÉ (Cap. Flyweight, p. 240-241)                                                                                         |
| 26 | O padr√£o Proxy fornece um substituto ou placeholder para outro objeto, controlando o acesso a ele. Um proxy sempre ter√° uma interface diferente do objeto de servi√ßo original.                                    | F        | ‚ùå A segunda parte √© falsa. Um Proxy geralmente implementa a **mesma interface** do objeto de servi√ßo original, permitindo que o cliente trate ambos de forma intercambi√°vel. üé≠ (Cap. Proxy, p. 254, 256)                                                                                                       |
| 27 | No padr√£o Chain of Responsibility, um pedido √© sempre processado por todos os handlers na corrente, mesmo que um handler anterior j√° tenha lidado completamente com o pedido.                                     | F        | ‚ùå Falso. Um handler na corrente pode decidir **n√£o passar** o pedido adiante se ele o processou completamente ou se decidir que o processamento deve parar ali. üîó‚û°Ô∏èüõë (Cap. Chain of Responsibility, p. 279)                                                                                                   |
| 28 | O padr√£o Command transforma um pedido em um objeto autocontido, permitindo parametrizar m√©todos com diferentes pedidos, enfileirar pedidos ou suportar opera√ß√µes de desfazer.                                     | V        | ‚úÖ Exatamente! O Command encapsula toda a informa√ß√£o de um pedido, permitindo grande flexibilidade em como e quando ele √© executado, al√©m de facilitar o hist√≥rico e o "desfazer". üìú (Cap. Command, p. 294)                                                                                                     |
| 29 | O padr√£o Iterator visa expor a representa√ß√£o interna de uma cole√ß√£o para que o cliente possa implementar algoritmos de travessia mais eficientes e customizados.                                                  | F        | ‚ùå O Iterator visa **esconder** a representa√ß√£o interna da cole√ß√£o, fornecendo uma interface uniforme para percorrer seus elementos sem que o cliente precise conhecer a estrutura subjacente. üö∂‚Äç‚ôÇÔ∏è (Cap. Iterator, p. 316)                                                                                     |
| 30 | O padr√£o Mediator promove o acoplamento direto entre componentes, permitindo que eles se comuniquem livremente para otimizar a performance e reduzir a necessidade de um objeto intermedi√°rio.                    | F        | ‚ùå O Mediator faz o oposto: ele **reduz** o acoplamento direto, for√ßando os componentes a se comunicarem atrav√©s de um objeto mediador central, o que simplifica as intera√ß√µes complexas. üó£Ô∏è (Cap. Mediator, p. 331)                                                                                            |
| 31 | O padr√£o State permite que um objeto altere seu comportamento quando seu estado interno muda, fazendo com que pare√ßa que o objeto mudou de classe. Cada estado √© encapsulado em sua pr√≥pria classe.               | V        | ‚úÖ Correto! O State permite que um objeto exiba diferentes comportamentos baseados em seu estado interno, delegando o comportamento espec√≠fico para classes de estado separadas. üé≠ (Cap. State, p. 376)                                                                                                         |
| 32 | No padr√£o Template Method, o esqueleto de um algoritmo √© definido em uma superclasse, e as subclasses s√£o for√ßadas a sobrescrever todo o algoritmo, incluindo sua estrutura principal.                            | F        | ‚ùå Falso. As subclasses sobrescrevem apenas **etapas espec√≠ficas** do algoritmo. A estrutura principal (o "template method" em si) definida na superclasse geralmente n√£o √© sobrescrita. üèóÔ∏è (Cap. Template Method, p. 407)                                                                                      |
| 33 | O padr√£o Visitor √© utilizado para adicionar novas opera√ß√µes a uma hierarquia de classes existente sem modificar as classes dessa hierarquia, encapsulando a nova opera√ß√£o em um objeto visitante.                 | V        | ‚úÖ Perfeito! O Visitor permite adicionar funcionalidades a uma estrutura de objetos sem alter√°-los, usando o mecanismo de "double dispatch" para executar a opera√ß√£o correta para cada tipo de elemento. üö∂‚Äç‚ôÄÔ∏èüö™ (Cap. Visitor, p. 420)                                                                          |
| 34 | O Princ√≠pio de Segrega√ß√£o de Interface (ISP) defende a cria√ß√£o de interfaces grandes e coesas, para que os clientes tenham acesso a todas as funcionalidades poss√≠veis de uma vez, mesmo que n√£o utilizem todas.  | F        | ‚ùå O ISP prega o contr√°rio: clientes **n√£o devem ser for√ßados a depender de interfaces que n√£o usam**. Interfaces devem ser pequenas e espec√≠ficas (granulares). üß© (Cap. Princ√≠pio de segrega√ß√£o de interface, p. 70)                                                                                           |
| 35 | O padr√£o Facade simplifica a intera√ß√£o com um subsistema complexo, fornecendo uma interface de alto n√≠vel que delega as chamadas para os objetos apropriados dentro do subsistema.                                | V        | ‚úÖ Exatamente! O Facade atua como uma "fachada" para um sistema complexo, tornando-o mais f√°cil de usar ao expor apenas as funcionalidades relevantes para o cliente. üèõÔ∏è (Cap. Facade, p. 229)                                                                                                                  |
| 36 | No Factory Method, a superclasse define um m√©todo f√°brica que retorna um tipo de produto abstrato, e as subclasses concretas devem obrigatoriamente retornar o mesmo tipo de produto concreto definido na superclasse.   | F        | ‚ùå As subclasses **alteram** o tipo de produto concreto retornado, desde que seja compat√≠vel com a interface/classe base do produto. A superclasse define o *contrato* de cria√ß√£o, n√£o o produto concreto exato. (Cap. Factory Method, p. 85)                                                         |
| 37 | Uma das principais vantagens do Factory Method √© que ele permite introduzir novos tipos de produtos no programa sem modificar o c√≥digo cliente que utiliza a f√°brica.                                                    | V        | ‚úÖ Verdadeiro! O cliente interage com a interface da f√°brica e a interface do produto, tornando-o independente das classes concretas. Adicionar um novo produto envolve criar uma nova subclasse de f√°brica e uma nova classe de produto. (Cap. Factory Method, p. 97 - Pr√≥s e Contras)               |
| 38 | O Factory Method √© frequentemente utilizado quando se deseja economizar recursos do sistema reutilizando objetos existentes, ao inv√©s de criar novos a cada chamada.                                                     | V        | ‚úÖ Sim, o m√©todo f√°brica pode ser implementado para retornar inst√¢ncias de um cache ou pool de objetos, al√©m de criar novas, otimizando recursos. (Cap. Factory Method, p. 94-95 - Aplicabilidade)                                                                                                    |
| 39 | Se, ap√≥s extrair a l√≥gica de cria√ß√£o para um m√©todo f√°brica, o m√©todo na classe base se tornar vazio (sem uma implementa√ß√£o padr√£o), ele deve ser mantido como um m√©todo concreto vazio para evitar erros em subclasses. | F        | ‚ùå Se o m√©todo f√°brica na classe base se torna vazio ap√≥s as extra√ß√µes, ele pode (e muitas vezes deve) ser tornado **abstrato**, for√ßando as subclasses a fornecerem uma implementa√ß√£o. (Cap. Factory Method, p. 97 - Como implementar)                                                               |
| 40 | O padr√£o Abstract Factory permite produzir fam√≠lias de objetos relacionados, como `CadeiraModerna` e `SofaModerno`, sem que o c√≥digo cliente precise especificar as classes concretas `FabricaMobiliaModerna`.           | V        | ‚úÖ Correto! O cliente usa uma interface de f√°brica abstrata para obter uma f√°brica concreta (ex: `FabricaMobiliaModerna`) e ent√£o usa essa f√°brica para criar produtos (`Cadeira`, `Sofa`) que s√£o garantidamente compat√≠veis. (Cap. Abstract Factory, p. 99, 103)                                    |
| 41 | No Abstract Factory, todas as variantes de um mesmo tipo de produto (ex: `CadeiraModerna`, `CadeiraVitoriana`) devem obrigatoriamente herdar de uma classe base comum, n√£o sendo suficiente implementar uma interface.   | F        | ‚ùå Os produtos abstratos (ex: `Cadeira`) geralmente declaram **interfaces** para um conjunto de produtos. As variantes concretas (`CadeiraModerna`, `CadeiraVitoriana`) implementam essas interfaces. Heran√ßa pode ser usada, mas interfaces s√£o mais flex√≠veis. (Cap. Abstract Factory, p. 101-102)  |
| 42 | O padr√£o Abstract Factory √© mais adequado quando o sistema precisa trabalhar com uma √∫nica fam√≠lia de produtos, e n√£o h√° previs√£o de adicionar novas fam√≠lias ou variantes no futuro.                                    | F        | ‚ùå Ao contr√°rio! O Abstract Factory brilha quando o sistema precisa lidar com **diversas fam√≠lias de produtos relacionados** e se quer permitir a f√°cil adi√ß√£o de novas fam√≠lias/variantes sem alterar o c√≥digo cliente. (Cap. Abstract Factory, p. 111 - Aplicabilidade)                             |
| 43 | Uma classe criadora no padr√£o Factory Method tem como sua principal responsabilidade a cria√ß√£o de produtos, mesmo que j√° possua l√≥gica de neg√≥cio relacionada a esses produtos.                                          | F        | ‚ùå A principal responsabilidade da classe criadora **n√£o √©** criar produtos. Ela geralmente j√° tem l√≥gica de neg√≥cio. O m√©todo f√°brica apenas **ajuda a dissociar** essa l√≥gica das classes concretas de produtos. (Cap. Factory Method, p. 89)                                                       |
| 44 | As classes Abstract Factory s√£o quase sempre baseadas em um conjunto de Factory Methods, mas tamb√©m podem utilizar o padr√£o Prototype para compor os m√©todos de cria√ß√£o de produtos.                                     | V        | ‚úÖ Verdadeiro. Uma Abstract Factory normalmente define v√°rios m√©todos f√°brica (um para cada tipo de produto na fam√≠lia). O Prototype pode ser uma alternativa ou complemento para criar as inst√¢ncias de produto dentro desses m√©todos. (Cap. Abstract Factory, p. 114 - Rela√ß√µes com outros padr√µes) |
| 45 | O padr√£o Builder permite construir objetos complexos passo a passo, mas exige que todas as etapas de constru√ß√£o sejam chamadas em uma ordem estritamente predefinida pelo cliente.                                       | F        | ‚ùå O cliente chama apenas as etapas necess√°rias para a configura√ß√£o desejada. A classe **Diretor** (opcional) pode encapsular sequ√™ncias de constru√ß√£o comuns, mas o cliente pode usar o Builder diretamente. (Cap. Builder, p. 118, 119)                                                             |
| 46 | No padr√£o Builder, o objeto produto s√≥ √© acessado pelo cliente ap√≥s todas as etapas de constru√ß√£o desejadas terem sido conclu√≠das, evitando que o cliente acesse um produto em estado incompleto.                        | V        | ‚úÖ Correto! O Builder n√£o exp√µe o produto enquanto ele est√° sendo constru√≠do. O cliente obt√©m o resultado final atrav√©s de um m√©todo como `getResult()` no builder. (Cap. Builder, p. 118)                                                                                                            |
| 47 | O uso de uma classe Diretor no padr√£o Builder √© obrigat√≥rio para definir a ordem de execu√ß√£o das etapas de constru√ß√£o e desacoplar o cliente dos builders concretos.                                                     | F        | ‚ùå O Diretor √© **opcional**. Ele √© √∫til para encapsular rotinas de constru√ß√£o complexas ou reutiliz√°veis, mas o cliente pode interagir diretamente com um builder para construir o objeto. (Cap. Builder, p. 120)                                                                                     |
| 48 | O padr√£o Builder √© particularmente √∫til para se livrar de "construtores telesc√≥picos", onde uma classe possui m√∫ltiplos construtores com diferentes combina√ß√µes de par√¢metros opcionais.                                 | V        | ‚úÖ Exato! Ao inv√©s de m√∫ltiplos construtores, o Builder permite especificar apenas os par√¢metros relevantes de forma clara, usando m√©todos dedicados para cada etapa da constru√ß√£o. (Cap. Builder, p. 129 - Aplicabilidade)                                                                           |
| 49 | Produtos constru√≠dos por diferentes Builders concretos devem, obrigatoriamente, pertencer √† mesma hierarquia de classe ou implementar a mesma interface.                                                                 | F        | ‚ùå N√£o necessariamente. Uma das flexibilidades do Builder √© que os produtos resultantes de diferentes builders concretos **n√£o precisam** seguir uma interface comum, embora possam. (Cap. Builder, p. 122 - Estrutura)                                                                               |
| 50 | O padr√£o Prototype √© baseado em heran√ßa para permitir a clonagem, exigindo que todos os prot√≥tipos concretos herdem de uma classe base `Prototype` que implementa a l√≥gica de c√≥pia.                                     | F        | ‚ùå O Prototype geralmente define uma **interface** de clonagem (ex: com um m√©todo `clone()`). As classes concretas implementam essa interface. Embora possa haver uma classe base, a heran√ßa n√£o √© o mecanismo central como no Template Method, por exemplo. (Cap. Prototype, p. 136, 139)            |
| 51 | Uma vantagem do Prototype √© a capacidade de produzir objetos complexos mais convenientemente, especialmente quando h√° muitas configura√ß√µes pr√©-determinadas que podem ser representadas por prot√≥tipos pr√©-constru√≠dos.  | V        | ‚úÖ Correto! Ao inv√©s de instanciar e configurar um objeto complexo do zero, pode-se clonar um prot√≥tipo j√° configurado e fazer pequenas altera√ß√µes, se necess√°rio. (Cap. Prototype, p. 146 - Pr√≥s e Contras)                                                                                          |
| 52 | O "Registro do Prot√≥tipo" √© uma estrutura que armazena objetos pr√©-constru√≠dos e prontos para serem clonados, sendo geralmente implementado como um `hashmap` de "nome do prot√≥tipo" para "objeto prot√≥tipo".            | V        | ‚úÖ Exato. O registro facilita o acesso a prot√≥tipos de uso frequente, permitindo que o cliente os solicite por um identificador (como um nome) e receba uma c√≥pia. (Cap. Prototype, p. 140)                                                                                                           |
| 53 | O padr√£o Singleton, ao garantir uma √∫nica inst√¢ncia de uma classe, sempre melhora a testabilidade do c√≥digo cliente, pois simplifica a cria√ß√£o de mocks e stubs para a classe Singleton.                                 | F        | ‚ùå Pelo contr√°rio, Singletons podem **dificultar** testes unit√°rios. O estado global e o construtor privado tornam mais complexo isolar e mockar a classe Singleton. (Cap. Singleton, p. 157 - Pr√≥s e Contras)                                                                                        |
| 54 | A inicializa√ß√£o pregui√ßosa (lazy initialization) no padr√£o Singleton significa que a inst√¢ncia √∫nica √© criada apenas na primeira vez que o m√©todo de acesso (ex: `getInstance()`) √© chamado.                             | V        | ‚úÖ Verdadeiro! Isso evita a cria√ß√£o desnecess√°ria da inst√¢ncia se ela nunca for utilizada durante a execu√ß√£o do programa. (Cap. Singleton, p. 155 - Como implementar)                                                                                                                                 |
| 55 | O padr√£o Singleton pode ser utilizado para implementar um objeto Facade, pois frequentemente uma √∫nica inst√¢ncia do Facade √© suficiente para interagir com um subsistema.                                                | V        | ‚úÖ Sim, √© comum que um Facade seja implementado como um Singleton, j√° que geralmente n√£o h√° necessidade de m√∫ltiplas inst√¢ncias da fachada para um mesmo subsistema. (Cap. Singleton, p. 157 - Rela√ß√µes com outros padr√µes)                                                                           |
| 56 | O padr√£o Adapter, na sua varia√ß√£o "Adaptador de Classe", utiliza heran√ßa m√∫ltipla (quando a linguagem suporta) para herdar interfaces tanto do cliente quanto do servi√ßo, realizando a adapta√ß√£o nos m√©todos sobrescritos.  | V        | ‚úÖ Correto! O Adaptador de Classe herda de ambas as classes (ou implementa ambas as interfaces) e a adapta√ß√£o ocorre nos m√©todos que ele sobrescreve/implementa. (Cap. Adapter, p. 171)                                                                                                                               |
| 57 | A principal diferen√ßa entre o padr√£o Adapter e o Decorator √© que o Adapter adiciona novas responsabilidades a um objeto, enquanto o Decorator apenas modifica sua interface para compatibilidade.                           | F        | ‚ùå √â o oposto! O **Decorator adiciona responsabilidades** mantendo a interface, enquanto o **Adapter modifica a interface** para torn√°-la compat√≠vel, sem necessariamente adicionar novas funcionalidades. (Cap. Adapter, p. 177 - Rela√ß√µes com outros padr√µes; Cap. Decorator, p. 226 - Rela√ß√µes com outros padr√µes) |
| 58 | O padr√£o Bridge √© ideal para ser aplicado em sistemas legados onde a modifica√ß√£o das classes existentes √© imposs√≠vel, pois ele permite adaptar interfaces incompat√≠veis sem alterar o c√≥digo original.                      | F        | ‚ùå Essa descri√ß√£o se encaixa melhor no padr√£o **Adapter**. O Bridge √© geralmente definido com anteced√™ncia, permitindo que partes de uma aplica√ß√£o evoluam independentemente, e n√£o para adaptar sistemas legados. (Cap. Bridge, p. 193 - Rela√ß√µes com outros padr√µes)                                                |
| 59 | No padr√£o Bridge, a "Abstra√ß√£o" controla a apar√™ncia ou l√≥gica de alto n√≠vel, enquanto a "Implementa√ß√£o" lida com o trabalho de baixo n√≠vel espec√≠fico da plataforma, permitindo que ambas evoluam independentemente.       | V        | ‚úÖ Exato! O Bridge desacopla uma abstra√ß√£o de sua implementa√ß√£o para que as duas possam variar independentemente. Pense em GUI (abstra√ß√£o) e API do SO (implementa√ß√£o). (Cap. Bridge, p. 181-182)                                                                                                                     |
| 60 | O padr√£o Composite permite que o cliente trate objetos "folha" e objetos "cont√™iner" de forma diferente, exigindo verifica√ß√µes de tipo para invocar m√©todos espec√≠ficos de cada um.                                         | F        | ‚ùå O Composite visa justamente permitir que o cliente trate folhas e cont√™ineres de **forma uniforme** atrav√©s de uma interface comum. O cliente n√£o precisa saber se est√° lidando com um n√≥ folha ou um n√≥ composto. (Cap. Composite, p. 196, 198-199)                                                               |
| 61 | Uma das vantagens do padr√£o Composite √© a facilidade de adicionar novos tipos de componentes (tanto folhas quanto cont√™ineres) √† estrutura em √°rvore sem quebrar o c√≥digo cliente existente.                                | V        | ‚úÖ Verdadeiro! Desde que os novos componentes implementem a interface comum do componente, o cliente pode trabalhar com eles sem modifica√ß√µes, seguindo o Princ√≠pio Aberto/Fechado. (Cap. Composite, p. 205 - Pr√≥s e Contras)                                                                                         |
| 62 | O padr√£o Decorator, ao envolver um objeto, sempre adiciona funcionalidades *antes* da execu√ß√£o do m√©todo do objeto envolvido, nunca permitindo adicionar comportamento *ap√≥s*.                                              | F        | ‚ùå O Decorator pode adicionar comportamento **antes, depois, ou at√© mesmo substituir completamente** a execu√ß√£o do m√©todo do objeto envolvido. Ele tem total controle sobre a delega√ß√£o. (Cap. Decorator, p. 212-213)                                                                                                 |
| 63 | O padr√£o Facade √© utilizado para aumentar a complexidade da interface de um subsistema, expondo todos os seus detalhes internos para que o cliente tenha controle granular m√°ximo.                                          | F        | ‚ùå O Facade **simplifica** a interface de um subsistema complexo, fornecendo um ponto de entrada mais f√°cil e escondendo a complexidade interna. Ele exp√µe apenas o necess√°rio. (Cap. Facade, p. 229)                                                                                                                 |
| 64 | O padr√£o Flyweight √© uma otimiza√ß√£o que s√≥ deve ser aplicada quando h√° um problema real de consumo excessivo de mem√≥ria devido a um grande n√∫mero de objetos similares.                                                     | V        | ‚úÖ Correto! O Flyweight introduz complexidade, ent√£o s√≥ vale a pena se o ganho de mem√≥ria for significativo. N√£o √© uma solu√ß√£o para todos os casos. (Cap. Flyweight, p. 245 - Estrutura, p. 249 - Aplicabilidade)                                                                                                     |
| 65 | No padr√£o Flyweight, o estado intr√≠nseco do objeto √© imut√°vel e compartilhado entre m√∫ltiplas inst√¢ncias, enquanto o estado extr√≠nseco √© √∫nico para cada contexto e passado aos m√©todos do flyweight.                       | V        | ‚úÖ Exatamente! O estado intr√≠nseco (cor, textura de uma √°rvore) √© compartilhado. O estado extr√≠nseco (posi√ß√£o x, y da √°rvore) √© espec√≠fico do contexto e fornecido externamente. (Cap. Flyweight, p. 240)                                                                                                             |
| 66 | O padr√£o Proxy, na sua varia√ß√£o "Proxy Virtual", inicializa o objeto de servi√ßo real assim que o proxy √© criado, para garantir que o servi√ßo esteja sempre pronto para uso imediato.                                        | F        | ‚ùå O Proxy Virtual implementa a **inicializa√ß√£o pregui√ßosa** (lazy initialization). O objeto de servi√ßo real s√≥ √© criado quando um cliente realmente solicita uma opera√ß√£o atrav√©s do proxy. (Cap. Proxy, p. 261 - Aplicabilidade)                                                                                    |
| 67 | O padr√£o Proxy pode ser usado para controle de acesso, onde o proxy verifica as credenciais do cliente antes de delegar uma solicita√ß√£o ao objeto de servi√ßo real.                                                          | V        | ‚úÖ Verdadeiro! Esta √© a varia√ß√£o "Proxy de Prote√ß√£o". O proxy atua como um porteiro, decidindo se o cliente tem permiss√£o para acessar o servi√ßo. (Cap. Proxy, p. 261 - Aplicabilidade)                                                                                                                               |
| 68 | No padr√£o Chain of Responsibility, cada handler na corrente deve, obrigatoriamente, processar o pedido recebido e, em seguida, pass√°-lo para o pr√≥ximo handler.                                                             | F        | ‚ùå Um handler pode decidir processar o pedido e **n√£o** pass√°-lo adiante, ou pode decidir n√£o process√°-lo e apenas pass√°-lo. A decis√£o √© de cada handler. (Cap. Chain of Responsibility, p. 279)                                                                                                                      |
| 69 | O padr√£o Command encapsula um pedido como um objeto, mas n√£o permite que esses objetos comando sejam armazenados em um hist√≥rico para implementar funcionalidades de "desfazer".                                            | F        | ‚ùå Uma das grandes utilidades do Command √© justamente facilitar a implementa√ß√£o de opera√ß√µes de "desfazer", armazenando os comandos executados (e possivelmente o estado anterior) em um hist√≥rico. (Cap. Command, p. 303, 308 - Aplicabilidade)                                                                      |
| 70 | O padr√£o Iterator permite percorrer os elementos de uma cole√ß√£o sem expor sua estrutura interna (lista, √°rvore, etc.), fornecendo uma interface comum para diferentes algoritmos de travessia.                              | V        | ‚úÖ Correto! O Iterator desacopla o cliente da estrutura espec√≠fica da cole√ß√£o, permitindo diferentes formas de travessia e diferentes tipos de cole√ß√µes serem usados de forma uniforme. (Cap. Iterator, p. 316)                                                                                                       |
| 71 | O padr√£o Mediator √© utilizado para definir um objeto que encapsula como um conjunto de objetos interagem, mas os objetos componentes ainda precisam conhecer uns aos outros para notificar o mediador.                      | F        | ‚ùå Os componentes notificam o mediador sobre seus eventos, mas eles **n√£o precisam** conhecer outros componentes. O mediador √© quem coordena as intera√ß√µes entre eles. (Cap. Mediator, p. 335 - Estrutura)                                                                                                            |
| 72 | O padr√£o Memento permite salvar e restaurar o estado anterior de um objeto (o Originador) sem violar seu encapsulamento, pois o Memento em si n√£o exp√µe o estado do Originador para outros objetos.                         | V        | ‚úÖ Exato! O Originador cria o Memento e pode restaurar seu estado a partir dele. Outros objetos (Cuidadores) podem armazenar Mementos, mas n√£o acessam seu conte√∫do interno. (Cap. Memento, p. 348)                                                                                                                   |
| 73 | O padr√£o Observer √© ideal para cen√°rios onde os assinantes precisam ser notificados em uma ordem espec√≠fica e previs√≠vel, pois o publicador gerencia uma fila de notifica√ß√£o ordenada.                                      | F        | ‚ùå A ordem de notifica√ß√£o dos assinantes no padr√£o Observer geralmente **n√£o √© garantida** e pode ser aleat√≥ria ou depender da implementa√ß√£o interna da lista de assinantes. (Cap. Observer, p. 374 - Pr√≥s e Contras)                                                                                                 |
| 74 | O padr√£o State permite que um objeto altere seu comportamento dinamicamente, mas essa mudan√ßa √© sempre iniciada pelo cliente, que deve explicitamente trocar o objeto de estado do contexto.                                | F        | ‚ùå A transi√ß√£o de estado pode ser iniciada tanto pelo contexto (baseado em alguma l√≥gica interna) quanto pelos pr√≥prios objetos de estado. O cliente n√£o √© o √∫nico iniciador. (Cap. State, p. 383 - Estrutura)                                                                                                        |
| 75 | No padr√£o Strategy, o objeto Contexto √© respons√°vel por escolher a estrat√©gia concreta mais adequada para uma determinada situa√ß√£o, baseando-se em par√¢metros internos ou no estado atual.                                  | F        | ‚ùå Geralmente, √© o **Cliente** quem fornece a estrat√©gia concreta ao Contexto. O Contexto usa a estrat√©gia fornecida, mas n√£o tem a responsabilidade de escolh√™-la. (Cap. Strategy, p. 394, 397 - Estrutura)                                                                                                          |
| 76 | O padr√£o Template Method define o esqueleto de um algoritmo em uma opera√ß√£o, adiando algumas etapas para as subclasses. Essas etapas adiadas podem ser m√©todos abstratos ou m√©todos com uma implementa√ß√£o padr√£o (ganchos). | V        | ‚úÖ Correto! O Template Method permite que subclasses customizem etapas espec√≠ficas de um algoritmo sem alterar sua estrutura geral. Ganchos (hooks) s√£o etapas opcionais com implementa√ß√£o padr√£o. (Cap. Template Method, p. 407, 409)                                                                                |
| 77 | O padr√£o Visitor permite adicionar opera√ß√µes a uma estrutura de objetos complexa (como uma √°rvore Composite) sem modificar as classes dos elementos dessa estrutura.                                                        | V        | ‚úÖ Exato! O Visitor encapsula uma opera√ß√£o a ser realizada nos elementos de uma estrutura. Ele visita cada elemento e executa a l√≥gica apropriada para o tipo do elemento. (Cap. Visitor, p. 420)                                                                                                                     |


