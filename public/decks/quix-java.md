| id  | afirma√ß√£o                                                                                                                                                                                                                                                                                                                                                | resposta | explica√ß√£o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | No contexto de prepara√ß√£o para entrevistas em grandes empresas de tecnologia, o livro "Java Coding Interview" sugere que as quest√µes apresentadas s√£o predominantemente te√≥ricas e extra√≠das de livros did√°ticos de ci√™ncia da computa√ß√£o.                                                                                                               | F        | üí° O livro enfatiza que as quest√µes s√£o "reais" e refletem o que √© "verdadeiramente sendo perguntado nas principais companhias", diferenciando-se de problemas puramente acad√™micos. üéØ **Dica de Concurseiro:** A banca CESPE/CEBRASPE adora testar a interpreta√ß√£o literal do que √© afirmado como diferencial ou prop√≥sito de um material. Aten√ß√£o aos termos "predominantemente" vs. "foco em".                                                                                                                                                                                                               |
| 2   | De acordo com o livro, um dos "O Que Tem Dentro?" (What's Inside?) √© a apresenta√ß√£o de "20 quest√µes de entrevista de programa√ß√£o, variando do b√°sico aos problemas de algoritmo mais complexos."                                                                                                                                                         | V        | ‚úÖ Esta afirma√ß√£o √© uma transcri√ß√£o direta da se√ß√£o "WHAT'S INSIDE?" do livro. üéØ **Dica de Concurseiro:** Quest√µes que citam diretamente o conte√∫do listado pela pr√≥pria obra (como sum√°rios ou se√ß√µes de "o que voc√™ vai aprender") tendem a ser verdadeiras, mas sempre verifique se n√£o h√° uma sutil distor√ß√£o.                                                                                                                                                                                                                                                                                               |
| 3   | O autor, Mr. Kotiyana, afirma no pref√°cio que o livro √© resultado de sua experi√™ncia tendo apenas estudado para entrevistas, sem nunca ter atuado como entrevistador ou coach.                                                                                                                                                                           | F        | üí° No pref√°cio, o autor declara: "I've coached and interviewed hundreds of software engineers." (Eu treinei e entrevistei centenas de engenheiros de software). üéØ **Dica de Concurseiro:** Atente-se a afirma√ß√µes sobre a experi√™ncia do autor, pois a banca pode inverter o sentido para criar uma pegadinha.                                                                                                                                                                                                                                                                                                  |
| 4   | O livro indica que a programa√ß√£o √© um processo no qual organizamos dados e usamos l√≥gica para fazer algo com esses dados, podendo estes variar de n√∫meros a personagens de videogame.                                                                                                                                                                    | V        | ‚úÖ O livro descreve programa√ß√£o como "um processo no qual organizamos dados e usamos l√≥gica para fazer algo com esses dados. Os dados s√£o tudo que um computador pode armazenar; eles podem variar de n√∫meros a personagens zumbis em um videogame." üéØ **Dica de Concurseiro:** Defini√ß√µes conceituais apresentadas no in√≠cio dos cap√≠tulos s√£o frequentemente cobradas de forma literal.                                                                                                                                                                                                                        |
| 5   | Em Java, conforme explicado no livro, classes s√£o usadas para criar objetos na mem√≥ria do computador, e cada objeto instanciado a partir de uma classe possui valores √∫nicos para seus atributos, mesmo que a classe seja a mesma.                                                                                                                       | V        | ‚úÖ O texto diz: "Classes s√£o usadas para criar objetos na mem√≥ria do computador e podem ser duplicadas para ter vida pr√≥pria... Cada zumbi [inst√¢ncia] tem valores √∫nicos para cada atributo ou elemento de dados na classe." üéØ **Dica de Concurseiro:** A rela√ß√£o entre classe (molde) e objeto (inst√¢ncia concreta com seus pr√≥prios dados) √© fundamental em OOP e um prato cheio para a banca.                                                                                                                                                                                                                |
| 6   | O conceito de heran√ßa em programa√ß√£o orientada a objetos, mencionado no livro, implica que uma subclasse (filha) n√£o pode modificar ou adicionar atributos herdados da superclasse (pai).                                                                                                                                                                | F        | üí° O livro afirma: "Para ser √∫til, o zumbi filho [subclasse] pode tamb√©m adicionar novos objetos e mudar os objetos que herdou de sua classe pai." üéØ **Dica de Concurseiro:** Heran√ßa permite especializa√ß√£o. A banca pode tentar confundir dizendo que a heran√ßa √© r√≠gida e imut√°vel. Lembre-se: a subclasse *estende* e pode *modificar/adicionar*.                                                                                                                                                                                                                                                           |
| 7   | Segundo o livro, a palavra "type" (tipo) √© usada por programadores para denotar exclusivamente os tipos predefinidos pela linguagem Java, como `int` ou `boolean`.                                                                                                                                                                                       | F        | üí° O livro explica que "Programadores usam a palavra type para denotar que tipo de dado ser√° armazenado... Existem muitos tipos predefinidos em Java... Se voc√™ adicionar a isso a habilidade de criar novos tipos de dados, os tipos de dados que podemos armazenar s√£o praticamente ilimitados." üéØ **Dica de Concurseiro:** A banca pode restringir um conceito amplo. Java permite criar tipos customizados (classes, interfaces, enums).                                                                                                                                                                    |
| 8   | Uma declara√ß√£o de vari√°vel em Java, como `int i;`, √© considerada um "statement" (instru√ß√£o) e deve ser finalizada com um ponto final, similar a uma senten√ßa em ingl√™s.                                                                                                                                                                                  | F        | üí° O livro corrige: "Cada conjunto de palavras que um programador escreve √© chamado de statement... Programadores usam um ponto e v√≠rgula (;) em vez de um ponto final para terminar o statement." üéØ **Dica de Concurseiro:** Detalhes de sintaxe b√°sica s√£o alvos f√°ceis. O ponto e v√≠rgula √© crucial em Java para delimitar instru√ß√µes.                                                                                                                                                                                                                                                                       |
| 9   | O nome de uma vari√°vel em Java, chamado identificador, pode come√ßar com um n√∫mero, como por exemplo, `int 13thInt;`.                                                                                                                                                                                                                                     | F        | üí° O livro √© claro: "Nomes de vari√°veis n√£o podem come√ßar com nenhum n√∫mero." e exemplifica `int 13thInt;` como inv√°lido. üéØ **Dica de Concurseiro:** Regras de nomea√ß√£o de identificadores s√£o cl√°ssicas. "N√£o pode come√ßar com n√∫mero" √© uma delas.                                                                                                                                                                                                                                                                                                                                                            |
| 10  | Em Java, `ADifferenceInCase` e `adifferenceincase` seriam considerados dois identificadores de vari√°veis distintos devido √† sensibilidade da linguagem ao caso (case-sensitive).                                                                                                                                                                         | V        | ‚úÖ O livro afirma: "As duas vari√°veis aqui s√£o na verdade diferentes. Linguagens case-sensitive como Java prestam aten√ß√£o ao caso de um caractere." üéØ **Dica de Concurseiro:** Case sensitivity √© uma caracter√≠stica fundamental de Java (e C, C++, etc.). A banca adora isso.                                                                                                                                                                                                                                                                                                                                   |
| 11  | O caractere `@` pode ser usado em qualquer posi√ß√£o de um identificador de vari√°vel em Java, desde que n√£o seja o √∫nico caractere.                                                                                                                                                                                                                        | F        | üí° O livro especifica: "O `@` pode ser usado somente se for o primeiro caractere no nome de uma vari√°vel." Exemplo v√°lido: `int @home;`, inv√°lido: `int noone@home;`. üéØ **Dica de Concurseiro:** Regras de exce√ß√£o como essa s√£o pegadinhas comuns. A maioria dos caracteres especiais √© proibida, mas o `@` tem essa particularidade no in√≠cio.                                                                                                                                                                                                                                                                |
| 12  | Palavras-chave (keywords) em Java, como `class` ou `public`, podem ser livremente utilizadas como nomes de vari√°veis, pois o compilador consegue distinguir o contexto de uso.                                                                                                                                                                           | F        | üí° O livro diz: "Keywords... s√£o tamb√©m nomes de vari√°veis inv√°lidos, pois j√° possuem um significado especial para o JAVA." üéØ **Dica de Concurseiro:** Palavras reservadas n√£o podem ser identificadores. √â uma regra b√°sica de quase toda linguagem de programa√ß√£o.                                                                                                                                                                                                                                                                                                                                            |
| 13  | Em Java, o escopo de uma vari√°vel declarada dentro de um m√©todo (escopo de fun√ß√£o) √© limitado a esse m√©todo, n√£o sendo acess√≠vel por outros m√©todos da mesma classe diretamente.                                                                                                                                                                         | V        | ‚úÖ O livro ilustra com o exemplo `ClassInt` (escopo de classe) e `firsttint` (escopo do m√©todo `first()`), explicando que `firsttint` s√≥ existe dentro de `first()`. üéØ **Dica de Concurseiro:** Entender escopo √© crucial. Vari√°veis locais a um m√©todo "morrem" quando o m√©todo termina.                                                                                                                                                                                                                                                                                                                        |
| 14  | O operador de igualdade em Java √© `=`, enquanto o operador de atribui√ß√£o √© `==`.                                                                                                                                                                                                                                                                         | F        | üí° O livro corrige: "H√° uma diferen√ßa entre o uso de um s√≠mbolo de igual simples e um duplo. `=` √© usado para atribuir um valor, enquanto `==` √© usado para comparar valores." üéØ **Dica de Concurseiro:** Essa √© uma das pegadinhas mais cl√°ssicas para iniciantes (e at√© para desatentos). `=` atribui, `==` compara.                                                                                                                                                                                                                                                                                          |
| 15  | Uma fun√ß√£o (m√©todo) em Java declarada com o tipo de retorno `void` n√£o pode utilizar a palavra-chave `return` em seu corpo.                                                                                                                                                                                                                              | F        | üí° O livro mostra um exemplo de fun√ß√£o `void MyFunction()` que cont√©m `return;`. Ele explica que "Esta fun√ß√£o retorna void... Neste caso, usar return ser√° bem simples." O `return;` em um m√©todo `void` causa a sa√≠da imediata do m√©todo. üéØ **Dica de Concurseiro:** `void` significa que o m√©todo n√£o retorna um *valor*, mas a instru√ß√£o `return;` ainda √© v√°lida para controle de fluxo.                                                                                                                                                                                                                    |
| 16  | Vari√°veis de classe em Java, declaradas com a palavra-chave `static`, garantem que cada objeto instanciado da classe possua sua pr√≥pria c√≥pia individual dessa vari√°vel.                                                                                                                                                                                 | F        | üí° O livro afirma: "Haveria apenas uma c√≥pia de cada vari√°vel de classe por classe, independentemente de quantos objetos s√£o criados a partir dela." üéØ **Dica de Concurseiro:** `static` significa "pertence √† classe, n√£o √† inst√¢ncia". Todas as inst√¢ncias compartilham a mesma vari√°vel est√°tica.                                                                                                                                                                                                                                                                                                            |
| 17  | Constantes em Java s√£o geralmente declaradas como `public static final`, e por conven√ß√£o, seus nomes s√£o escritos em letras mai√∫sculas.                                                                                                                                                                                                                  | V        | ‚úÖ O livro diz: "Constantes s√£o vari√°veis declaradas como `public/private`, `final` e `static`... Ao declarar vari√°veis de classe como `public static final`, ent√£o os nomes das vari√°veis (constantes) s√£o todos em mai√∫sculas." üéØ **Dica de Concurseiro:** Conven√ß√µes de nomenclatura, embora n√£o impostas pelo compilador, s√£o importantes e frequentemente testadas. `PUBLIC_STATIC_FINAL_CONSTANT`.                                                                                                                                                                                                         |
| 18  | A instancia√ß√£o de um array em Java, como `arrayRefVar=new datatype[size];`, define o tamanho do array, que pode ser alterado dinamicamente ap√≥s a cria√ß√£o.                                                                                                                                                                                               | F        | üí° Arrays em Java t√™m tamanho fixo ap√≥s a cria√ß√£o. Para cole√ß√µes de tamanho din√¢mico, utiliza-se estruturas como `ArrayList`. O livro foca na sintaxe de cria√ß√£o com tamanho definido. üéØ **Dica de Concurseiro:** Tamanho fixo de array √© uma caracter√≠stica chave. A banca pode sugerir flexibilidade que n√£o existe nativamente no tipo `array`.                                                                                                                                                                                                                                                              |
| 19  | A propriedade `length` de um array em Java (ex: `a.length`) retorna o n√∫mero de elementos atualmente armazenados no array, e n√£o sua capacidade total.                                                                                                                                                                                                   | F        | üí° `a.length` em Java retorna a capacidade total do array, ou seja, o tamanho com o qual ele foi declarado. N√£o indica quantos elementos foram efetivamente preenchidos se for menor que a capacidade. üéØ **Dica de Concurseiro:** Cuidado com a sem√¢ntica de `length`. Em arrays, √© a capacidade. Em `String`, √© o n√∫mero de caracteres. Em cole√ß√µes como `ArrayList`, `size()` √© usado para o n√∫mero de elementos.                                                                                                                                                                                             |
| 20  | Em um loop `for` em Java, como `for(inicializa√ß√£o; Boolean_expression; update)`, a etapa de `inicializa√ß√£o` √© executada repetidamente a cada itera√ß√£o do loop.                                                                                                                                                                                           | F        | üí° O livro explica: "A etapa de `inicializa√ß√£o` √© executada primeiro, e apenas uma vez." üéØ **Dica de Concurseiro:** O fluxo de controle do loop `for` √© crucial: inicializa√ß√£o (uma vez) -> condi√ß√£o -> corpo do loop -> atualiza√ß√£o -> condi√ß√£o...                                                                                                                                                                                                                                                                                                                                                             |
| 21  | A instru√ß√£o `break` dentro de um loop, quando executada, faz com que o controle do programa salte para a pr√≥xima itera√ß√£o do mesmo loop, ignorando o restante do c√≥digo da itera√ß√£o atual.                                                                                                                                                               | F        | üí° O livro afirma: "Quando a instru√ß√£o `break` √© encontrada dentro de um loop, o loop √© imediatamente terminado e o controle do programa resume na pr√≥xima instru√ß√£o seguinte ao loop." A instru√ß√£o `continue` √© que pula para a pr√≥xima itera√ß√£o. üéØ **Dica de Concurseiro:** `break` sai do loop; `continue` vai para a pr√≥xima itera√ß√£o. A banca ADORA trocar esses dois.                                                                                                                                                                                                                                     |
| 22  | O casting de um tipo `float` para `int` em Java, como em `int Zint = (int)Zmove;`, √© uma opera√ß√£o impl√≠cita e n√£o requer um operador de cast expl√≠cito.                                                                                                                                                                                                  | F        | üí° O livro diz: "Para converter um `float` em um `int`, voc√™ precisa ser mais expl√≠cito. √â por isso que Java requer que voc√™ use o cast e adicione o `(int)` em `int Zint = (int)Zmove;`." üéØ **Dica de Concurseiro:** Convers√µes que podem perder informa√ß√£o (como `float` para `int`, onde a parte decimal √© truncada) exigem cast expl√≠cito em Java.                                                                                                                                                                                                                                                          |
| 23  | A Busca Bin√°ria √© um algoritmo eficiente para encontrar um valor em uma sequ√™ncia, independentemente de a sequ√™ncia estar ordenada ou n√£o.                                                                                                                                                                                                               | F        | üí° O livro √© claro: "Em sua forma mais simples, a busca bin√°ria √© usada para encontrar rapidamente um valor em uma sequ√™ncia *ordenada*." üéØ **Dica de Concurseiro:** O pr√©-requisito da Busca Bin√°ria √© a ordena√ß√£o. Sem isso, ela n√£o funciona.                                                                                                                                                                                                                                                                                                                                                                |
| 24  | A complexidade de tempo da Busca Bin√°ria √©, em nota√ß√£o Big-O, `O(log N)`, o que a torna significativamente mais lenta que uma busca linear `O(N)` para grandes conjuntos de dados.                                                                                                                                                                       | F        | üí° O livro afirma: "A Busca Bin√°ria nunca usar√° mais do que (em nota√ß√£o big-oh) `O(log N)` compara√ß√µes... O logaritmo √© uma fun√ß√£o de crescimento terrivelmente lento", indicando sua efici√™ncia. `O(log N)` √© muito mais r√°pido que `O(N)` para N grande. üéØ **Dica de Concurseiro:** `log N` cresce muito mais devagar que `N`. A banca pode inverter a rela√ß√£o de efici√™ncia.                                                                                                                                                                                                                                 |
| 25  | O algoritmo Bubble Sort, apesar de sua simplicidade, √© conhecido por ter uma complexidade de tempo m√©dia de `O(N log N)`.                                                                                                                                                                                                                                | F        | üí° O livro descreve o Bubble Sort como o "mais simples algoritmo de ordena√ß√£o" e, implicitamente pelos outros exemplos, sua complexidade √© `O(N¬≤)`. Livros cl√°ssicos de algoritmos confirmam `O(N¬≤)`. üéØ **Dica de Concurseiro:** Bubble Sort √© `O(N¬≤)`. `O(N log N)` √© t√≠pico de algoritmos mais eficientes como Merge Sort e Quick Sort (na m√©dia).                                                                                                                                                                                                                                                            |
| 26  | O Merge Sort √© um algoritmo de "dividir para conquistar" que, em sua etapa de "conquistar", mescla recursivamente as sub-listas menores em uma nova lista ordenada.                                                                                                                                                                                      | V        | ‚úÖ O livro descreve o Merge Sort: "Passo 2 ‚Äì dividir a lista recursivamente... Passo 3 ‚Äì mesclar as listas menores em uma nova lista em ordem classificada." üéØ **Dica de Concurseiro:** Entender as fases do "dividir para conquistar" (dividir, conquistar/resolver, combinar) √© chave para algoritmos como Merge Sort e Quick Sort.                                                                                                                                                                                                                                                                            |
| 27  | O Quicksort, um algoritmo de "dividir para conquistar", seleciona um elemento chamado "piv√¥" e rearranja o array de forma que todos os elementos menores que o piv√¥ fiquem ap√≥s ele, e os maiores, antes.                                                                                                                                                | F        | üí° O Quicksort coloca elementos menores que o piv√¥ √† sua esquerda (ou antes) e os maiores √† sua direita (ou depois). O livro diz: "Todos os elementos menores que o elemento piv√¥ s√£o colocados em um array e todos os elementos maiores s√£o colocados em outro array." (No contexto de ordena√ß√£o crescente). üéØ **Dica de Concurseiro:** A posi√ß√£o relativa dos elementos menores/maiores em rela√ß√£o ao piv√¥ √© fundamental. A banca pode inverter essa l√≥gica.                                                                                                                                                  |
| 28  | Uma das vantagens do Quicksort √© que ele pode ser implementado para ordenar "in-place", ou seja, sem a necessidade de criar arrays adicionais significativos durante o processo.                                                                                                                                                                         | V        | ‚úÖ O livro menciona: "Quicksort pode ser implementado para ordenar 'in-place'. Isso significa que a ordena√ß√£o ocorre no array e que nenhum array adicional precisa ser criado." üéØ **Dica de Concurseiro:** "In-place" √© uma caracter√≠stica importante que economiza mem√≥ria, e o Quicksort √© um exemplo cl√°ssico.                                                                                                                                                                                                                                                                                                |
| 29  | Em uma Lista Ligada (Linked List), cada n√≥ (link) cont√©m apenas os dados do elemento, sem qualquer refer√™ncia para outros n√≥s da lista.                                                                                                                                                                                                                  | F        | üí° O livro define: "Cada link cont√©m uma conex√£o para outro link chamado Next." Al√©m disso, "Cada link carrega um(s) campo(s) de dados e um campo de link chamado next." üéØ **Dica de Concurseiro:** A ess√™ncia da lista ligada √© justamente a conex√£o entre os n√≥s. Sem o ponteiro/refer√™ncia para o pr√≥ximo, n√£o seria uma lista *ligada*.                                                                                                                                                                                                                                                                     |
| 30  | Na opera√ß√£o de inser√ß√£o em uma lista ligada, se um novo n√≥ B √© inserido entre A e C, o `next` de A deve apontar para B, e o `next` de B deve apontar para C.                                                                                                                                                                                             | V        | ‚úÖ O livro ilustra: `NewNode.next -> RightNode;` (B aponta para C) e depois `LeftNode.next -> NewNode;` (A aponta para B). Essa √© a l√≥gica correta para inser√ß√£o no meio. üéØ **Dica de Concurseiro:** Visualizar as opera√ß√µes em listas ligadas √© crucial. Desenhe os n√≥s e ponteiros para entender o fluxo.                                                                                                                                                                                                                                                                                                      |
| 31  | Para deletar um n√≥ alvo (TargetNode) que est√° entre LeftNode e RightNode (NextNode do TargetNode) em uma lista ligada, basta fazer `LeftNode.next` apontar para `null`.                                                                                                                                                                                  | F        | üí° Para remover o TargetNode, `LeftNode.next` deve apontar para o n√≥ que vinha *depois* do TargetNode, ou seja, `TargetNode.next` (que √© o RightNode). O livro mostra: `LeftNode.next -> TargetNode.next;`. Apontar para `null` quebraria a lista. üéØ **Dica de Concurseiro:** A dele√ß√£o envolve "saltar" o n√≥ a ser removido, religando o anterior ao posterior dele.                                                                                                                                                                                                                                           |
| 32  | O livro apresenta um programa para verificar se uma string possui todos os caracteres √∫nicos utilizando uma estrutura de dados Hash (Set) ou ordenando a string e verificando caracteres adjacentes.                                                                                                                                                     | V        | ‚úÖ O Cap√≠tulo 4, Q.1, mostra duas fun√ß√µes: `isUniqueUsingHash` e `isUniqueUsingSort` para resolver exatamente este problema. üéØ **Dica de Concurseiro:** Conhecer m√∫ltiplas abordagens para um mesmo problema √© comum em entrevistas e, portanto, em quest√µes baseadas em material de entrevista.                                                                                                                                                                                                                                                                                                                 |
| 33  | A forma de verificar se duas strings s√£o permuta√ß√µes uma da outra, conforme c√≥digo no livro, envolve orden√°-las e depois comparar caractere por caractere.                                                                                                                                                                                               | V        | ‚úÖ O Cap√≠tulo 4, Q.2 (`isPermutation`), implementa essa l√≥gica: converte para array de char, ordena ambos com `Arrays.sort()` e compara. üéØ **Dica de Concurseiro:** Se duas strings s√£o permuta√ß√µes, suas vers√µes ordenadas ser√£o id√™nticas. Essa √© uma t√©cnica cl√°ssica.                                                                                                                                                                                                                                                                                                                                        |
| 34  | O problema "URLify", apresentado no livro, consiste em substituir todos os espa√ßos em uma string pelo caractere `+`, comum em par√¢metros de URL.                                                                                                                                                                                                         | F        | üí° O problema "URLify" (Cap√≠tulo 4, Q.3) substitui espa√ßos por `%20`, n√£o por `+`. O c√≥digo de exemplo implementa a substitui√ß√£o por `%20`. üéØ **Dica de Concurseiro:** Aten√ß√£o aos detalhes da especifica√ß√£o do problema. `%20` √© a codifica√ß√£o padr√£o para espa√ßos em URLs, enquanto `+` √© frequentemente usado em query strings (application/x-www-form-urlencoded).                                                                                                                                                                                                                                          |
| 35  | Para adicionar dois n√∫meros inteiros sem usar o operador `+`, o livro demonstra uma t√©cnica que utiliza exclusivamente opera√ß√µes de incremento e decremento em loops.                                                                                                                                                                                    | F        | üí° O Cap√≠tulo 4, Q.9 (`AddWithoutPlus`), utiliza opera√ß√µes bit-a-bit (XOR `^` para soma sem vai-um, AND `&` para o vai-um, e left shift `<<` para mover o vai-um). üéØ **Dica de Concurseiro:** Adi√ß√£o sem `+` geralmente remete a manipula√ß√£o de bits. A banca pode sugerir uma abordagem menos eficiente ou incorreta.                                                                                                                                                                                                                                                                                          |
| 36  | A implementa√ß√£o de `hashCode()` e `equals()` em uma classe Java deve seguir o contrato onde, se dois objetos s√£o iguais por `equals()`, eles obrigatoriamente devem retornar o mesmo `hashCode()`.                                                                                                                                                       | V        | ‚úÖ O Cap√≠tulo 4, Q.15, discute e exemplifica essa regra fundamental: "Se dois objetos s√£o iguais, ent√£o esses dois objetos devem retornar o mesmo c√≥digo hash." üéØ **Dica de Concurseiro:** Esse contrato √© CRUCIAL. O inverso n√£o √© verdadeiro (dois objetos com mesmo hashCode n√£o s√£o necessariamente equals). A quebra desse contrato leva a comportamentos inesperados em cole√ß√µes baseadas em hash (HashMap, HashSet).                                                                                                                                                                                      |
| 37  | Segundo o livro, uma das habilidades que programadores autodidatas comumente n√£o possuem √© um profundo conhecimento em Algoritmos e Estruturas de Dados.                                                                                                                                                                                                 | V        | ‚úÖ Na se√ß√£o "5 SKILLS SELF-TAUGHT PROGRAMMERS COMMONLY LACK", o item 1 √© "ALGORITHMS" e o item 4 √© "DATA STRUCTURES". üéØ **Dica de Concurseiro:** T√≥picos listados como "defici√™ncias comuns" s√£o bons candidatos para quest√µes que testam o conhecimento desses pontos fracos.                                                                                                                                                                                                                                                                                                                                   |
| 38  | O livro sugere que, para se tornar um √≥timo programador, √© importante focar em apenas uma linguagem de programa√ß√£o e um paradigma, evitando a dispers√£o de aprendizado.                                                                                                                                                                                  | F        | üí° Na se√ß√£o "9 WAYS TO BECOME A GREAT PROGRAMMER!", item "6. KEEP LEARNING NEW THINGS", o livro cita Jonathan Henson que "tenta aprender uma nova linguagem de programa√ß√£o, paradigma ou stack todo ano". Tamb√©m em "3. PROGRAMMING PARADIGMS" critica a vis√£o de que s√≥ existe "Um Jeito". üéØ **Dica de Concurseiro:** A polival√™ncia e a capacidade de aprender continuamente s√£o valorizadas. A banca pode pregar o oposto.                                                                                                                                                                                   |
| 39  | "Amar o erro" (Love the Error) √© uma das 9 maneiras de se tornar um √≥timo programador, significando que o desenvolvedor deve ignorar mensagens de erro e focar apenas na l√≥gica principal.                                                                                                                                                               | F        | üí° "Love the Error" significa "abra√ßar os erros como momentos cruciais de aprendizado... acostumar-se aos erros e aprender a reconhecer as mensagens de erro." Ignorar os erros √© o oposto do conselho. üéØ **Dica de Concurseiro:** A interpreta√ß√£o correta de conselhos ou "m√°ximas" √© importante. A banca pode distorcer o significado.                                                                                                                                                                                                                                                                        |
| 40  | O livro aconselha, na se√ß√£o de curr√≠culos, que um t√≠tulo de curr√≠culo como "`1975 hottie looking for a job`" √© uma forma criativa de se destacar e chamar a aten√ß√£o do recrutador.                                                                                                                                                                       | F        | üí° O livro cita esse exemplo como algo a N√ÉO fazer: "...'1975 hottie looking for a job resume' gets your resume passed over by a busy recruiter... enough with the stupid titles we dismiss and make fun of." üéØ **Dica de Concurseiro:** Conselhos pr√°ticos, especialmente os que d√£o exemplos de "n√£o fa√ßa isso", s√£o f√°ceis de virar quest√£o.                                                                                                                                                                                                                                                                 |
| 41  | A utiliza√ß√£o de papel de boa qualidade e cor profissional (diferente do branco) para a c√≥pia impressa do curr√≠culo pode, sutilmente, causar uma impress√£o positiva no recrutador.                                                                                                                                                                        | V        | ‚úÖ A se√ß√£o "LOOK AND FEEL" do "Resume Advice" detalha como um papel de maior gramatura ou cor profissional pode fazer o curr√≠culo "se sentir" diferente e prender a aten√ß√£o por mais tempo. üéØ **Dica de Concurseiro:** Dicas que parecem "menores" ou de "bom senso" podem ser cobradas para testar a aten√ß√£o a todos os aspectos da prepara√ß√£o.                                                                                                                                                                                                                                                                 |
| 42  | O livro sugere que, durante uma entrevista, ao receber uma quest√£o, o candidato deve imediatamente come√ßar a codificar a solu√ß√£o para demonstrar agilidade e conhecimento.                                                                                                                                                                               | F        | üí° Na se√ß√£o "AT THE INTERVIEW", aconselha-se: "imediatamente esboce um monte de exemplos e fa√ßa um monte de perguntas esclarecedoras... N√£o fa√ßa nenhuma suposi√ß√£o sem antes verific√°-las com seu entrevistador." E "E o que quer que voc√™ fa√ßa, n√£o surte ou tente pular direto para codificar uma resposta." üéØ **Dica de Concurseiro:** Afoiteza na entrevista √© ruim. Esclarecer a quest√£o √© o primeiro passo.                                                                                                                                                                                               |
| 43  | Uma das "Common Programming Interview Idioms" para arrays num√©ricos √© iterar sobre os elementos do array apenas no sentido progressivo (do in√≠cio para o fim).                                                                                                                                                                                           | F        | üí° O livro sugere: "Pense em iterar para tr√°s sobre os elementos do array, bem como para frente." üéØ **Dica de Concurseiro:** Flexibilidade de pensamento √© chave. Iterar ao contr√°rio pode simplificar certos problemas (ex: merge in-place de arrays ordenados).                                                                                                                                                                                                                                                                                                                                               |
| 44  | Para problemas envolvendo listas ligadas, √© comum a necessidade de utilizar dois ponteiros, `cur` (atual) e `prev` (anterior), para percorrer a lista.                                                                                                                                                                                                   | V        | ‚úÖ Em "Linked lists" na se√ß√£o de "COMMON PROGRAMMING INTERVIEW IDIOMS", est√°: "...chances are that you'll need to walk two pointers, which I like to call `cur` and `prev`, down the list..." üéØ **Dica de Concurseiro:** A t√©cnica de "dois ponteiros" (two-pointer technique) √© muito comum para listas ligadas e arrays.                                                                                                                                                                                                                                                                                       |
| 45  | √Årvores bin√°rias e √°rvores bin√°rias de busca s√£o termos intercambi√°veis, referindo-se sempre √† mesma estrutura de dados com as mesmas propriedades de ordena√ß√£o.                                                                                                                                                                                         | F        | üí° O livro alerta em "Binary trees": "Lembre-se que nem todas as √°rvores bin√°rias s√£o √°rvores bin√°rias de busca, e saiba a diferen√ßa entre as duas." üéØ **Dica de Concurseiro:** Uma √°rvore bin√°ria de busca (BST) TEM uma propriedade de ordem (esquerda < raiz < direita). Uma √°rvore bin√°ria qualquer n√£o necessariamente. A banca adora essa distin√ß√£o.                                                                                                                                                                                                                                                      |
| 46  | Ao se deparar com um problema que envolve relacionamentos bin√°rios entre entidades (ex: X √© amigo de Y), a utiliza√ß√£o de uma estrutura de Grafos √© uma representa√ß√£o adequada.                                                                                                                                                                           | V        | ‚úÖ Na se√ß√£o "Graphs": "Sempre que voc√™ precisar representar relacionamentos bin√°rios, pense em usar um grafo. Ex: X √© amigo de Y..." üéØ **Dica de Concurseiro:** Grafos s√£o a estrutura de dados natural para modelar redes e relacionamentos.                                                                                                                                                                                                                                                                                                                                                                    |
| 47  | O algoritmo de Dijkstra √© comumente associado √† estrutura de dados Array para encontrar o menor caminho entre dois elementos.                                                                                                                                                                                                                            | F        | üí° Na se√ß√£o "Important data structure and algorithms", o livro menciona "(Dijkstra's for a graph.)". Dijkstra opera sobre Grafos. üéØ **Dica de Concurseiro:** Associar algoritmos corretos √†s suas estruturas de dados √© fundamental. Dijkstra √© para grafos.                                                                                                                                                                                                                                                                                                                                                    |
| 48  | "Falar √© barato. Mostre-me o c√≥digo." √© uma cita√ß√£o de Harold Abelson, presente na se√ß√£o "Programming Quotes!" do livro.                                                                                                                                                                                                                                 | F        | üí° O livro atribui esta cita√ß√£o a Linus Torvalds. A cita√ß√£o de Harold Abelson √©: "Programas devem ser escritos para pessoas lerem, e apenas incidentalmente para m√°quinas executarem." üéØ **Dica de Concurseiro:** Atribui√ß√£o correta de cita√ß√µes, se presentes, pode ser testada.                                                                                                                                                                                                                                                                                                                               |
| 49  | A complexidade de pior caso do algoritmo Quicksort √© `O(N¬≤)`, embora sua complexidade m√©dia seja `O(N log N)`.                                                                                                                                                                                                                                           | V        | ‚úÖ Embora o livro n√£o detalhe a complexidade do pior caso do Quicksort explicitamente na se√ß√£o de algoritmos, ele menciona que o BST pode ficar desbalanceado (an√°logo ao pior caso do Quicksort com piv√¥ ruim) e foca na efici√™ncia m√©dia. Conhecimento padr√£o de algoritmos confirma `O(N¬≤)` para o pior caso do Quicksort (ex: array j√° ordenado com piv√¥ na extremidade). üéØ **Dica de Concurseiro:** A banca pode focar no pior caso de algoritmos geralmente eficientes. Quicksort √© um exemplo cl√°ssico.                                                                                                   |
| 50  | Ao ordenar uma pilha usando uma pilha tempor√°ria, conforme o Q.20 do livro, elementos s√£o movidos da pilha de entrada para a tempor√°ria, e se um elemento a ser inserido na tempor√°ria for menor que o topo desta, elementos da tempor√°ria s√£o movidos de volta para a de entrada.                                                                       | V        | ‚úÖ O c√≥digo e a l√≥gica do Q.20 ("HOW TO SORT A STACK USING A TEMPORARY STACK?") demonstram exatamente este processo: `while(!tmpStack.isEmpty() && tmpStack.peek() > tmp) { input.push(tmpStack.pop()); } tmpStack.push(tmp);`. üéØ **Dica de Concurseiro:** Entender o fluxo de algoritmos que usam estruturas auxiliares √© importante. Desenhar o estado das pilhas a cada passo ajuda a visualizar.                                                                                                                                                                                                             |
| 51  | No contexto de *Java Concurrency in Practice*, a principal amea√ßa √† escalabilidade em aplica√ß√µes concorrentes √© a conten√ß√£o por recursos, independentemente do uso de locks exclusivos.                                                                                                                                                                  | F        | üë®‚Äçüè´ O livro enfatiza que o **lock exclusivo** √© o principal gargalo de escalabilidade. A conten√ß√£o por *qualquer* recurso pode ser um problema, mas o lock exclusivo serializa o acesso de forma inerente. üí°**Dica:** Pense em "lock exclusivo = fila √∫nica".                                                                                                                                                                                                                                                                                                                                                 |
| 52  | A Lei de Amdahl, conforme discutida em *Java Concurrency in Practice*, sugere que a paraleliza√ß√£o de 100% de um programa resulta em um ganho de desempenho linear com o aumento do n√∫mero de processadores.                                                                                                                                              | F        | üë®‚Äçüè´ A Lei de Amdahl mostra que o ganho de desempenho √© limitado pela por√ß√£o serial do programa. Mesmo com paraleliza√ß√£o quase total, h√° um limite. üí°**Dica:** Lembre-se que sempre existe uma parte que n√£o d√° para dividir entre v√°rios "trabalhadores" üë∑.                                                                                                                                                                                                                                                                                                                                                  |
| 53  | Em RxJava, um `Observable` "frio" (cold) inicia a emiss√£o de seus itens assim que √© criado, mesmo antes de qualquer `Observer` se inscrever.                                                                                                                                                                                                             | F        | üë®‚Äçüè´ `Observables` frios s√£o como CDs üíø: s√≥ "tocam" (emitem) quando um `Observer` (ouvinte) se inscreve. Cada `Observer` recebe sua pr√≥pria sequ√™ncia de emiss√µes desde o in√≠cio. üí°**Dica:** "Frio" espera pelo ouvinte; "Quente" (hot) transmite para quem estiver l√°.                                                                                                                                                                                                                                                                                                                                       |
| 54  | O operador `flatMap()` em RxJava √© utilizado exclusivamente para transformar um item emitido em exatamente um outro item de tipo diferente.                                                                                                                                                                                                              | F        | üë®‚Äçüè´ `flatMap()` √© poderoso porque pode transformar um item emitido em *zero, um ou m√∫ltiplos* itens, emitidos por um novo `Observable`. Ele "achata" esses `Observables` em um √∫nico fluxo. üí°**Dica:** `flatMap` = achatar mapas de `Observables`.                                                                                                                                                                                                                                                                                                                                                            |
| 55  | No Java 21, `Executors.newVirtualThreadPerTaskExecutor()` √© a forma recomendada para criar um pool de threads virtuais com tamanho fixo para reutiliza√ß√£o.                                                                                                                                                                                               | F        | üë®‚Äçüè´ Threads virtuais s√£o leves e baratas. O `newVirtualThreadPerTaskExecutor()` cria uma *nova* thread virtual para *cada* tarefa, n√£o um pool fixo para reutiliza√ß√£o. üí°**Dica:** Virtual √© descart√°vel por tarefa! üóëÔ∏è                                                                                                                                                                                                                                                                                                                                                                                       |
| 56  | A utiliza√ß√£o de `Semaphore` no Java 21 com threads virtuais √© desencorajada, pois threads virtuais n√£o s√£o um recurso escasso que precise de pooling.                                                                                                                                                                                                    | F        | üë®‚Äçüè´ `Semaphore` √© recomendado para *limitar a taxa de concorr√™ncia* ao acessar servi√ßos externos, mesmo com threads virtuais. Ele controla o n√∫mero de permiss√µes, n√£o o pooling de threads. üí°**Dica:** Sem√°foro üö¶ controla o fluxo, n√£o o "estacionamento" de threads.                                                                                                                                                                                                                                                                                                                                      |
| 57  | Um `ConnectableObservable` em RxJava, ap√≥s ser tornado "quente" pelo m√©todo `connect()`, sempre reemitir√° todos os seus itens para novos `Observers` que se inscreverem tardiamente.                                                                                                                                                                     | F        | üë®‚Äçüè´ `ConnectableObservable` (hot) n√£o reemite itens passados para `Observers` tardios, a menos que combinado com operadores como `replay()`. Eles pegam a transmiss√£o "ao vivo". üí°**Dica:** R√°dio ao vivo üìª: se ligou tarde, perdeu o in√≠cio.                                                                                                                                                                                                                                                                                                                                                                |
| 88  | A Concorr√™ncia Estruturada, um recurso em preview no JDK 21, visa simplificar o tratamento de erros e o cancelamento de grupos de tarefas concorrentes, tratando-as como uma unidade de trabalho.                                                                                                                                                        | V        | üë®‚Äçüè´ Exatamente! A Concorr√™ncia Estruturada agrupa tarefas relacionadas, facilitando o gerenciamento do ciclo de vida delas como um todo. üí°**Dica:** Pense em "gerente de projeto" üìã para suas tarefas concorrentes.                                                                                                                                                                                                                                                                                                                                                                                          |
| 89  | Segundo *Java Concurrency in Practice*, o uso de `volatile` garante tanto a visibilidade quanto a atomicidade para opera√ß√µes compostas como `i++`.                                                                                                                                                                                                       | F        | üë®‚Äçüè´ `volatile` garante visibilidade, mas n√£o atomicidade para opera√ß√µes compostas. `i++` √© uma opera√ß√£o de leitura-modifica√ß√£o-escrita, que n√£o √© at√¥mica com `volatile`. üí°**Dica:** `volatile` √© como um "aviso" üì¢ de mudan√ßa, n√£o um "cadeado" üîí.                                                                                                                                                                                                                                                                                                                                                         |
| 60  | Em RxJava, o operador `subscribeOn()` determina em qual `Scheduler` (thread) as emiss√µes de um `Observable` ser√£o processadas *a partir do ponto em que √© declarado na cadeia*.                                                                                                                                                                          | F        | üë®‚Äçüè´ `subscribeOn()` afeta a thread usada pela *fonte* do `Observable` (upstream), impactando toda a cadeia, a menos que um `observeOn()` seja usado. üí°**Dica:** `subscribeOn` √© "onde a fonte mora" üèûÔ∏è.                                                                                                                                                                                                                                                                                                                                                                                                      |
| 61  | Threads virtuais no Java 21, ao realizarem uma opera√ß√£o de I/O bloqueante, fazem com que a thread de plataforma (carrier thread) subjacente tamb√©m fique bloqueada, aguardando a conclus√£o do I/O.                                                                                                                                                       | F        | üë®‚Äçüè´ O grande trunfo das threads virtuais √© que, ao bloquear em I/O, elas s√£o "desmontadas" da thread portadora, que fica livre para executar outras threads virtuais. üí°**Dica:** Virtual "sai da fila" do SO quando espera por I/O ‚òï.                                                                                                                                                                                                                                                                                                                                                                         |
| 62  | O `Foreign Function and Memory API (FFM API)` do JDK 21 visa substituir completamente a necessidade de JNI, oferecendo uma maneira mais segura e robusta de interagir com c√≥digo nativo.                                                                                                                                                                 | V        | üë®‚Äçüè´ Sim, o FFM API √© projetado para ser uma alternativa mais segura e f√°cil de usar que o JNI para interagir com bibliotecas nativas e mem√≥ria fora da heap Java. üí°**Dica:** FFM √© a ponte moderna üåâ para o mundo C, mais segura que a velha JNI.                                                                                                                                                                                                                                                                                                                                                            |
| 63  | Em RxJava, o mecanismo de backpressure, utilizando `Flowable` e `Subscriber`, permite que o consumidor controle o fluxo de emiss√µes do produtor, solicitando apenas a quantidade de dados que consegue processar.                                                                                                                                        | V        | üë®‚Äçüè´ Correto! Backpressure √© fundamental quando o produtor √© mais r√°pido que o consumidor. O `Subscriber` "puxa" os dados do `Flowable` conforme sua capacidade. üí°**Dica:** Backpressure √© o "freio" üõë do consumidor para o produtor apressadinho.                                                                                                                                                                                                                                                                                                                                                            |
| 64  | A serializa√ß√£o de objetos em Java, conforme abordado no *Oracle Core Libraries*, √© inerentemente segura contra vulnerabilidades de desserializa√ß√£o, n√£o necessitando de filtros.                                                                                                                                                                         | F        | üë®‚Äçüè´ A desserializa√ß√£o de dados n√£o confi√°veis √© perigosa. O Java oferece "Serialization Filtering" (JEP 290, JEP 415) para mitigar riscos, permitindo definir quais classes podem ser desserializadas. üí°**Dica:** Filtro na entrada üö™ para evitar "presentes de grego".                                                                                                                                                                                                                                                                                                                                      |
| 65  | O padr√£o `ExecutorService` em Java, descrito em *Java Concurrency in Practice*, desacopla a submiss√£o da tarefa de sua pol√≠tica de execu√ß√£o, permitindo flexibilidade na forma como as tarefas s√£o executadas.                                                                                                                                           | V        | üë®‚Äçüè´ Exato! `ExecutorService` √© uma abstra√ß√£o poderosa que separa "o qu√™" (tarefa) de "como/quando" (execu√ß√£o), permitindo, por exemplo, usar pools de threads. üí°**Dica:** `ExecutorService` √© o "gerente de tarefas" üßë‚Äçüíº, voc√™ s√≥ entrega o trabalho.                                                                                                                                                                                                                                                                                                                                                       |
| 66  | Ao utilizar RxJava com Android, todas as intera√ß√µes com a UI devem ocorrer obrigatoriamente na thread principal, e `Schedulers.io()` √© o `Scheduler` padr√£o para essa finalidade.                                                                                                                                                                        | F        | üë®‚Äçüè´ Intera√ß√µes com a UI no Android devem ocorrer na thread principal, mas o `Scheduler` para isso √© `AndroidSchedulers.mainThread()`, n√£o `Schedulers.io()` (que √© para I/O). üí°**Dica:** UI no Android = `mainThread()` sempre! üñºÔ∏è                                                                                                                                                                                                                                                                                                                                                                           |
| 67  | O `Foreign Function and Memory API (FFM API)` permite que o c√≥digo Java aloque e acesse mem√≥ria exclusivamente dentro da heap da JVM.                                                                                                                                                                                                                    | F        | üë®‚Äçüè´ O FFM API foi projetado para interagir com mem√≥ria *fora* da heap da JVM (off-heap memory), que √© crucial para interoperar com bibliotecas nativas. üí°**Dica:** FFM = "fora da fortaleza da mem√≥ria Java" üè∞.                                                                                                                                                                                                                                                                                                                                                                                              |
| 68  | Em RxJava, o operador `observeOn()` influencia a thread em que os operadores *anteriores* (upstream) na cadeia `Observable` executar√£o suas opera√ß√µes.                                                                                                                                                                                                   | F        | üë®‚Äçüè´ `observeOn()` afeta a thread em que os operadores *subsequentes* (downstream) e o `Observer` final executar√£o. Ele "troca de pista" para o que vem depois. üí°**Dica:** `observeOn` muda a "via" üõ£Ô∏è para baixo.                                                                                                                                                                                                                                                                                                                                                                                            |
| 69  | As threads virtuais do Java 21 sempre herdam os valores das `ThreadLocal` vari√°veis da thread de plataforma que as iniciou.                                                                                                                                                                                                                              | F        | üë®‚Äçüè´ Por padr√£o, threads virtuais n√£o herdam `ThreadLocal`s. Para heran√ßa, deve-se usar `InheritableThreadLocal` ou, preferencialmente, os novos `ScopedValue`s (JEP 446). üí°**Dica:** `ThreadLocal` √© "ego√≠sta" üôÖ‚Äç‚ôÇÔ∏è, n√£o compartilha com virtuais por padr√£o.                                                                                                                                                                                                                                                                                                                                                |
| 70  | O livro *Java Concurrency in Practice* desaconselha o uso de `Thread.stop()` para interromper threads devido aos seus potenciais problemas de seguran√ßa e consist√™ncia de dados.                                                                                                                                                                         | V        | üë®‚Äçüè´ Absolutamente. `Thread.stop()` √© depreciado e perigoso, pois pode deixar objetos em estados inconsistentes ao liberar locks abruptamente. A interrup√ß√£o cooperativa √© a abordagem correta. üí°**Dica:** `stop()` √© o bot√£o de "autodestrui√ß√£o" üí£, evite!                                                                                                                                                                                                                                                                                                                                                   |
| 71  | Em RxJava, `Single` √© um tipo de `Observable` que pode emitir zero ou um item, seguido por uma notifica√ß√£o de `onComplete()` ou `onError()`.                                                                                                                                                                                                             | F        | üë®‚Äçüè´ `Single` *deve* emitir exatamente um item ou um erro. Para zero ou um item, usa-se `Maybe`. üí°**Dica:** `Single` = √∫nico item ü•á; `Maybe` = talvez um, talvez nenhum ü§î.                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 72  | As `Sequenced Collections` (JEP 431), introduzidas no JDK 21, fornecem uma interface unificada para cole√ß√µes que mant√™m uma ordem de encontro definida, como `List` e `LinkedHashSet`.                                                                                                                                                                   | V        | üë®‚Äçüè´ Correto. `SequencedCollection`, `SequencedSet` e `SequencedMap` padronizam o acesso a elementos em cole√ß√µes ordenadas, oferecendo m√©todos como `getFirst()`, `getLast()`, `reversed()`. üí°**Dica:** Sequenced = "ordem na casa" üè†.                                                                                                                                                                                                                                                                                                                                                                        |
| 73  | No RxJava, o operador `concatMap()` processa os `Observables` gerados por cada emiss√£o da fonte de forma concorrente, semelhante ao `flatMap()`, mas garantindo a ordem das emiss√µes originais.                                                                                                                                                          | F        | üë®‚Äçüè´ `concatMap()` processa os `Observables` gerados *sequencialmente*, um ap√≥s o outro, esperando o anterior completar antes de iniciar o pr√≥ximo, para garantir a ordem. `flatMap()` os processa concorrentemente. üí°**Dica:** `concat` = um de cada vez, em fila üö∂‚Äç‚ôÇÔ∏èüö∂‚Äç‚ôÄÔ∏è.                                                                                                                                                                                                                                                                                                                                 |
| 74  | Threads virtuais no Java 21 n√£o suportam `ThreadLocal` vari√°veis para evitar problemas de vazamento de mem√≥ria, dado o grande n√∫mero de threads virtuais que podem ser criadas.                                                                                                                                                                          | F        | üë®‚Äçüè´ Threads virtuais *suportam* `ThreadLocal`s, mas seu uso para cache de objetos reutiliz√°veis √© desencorajado, pois cada thread virtual teria sua c√≥pia. `ScopedValue`s s√£o uma alternativa melhor para muitos casos. üí°**Dica:** `ThreadLocal` com virtual? Cuidado redobrado! ‚ö†Ô∏è                                                                                                                                                                                                                                                                                                                           |
| 75  | Segundo o livro *Java Concurrency in Practice*, a documenta√ß√£o clara das pol√≠ticas de sincroniza√ß√£o de uma classe √© crucial tanto para seus usu√°rios quanto para seus mantenedores.                                                                                                                                                                      | V        | üë®‚Äçüè´ Com certeza! Documentar se uma classe √© thread-safe, qual lock protege qual estado (`@GuardedBy`), etc., √© vital para evitar que outros introduzam bugs de concorr√™ncia. üí°**Dica:** Documenta√ß√£o √© o mapa do tesouro üó∫Ô∏è da concorr√™ncia.                                                                                                                                                                                                                                                                                                                                                                 |
| 76  | Express√µes lambda, introduzidas no Java 8, podem ser utilizadas para instanciar qualquer interface, independentemente do n√∫mero de m√©todos abstratos que ela possua.                                                                                                                                                                                     | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Lambdas s√£o como atalhos para dar instru√ß√µes r√°pidas. Elas s√≥ funcionam com "brinquedos" (interfaces) que t√™m UMA √∫nica instru√ß√£o principal (m√©todo abstrato). Se tem mais de uma, o Java fica confuso. üí°**Dica:** Lambda = SAM (Single Abstract Method). Se n√£o √© SAM, n√£o √© lambda! üéØ                                                                                                                                                                                                                                                                          |
| 77  | A interface `java.util.stream.Stream` do Java 8 √© projetada para modificar a cole√ß√£o original da qual o stream foi derivado, tornando as opera√ß√µes de stream inerentemente mut√°veis.                                                                                                                                                                     | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Pense num stream como um "rio de dados" que flui da sua cole√ß√£o (fonte). As opera√ß√µes no rio (filtros, mapas) criam um *novo* rio modificado, mas a fonte original fica intacta, como um lago que n√£o muda. üí°**Dica:** Streams s√£o *n√£o-interferentes* e *stateless* (sem estado) por padr√£o. N√£o alteram a fonte! üèûÔ∏è                                                                                                                                                                                                                                            |
| 78  | O m√©todo `Optional.orElseThrow()` do Java 8 permite lan√ßar uma exce√ß√£o espec√≠fica caso o `Optional` esteja vazio, oferecendo um controle mais fino sobre o tratamento de aus√™ncia de valor do que `Optional.get()`.                                                                                                                                      | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `Optional` √© uma caixinha que pode ou n√£o ter um presente. Se tentar pegar (`get()`) e n√£o tiver nada, d√° um erro gen√©rico. Com `orElseThrow()`, voc√™ diz: "se estiver vazia, grite ESTE erro espec√≠fico!". üí°**Dica:** `orElseThrow()`: seu grito personalizado para caixas vazias! üó£Ô∏è                                                                                                                                                                                                                                                                           |
| 79  | `CompletableFuture` no Java 8 e superior permite a composi√ß√£o de m√∫ltiplas opera√ß√µes ass√≠ncronas de forma fluente, mas n√£o oferece mecanismos para lidar com exce√ß√µes ocorridas durante essas opera√ß√µes.                                                                                                                                                 | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `CompletableFuture` √© como um mensageiro üö¥ que faz v√°rias entregas (tarefas) e te avisa quando termina. Se algo der errado numa entrega (exce√ß√£o), ele tem formas de te contar e at√© de tentar de novo ou fazer outra coisa. üí°**Dica:** `handle()`, `whenComplete()`, `exceptionally()` s√£o seus amigos para tratar erros em `CompletableFuture`.                                                                                                                                                                                                                |
| 80  | A infer√™ncia de tipo para vari√°veis locais com `var`, introduzida no Java 10, permite que o compilador determine o tipo da vari√°vel a partir do inicializador, mas a vari√°vel ainda √© estaticamente tipada.                                                                                                                                              | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Com `var`, voc√™ deixa o Java adivinhar o tipo da sua "caixa de brinquedos" pelo primeiro brinquedo que voc√™ coloca nela. Mas depois que ele adivinha, a caixa s√≥ aceita aquele tipo de brinquedo. üí°**Dica:** `var` √© conveni√™ncia na declara√ß√£o, n√£o dinamismo de tipo! O tipo √© fixo em tempo de compila√ß√£o. ‚úÖ                                                                                                                                                                                                                                                   |
| 81  | Records, introduzidos no Java 14, s√£o classes concisas para armazenar dados imut√°veis, gerando automaticamente construtores, getters, `equals()`, `hashCode()` e `toString()`.                                                                                                                                                                           | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Records s√£o como cart√µes de visita super pr√°ticos. Voc√™ s√≥ diz quais informa√ß√µes quer (nome, telefone), e o Java j√° imprime tudo bonitinho (construtor, jeitos de ler os dados, como comparar). E s√£o imut√°veis! üí°**Dica:** Record = "POJO" moderno e sem boiler-plate! üìù                                                                                                                                                                                                                                                                                        |
| 82  | Threads virtuais no Java 21 s√£o executadas diretamente pelo sistema operacional, de forma an√°loga √†s threads de plataforma, mas com uma pilha de mem√≥ria significativamente menor.                                                                                                                                                                       | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Threads virtuais s√£o como "tarefas leves" gerenciadas pelo pr√≥prio Java (JVM), n√£o pelo "chefe maior" (SO). Elas "pegam carona" em poucas threads do chefe (platform threads). üí°**Dica:** Virtuais s√£o gerenciadas pela JVM, platform pelo SO. A leveza vem da√≠! üéà                                                                                                                                                                                                                                                                                               |
| 83  | Ao usar `Executors.newVirtualThreadPerTaskExecutor()` no Java 21, cada tarefa submetida ao `ExecutorService` resultante sempre reutilizar√° uma thread virtual de um pool preexistente para otimizar recursos.                                                                                                                                            | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Esse executor especial √© como uma m√°quina de clonar oper√°rios (threads virtuais) sob demanda. Cada nova tarefa ganha um oper√°rio novinho em folha, feito na hora, e que some depois do trabalho. N√£o tem pool! üí°**Dica:** `newVirtualThreadPerTaskExecutor` = 1 tarefa, 1 thread virtual NOVA. üÜï                                                                                                                                                                                                                                                                 |
| 84  | "Pinning" (afixa√ß√£o) de uma thread virtual √† sua thread de plataforma portadora pode ocorrer quando a thread virtual executa c√≥digo dentro de um bloco `synchronized` ou um m√©todo nativo.                                                                                                                                                               | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Quando uma thread virtual entra num bloco `synchronized` (como uma sala com uma s√≥ chave üîë) ou fala com c√≥digo de fora do Java (nativo), ela "gruda" na sua thread de plataforma portadora e n√£o a solta at√© sair. üí°**Dica:** `synchronized` e JNI s√£o "superbonder" para virtuais e suas portadoras. Use `ReentrantLock` para mais flexibilidade.                                                                                                                                                                                                               |
| 85  | Em RxJava, o operador `observeOn()` especifica o `Scheduler` (thread) em que a fonte `Observable` original deve emitir seus itens, afetando toda a cadeia de operadores subsequentes.                                                                                                                                                                    | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `observeOn()` √© como um "desvio de tr√¢nsito" ‚Ü™Ô∏è. Ele muda a "pista" (thread) para todos os operadores que v√™m *depois* dele na cadeia. O que veio *antes* continua na pista original ou na definida por `subscribeOn()`. üí°**Dica:** `observeOn` = downstream; `subscribeOn` = upstream (mais pr√≥ximo da fonte).                                                                                                                                                                                                                                                   |
| 86  | O `Foreign Function & Memory API (FFM API)` no Java 21 permite a aloca√ß√£o de mem√≥ria off-heap (fora da heap gerenciada pelo garbage collector) atrav√©s de um `Arena`, que controla o ciclo de vida dessa mem√≥ria.                                                                                                                                        | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** FFM API deixa o Java brincar com uma "caixa de areia" (Arena) de mem√≥ria especial, fora do parquinho principal (heap). Quando a brincadeira na Arena acaba, a areia √© limpa (mem√≥ria liberada). üí°**Dica:** `Arena` = gerenciador de ciclo de vida para mem√≥ria off-heap no FFM. `try-with-resources` √© seu amigo aqui! üõ°Ô∏è                                                                                                                                                                                                                                        |
| 87  | As `Sequenced Collections` do JDK 21, como `SequencedSet`, garantem uma ordem de encontro definida e introduzem m√©todos como `addFirst()` e `addLast()`, mas n√£o oferecem uma vis√£o reversa da cole√ß√£o.                                                                                                                                                  | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** As `Sequenced Collections` s√£o como filas organizadas. Elas sabem quem √© o primeiro e o √∫ltimo, e sim, elas t√™m um truque m√°gico: o m√©todo `reversed()` que te d√° uma vis√£o da fila de tr√°s para frente! üîÑ üí°**Dica:** `SequencedCollection.reversed()` √© o "retrovisor" das cole√ß√µes ordenadas.                                                                                                                                                                                                                                                                  |
| 88  | Threads virtuais s√£o mais adequadas para tarefas intensivas em CPU (CPU-bound) do que para tarefas limitadas por I/O (I/O-bound), pois sua leveza permite um chaveamento de contexto mais r√°pido entre c√°lculos.                                                                                                                                         | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Threads virtuais brilham ‚ú® quando as tarefas passam muito tempo esperando (I/O), como um gar√ßom esperando a cozinha. Para tarefas que usam muito o c√©rebro (CPU), as threads de plataforma tradicionais, em n√∫mero limitado aos n√∫cleos, ainda s√£o eficientes. üí°**Dica:** Virtual = I/O-bound (muitas esperando); Platform = CPU-bound (poucas trabalhando duro).                                                                                                                                                                                                 |
| 89  | Em RxJava, se um `Flowable` emitir itens mais rapidamente do que o `Subscriber` consegue processar, e n√£o houver uma estrat√©gia de backpressure definida (como `onBackpressureBuffer` ou `onBackpressureDrop`), uma `MissingBackpressureException` ser√° lan√ßada.                                                                                         | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Imagine uma esteira de f√°brica (`Flowable`) cuspindo produtos muito r√°pido para o empacotador (`Subscriber`). Se n√£o tiver uma "caixa de espera" (buffer) ou uma regra para "ignorar alguns" (drop), o empacotador entra em p√¢nico (lan√ßa `MissingBackpressureException`)! üí°**Dica:** Fluxo r√°pido sem controle = `MissingBackpressureException`. RxJava √© expl√≠cito sobre isso. üí•                                                                                                                                                                               |
| 90  | A Concorr√™ncia Estruturada no JDK 21, ao utilizar um `StructuredTaskScope`, garante que, se uma subtarefa falhar, todas as outras subtarefas ainda em execu√ß√£o continuar√£o at√© sua conclus√£o normal antes que a falha seja propagada.                                                                                                                    | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Com `StructuredTaskScope` (e uma pol√≠tica como `ShutdownOnFailure`), se uma "pe√ßa da equipe" (subtarefa) quebra, o "gerente" (escopo) avisa as outras para pararem tamb√©m e reporta o problema rapidamente. N√£o espera todo mundo terminar. üí°**Dica:** "Um por todos, todos por um... mas se um falhar, parem todos!" (com `ShutdownOnFailure`). üõë                                                                                                                                                                                                               |
| 91  | O `java.time` API (Java 8+) √© imut√°vel por design, o que significa que objetos como `LocalDate` ou `LocalDateTime`, uma vez criados, n√£o podem ter seu estado interno alterado, promovendo a seguran√ßa em ambientes concorrentes.                                                                                                                        | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** As datas e horas do `java.time` s√£o como fotografias üì∏: uma vez tiradas (criadas), n√£o d√° para mudar o que est√° na foto. Se quiser uma data diferente, voc√™ tira uma nova foto. Isso evita confus√£o se v√°rias pessoas olharem ao mesmo tempo. üí°**Dica:** Imutabilidade √© amiga da concorr√™ncia! ü§ù                                                                                                                                                                                                                                                               |
| 92  | Em RxJava, o operador `Schedulers.trampoline()` executa tarefas imediatamente na thread atual, mas se uma tarefa agendar recursivamente outra tarefa no mesmo `Scheduler`, a tarefa agendada ser√° enfileirada e executada ap√≥s a conclus√£o da tarefa atual, evitando `StackOverflowError`.                                                               | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `trampoline()` √© como um trampolim educado. Se voc√™ est√° pulando e tenta pular de novo enquanto ainda est√° no ar (recurs√£o), ele espera voc√™ aterrissar (tarefa atual acabar) antes de deixar voc√™ pular de novo (executar a tarefa enfileirada). üí°**Dica:** `trampoline()` = enfileiramento para recurs√£o no mesmo Scheduler. Evita o "tombo" (`StackOverflowError`).ü§∏                                                                                                                                                                                          |
| 93  | O `FFM API` do Java 21 utiliza `MemorySegment` para representar regi√µes cont√≠guas de mem√≥ria (on-heap ou off-heap) e `Linker` para obter handles para fun√ß√µes nativas. A intera√ß√£o com fun√ß√µes C que esperam ponteiros C √© tipicamente feita passando inst√¢ncias de `MemorySegment`.                                                                     | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Para o Java falar com c√≥digo C, o FFM API usa "peda√ßos de mem√≥ria" (`MemorySegment`) para os dados e um "tradutor" (`Linker`) para chamar as fun√ß√µes C. Se a fun√ß√£o C espera um endere√ßo (ponteiro), o Java entrega um `MemorySegment`. üí°**Dica:** `MemorySegment` √© o "endere√ßo" que o Java mostra para o C. üó∫Ô∏è                                                                                                                                                                                                                                                 |
| 94  | Em uma aplica√ß√£o que utiliza threads virtuais, se uma thread virtual estiver executando uma opera√ß√£o de longa dura√ß√£o intensiva em CPU sem realizar I/O bloqueante, ela ocupar√° continuamente sua thread de plataforma portadora, potencialmente impactando o throughput de outras tarefas I/O-bound.                                                    | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Se uma thread virtual decide fazer uma maratona de c√°lculos üèÉ‚Äç‚ôÇÔ∏èüí® sem parar para beber √°gua (I/O), ela "segura" a thread de plataforma que a carrega. Essa portadora n√£o consegue ajudar outras virtuais que s√≥ queriam pegar um copo d'√°gua r√°pido. üí°**Dica:** Virtuais s√£o para I/O-bound. CPU-bound em virtual pode "monopolizar" uma portadora.  monopolizar                                                                                                                                                                                                |
| 95  | A principal diferen√ßa entre `Observable.merge()` e `Observable.concat()` em RxJava √© que `merge()` processa as emiss√µes dos `Observables` de origem de forma intercalada e concorrente, enquanto `concat()` processa todas as emiss√µes de um `Observable` antes de passar para o pr√≥ximo, garantindo a ordem sequencial entre as fontes.                 | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `merge()` √© como v√°rios DJs tocando ao mesmo tempo üéßüé∂, as m√∫sicas (emiss√µes) se misturam. `concat()` √© como uma playlist üìú: uma m√∫sica toca inteira antes da pr√≥xima come√ßar. üí°**Dica:** `merge` = bagun√ßa criativa (concorr√™ncia); `concat` = ordem e progresso (sequencial).                                                                                                                                                                                                                                                                                 |
| 66  | O `java.util.concurrent.atomic` como `AtomicInteger` utiliza internamente locks expl√≠citos (como `ReentrantLock`) para garantir atomicidade em suas opera√ß√µes, oferecendo apenas uma sintaxe mais conveniente sobre o bloqueio manual.                                                                                                                   | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `AtomicInteger` e amigos s√£o mais espertos! Eles usam truques de m√°gica do processador ü™Ñ (como Compare-And-Swap - CAS) para fazer atualiza√ß√µes at√¥micas sem precisar de "cadeados" (locks) na maioria das vezes. Isso √© muito mais r√°pido sob conten√ß√£o moderada. üí°**Dica:** At√¥micos = CAS (geralmente), n√£o locks. Mais leveza e escalabilidade!                                                                                                                                                                                                               |
| 97  | No FFM API, uma `Arena` do tipo `Arena.ofConfined()` cria uma regi√£o de mem√≥ria off-heap cujo ciclo de vida √© limitado ao escopo do bloco `try-with-resources` em que foi declarada, e apenas a thread que a criou pode acess√°-la ou fech√°-la.                                                                                                           | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `Arena.ofConfined()` √© como um "playground particular" üé† para uma thread. S√≥ ela pode entrar e sair, e quando ela sai do `try` (port√£o do playground), todos os brinquedos (mem√≥ria) s√£o guardados automaticamente. üí°**Dica:** "Confined" = privado para a thread e com limpeza autom√°tica no `try-with-resources`. üßº                                                                                                                                                                                                                                           |
| 98  | Em RxJava, `TestScheduler` √© uma ferramenta utilizada para testar `Observables` baseados em tempo, permitindo avan√ßar o tempo virtualmente para verificar emiss√µes sem a necessidade de esperar o tempo real decorrer, mas n√£o suporta testes de operadores que usam `Schedulers` diferentes do `TestScheduler` em si.                                   | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `TestScheduler` √© um "controle remoto do tempo" ‚è≥ para seus testes. Ele acelera o rel√≥gio! E sim, voc√™ pode us√°-lo para substituir os `Schedulers` padr√£o (como `computation()` ou `io()`) usando `RxJavaPlugins` para testar operadores que normalmente usariam outros `Schedulers`. üí°**Dica:** `TestScheduler` + `RxJavaPlugins.setComputationSchedulerHandler(...)` = controle total do tempo nos testes. üï∞Ô∏è                                                                                                                                                  |
| 99  | Threads virtuais herdam automaticamente todas as propriedades da thread de plataforma que as criou, incluindo prioridade, status de daemon e o `ContextClassLoader`.                                                                                                                                                                                     | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Threads virtuais s√£o mais "independentes". Elas t√™m sua pr√≥pria maneira de ser. Elas n√£o herdam automaticamente todas essas coisas. Por exemplo, elas sempre t√™m prioridade normal e s√£o sempre nondaemon (a menos que a thread de f√°brica especifique o contr√°rio para o status de daemon). üí°**Dica:** Virtuais s√£o "novas em folha" em muitos aspectos, n√£o meras c√≥pias da m√£e-plataforma. üê£                                                                                                                                                                  |
| 100 | Para um perito da Pol√≠cia Federal analisando um sistema Java legado que faz uso intensivo de I/O de rede e sofre de baixa escalabilidade devido ao esgotamento de threads de plataforma, a migra√ß√£o para threads virtuais (JDK 21+) seria uma estrat√©gia de moderniza√ß√£o altamente recomend√°vel para melhorar o throughput e a resili√™ncia da aplica√ß√£o. | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos (para um futuro perito üòâ):** Se o sistema antigo est√° "engasgando" porque usa muitas threads pesadas para esperar a rede, as threads virtuais s√£o como dar a cada tarefa uma "bicicleta super leve" üö≤ em vez de um "caminh√£o pesado" üöö. Ele consegue ter muito mais "bicicletas" rodando e esperando sem gastar tanta "gasolina" (recursos). üí°**Dica de Perito:** Threads Virtuais s√£o a resposta moderna para o cl√°ssico "thread-per-request" em aplica√ß√µes I/O-bound, maximizando a utiliza√ß√£o do hardware com m√≠nima sobrecarga. Ideal para investigar! üïµÔ∏è‚Äç‚ôÇÔ∏è |
| 101 | `Sequenced Collections` (JEP 431), introduzidas no JDK 21, adicionam uma ordem de encontro bem definida a interfaces como `Collection`, `Set` e `Map`, permitindo acesso previs√≠vel ao primeiro e √∫ltimo elemento.                                                                                                                                       | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Pense numa caixa de brinquedos bagun√ßada (`Collection` antiga). Com as `Sequenced Collections`, a caixa fica organizada em fila! Agora voc√™ sabe quem √© o primeiro ü•á e o √∫ltimo Íº¥ brinquedo, e pode at√© olhar a fila de tr√°s pra frente. üí°**Dica:** "Sequenced" = Fila indiana para suas cole√ß√µes! `getFirst()`, `getLast()`, `reversed()`.                                                                                                                                                                                                                      |
| 102 | `Record Patterns` (JEP 440), finalizados no Java 21, permitem desestruturar inst√¢ncias de `Record` diretamente em declara√ß√µes `switch` e `instanceof`, mas n√£o podem ser usados em `for-each loops` aprimorados.                                                                                                                                         | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `Record Patterns` s√£o como "raios-X"  R√∂ntgen para seus `Records`. Eles deixam voc√™ ver o que tem dentro (os componentes) de forma f√°cil no `switch` e `instanceof`. Embora n√£o diretamente em `for-each` como desestrutura√ß√£o, o conceito √© sobre inspe√ß√£o e extra√ß√£o de dados. üí°**Dica:** Padr√µes de Record s√£o para "olhar dentro" e extrair componentes com facilidade.                                                                                                                                                                                       |
| 103 | `Pattern Matching for switch` (JEP 441), finalizado no Java 21, permite usar padr√µes de tipo (type patterns) e `Record Patterns` nos `case` labels de uma instru√ß√£o `switch`, tornando o c√≥digo mais expressivo e seguro.                                                                                                                                | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** O `switch` ficou mais esperto! üß† Antes ele s√≥ olhava n√∫meros ou palavras exatas. Agora ele consegue "reconhecer" tipos diferentes de brinquedos (`case Circle c:`) e at√© o que tem dentro de alguns deles (`case Point(int x, int y):`). üí°**Dica:** `switch` com padr√µes = menos `if-else instanceof` e mais clareza.                                                                                                                                                                                                                                            |
| 104 | Com `Pattern Matching for switch`, √© obrigat√≥rio que a instru√ß√£o `switch` cubra todos os valores poss√≠veis do tipo do seletor, caso contr√°rio, um erro de compila√ß√£o ocorrer√°, mesmo se uma cl√°usula `default` estiver presente.                                                                                                                         | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Se o `switch` esperto n√£o cobrir todas as possibilidades, ele reclama (erro de compila√ß√£o) *a menos que* voc√™ tenha um "plano B" (`default`) para o que ele n√£o reconhecer. O `default` ainda √© o coringa. üí°**Dica:** Exaustividade √© chave, mas `default` ainda salva o dia se voc√™ n√£o cobrir tudo explicitamente. üÉè                                                                                                                                                                                                                                           |
| 105 | `String Templates` (JEP 430), um recurso em preview no Java 21, visam oferecer uma forma mais segura e flex√≠vel de compor strings do que a concatena√ß√£o tradicional ou `String.format()`, permitindo processadores de template customizados.                                                                                                             | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `String Templates` s√£o como "cartinhas m√°gicas" üíå onde voc√™ pode colocar espa√ßos para preencher com nomes ou n√∫meros (`STR."Ol√° \{nome}"`). √â mais f√°cil de ler e pode ter "m√°gicas" extras (processadores) para fazer coisas como checar seguran√ßa ou formatar. üí°**Dica:** Pense em `f-strings` do Python ou interpola√ß√£o do Kotlin, mas com esteroides (processadores).                                                                                                                                                                                        |
| 106 | As `Sequenced Collections` obrigam que todas as suas implementa√ß√µes, como `ArrayList` e `LinkedHashSet`, sejam imut√°veis para garantir a consist√™ncia da ordem de encontro.                                                                                                                                                                              | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Ser "sequenciada" significa apenas que a cole√ß√£o tem uma ordem definida, como uma fila. N√£o quer dizer que voc√™ n√£o pode mudar quem est√° na fila (`ArrayList` ainda √© mut√°vel). Imutabilidade √© outra hist√≥ria. üí°**Dica:** Ordem ‚â† Imutabilidade. `List.of()` cria uma sequenciada e imut√°vel. `new ArrayList()` cria uma sequenciada e mut√°vel.                                                                                                                                                                                                                  |
| 107 | `Unnamed Patterns and Variables` (JEP 443), um recurso em preview no Java 21, permitem usar o underscore (`_`) para indicar vari√°veis ou componentes de padr√£o que n√£o ser√£o utilizados, melhorando a legibilidade do c√≥digo.                                                                                                                            | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** √Äs vezes voc√™ pega um monte de informa√ß√µes, mas s√≥ quer usar algumas. Com `_`, voc√™ diz pro Java: "essa parte aqui eu n√£o vou usar, pode ignorar". Deixa o c√≥digo mais limpinho. üí°**Dica:** `_` = "n√£o me importo com este valor". √ötil em desestrutura√ß√£o e `catch` de exce√ß√µes.                                                                                                                                                                                                                                                                                 |
| 108 | `Scoped Values` (JEP 446), um recurso em preview no Java 21, s√£o projetados para compartilhar dados imut√°veis entre threads, especialmente entre uma thread pai e threads filhas (incluindo virtuais), de forma mais eficiente e segura que `InheritableThreadLocal`.                                                                                    | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `Scoped Values` s√£o como "bilhetinhos" üóíÔ∏è que uma thread pai pode deixar para suas threads filhas lerem. √â uma forma organizada e segura de passar informa√ß√µes sem que as filhas possam bagun√ßar o bilhete original. üí°**Dica:** `ScopedValue` = `InheritableThreadLocal` moderno, mais eficiente e focado em imutabilidade para threads virtuais.                                                                                                                                                                                                                |
| 109 | O `Foreign Function & Memory API (FFM API)` no JDK 21 requer o uso da palavra-chave `native` para declarar m√©todos Java que invocar√£o fun√ß√µes de bibliotecas C/C++.                                                                                                                                                                                      | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** O FFM API √© a nova forma chique de falar com c√≥digo C. Ele n√£o usa a velha palavra `native`. Em vez disso, voc√™ usa `Linker` e `SymbolLookup` para "encontrar" a fun√ß√£o C e `MethodHandle` para "cham√°-la". üí°**Dica:** FFM API abandona `native` por uma abordagem mais program√°tica e segura para interopera√ß√£o.                                                                                                                                                                                                                                                 |
| 110 | `Pattern Matching for instanceof` (JEP 394), finalizado no Java 16, permite n√£o apenas testar o tipo de um objeto, mas tamb√©m declarar uma vari√°vel de binding do tipo testado, se o teste for verdadeiro, dentro do mesmo escopo.                                                                                                                       | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Antes, voc√™ perguntava "isso √© um c√≠rculo?" e depois "ok, agora me d√° ele como c√≠rculo". Com `instanceof` moderno, voc√™ pergunta "se isso for um c√≠rculo `c`, ent√£o..." e j√° pode usar `c` como c√≠rculo. üí°**Dica:** `if (obj instanceof String s)` = teste e casting inteligente em uma s√≥ tacada! üí°                                                                                                                                                                                                                                                             |
| 111 | Text Blocks (JEP 378), introduzidos no Java 15, permitem criar strings multi-linha usando tr√™s aspas duplas (`"""`), mas n√£o removem automaticamente a indenta√ß√£o incidental comum.                                                                                                                                                                      | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Text Blocks s√£o para escrever text√µes no c√≥digo, como poemas. O Java √© esperto e tira os espa√ßos extras da frente de cada linha (indenta√ß√£o incidental) para o texto ficar alinhado. üí°**Dica:** Text Blocks s√£o √≥timos para SQL, JSON, HTML embutido. A indenta√ß√£o √© gerenciada! üìè                                                                                                                                                                                                                                                                               |
| 112 | O `java.util.HexFormat` (Java 17) fornece uma API padronizada para converter entre bytes e suas representa√ß√µes hexadecimais, substituindo a necessidade de bibliotecas de terceiros ou implementa√ß√µes manuais para essa tarefa comum.                                                                                                                    | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Antes, para transformar n√∫meros secretos (bytes) em c√≥digos hexadecimais (0-9, A-F), cada um fazia de um jeito. Agora o Java tem uma "ferramenta oficial" para isso, o `HexFormat`. üí°**Dica:** Precisa de Hex? `HexFormat.of().formatHex(bytes)`. Padronizado e eficiente! ‚öôÔ∏è                                                                                                                                                                                                                                                                                     |
| 113 | Sealed Classes and Interfaces (JEP 409), finalizadas no Java 17, permitem restringir quais outras classes ou interfaces podem estender ou implementar uma classe ou interface selada, mas n√£o podem ser usadas em conjunto com `Records`.                                                                                                                | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Classes Seladas s√£o como clubes exclusivos üëë. S√≥ quem est√° na lista (`permits`) pode entrar (herdar/implementar). E sim, `Records` podem implementar interfaces seladas ou ser declarados como `permits` de uma classe selada! üí°**Dica:** Sealed + Records = controle fino de hierarquias de dados imut√°veis.                                                                                                                                                                                                                                                    |
| 114 | O construtor `Executors.newSingleThreadExecutor()` cria um `ExecutorService` que utiliza apenas uma thread de plataforma, garantindo que as tarefas submetidas sejam executadas sequencialmente. Essa thread nunca √© uma thread virtual.                                                                                                                 | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Esse executor √© como ter um √∫nico funcion√°rio super focado. Ele pega uma tarefa, faz, depois pega a pr√≥xima. Ele sempre usa um funcion√°rio "tradicional" (thread de plataforma), nunca um "tempor√°rio" (virtual). üí°**Dica:** `newSingleThreadExecutor` √© para serializa√ß√£o de tarefas em uma thread de plataforma.                                                                                                                                                                                                                                                |
| 115 | `Pattern Matching for switch` no Java 21 introduziu a capacidade de usar `when` clauses (guarded patterns) para refinar ainda mais a condi√ß√£o de um `case` label.                                                                                                                                                                                        | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** No `switch` esperto, al√©m de ver o tipo do brinquedo, voc√™ pode adicionar uma "condi√ß√£o extra" com `when`. Tipo: "se for um c√≠rculo `c` *E QUANDO* (`when`) o raio dele for maior que 10...". üí°**Dica:** `case Circulo c when c.raio() > 10:` = mais poder de decis√£o dentro do `switch`.                                                                                                                                                                                                                                                                         |
| 116 | O recurso de `String Templates` (JEP 430) √© limitado a processadores de template fornecidos pelo JDK, como `STR` e `RAW`, n√£o permitindo que desenvolvedores criem seus pr√≥prios processadores de template.                                                                                                                                              | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** O Java d√° alguns processadores de "cartinhas m√°gicas" prontos (`STR` para texto normal, `RAW` para texto sem processar), mas ele tamb√©m deixa voc√™ criar os seus pr√≥prios com regras especiais! üí°**Dica:** `StringTemplate.Processor` √© a interface para criar sua pr√≥pria m√°gica de templates. üßô                                                                                                                                                                                                                                                                |
| 117 | `Unnamed Classes and Instance Main Methods` (JEP 445), um recurso em preview no Java 21, visa simplificar a escrita de pequenos programas e scripts Java, permitindo que m√©todos `main` sejam declarados em classes sem nome expl√≠cito e como m√©todos de inst√¢ncia.                                                                                      | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Para programinhas r√°pidos, o Java 21 quer deixar voc√™ come√ßar a escrever o c√≥digo principal sem ter que criar toda aquela "casca" de `public class MeuPrograma { public static void main... }`. Mais direto ao ponto! üöÄ üí°**Dica:** Menos boilerplate para iniciantes e scripts! (ainda em preview)                                                                                                                                                                                                                                                               |
| 118 | `java.util.RandomGenerator` (Java 17) √© uma nova interface para geradores de n√∫meros pseudoaleat√≥rios (PRNGs), oferecendo uma API mais rica e flex√≠vel que a antiga classe `java.util.Random`, com v√°rias implementa√ß√µes novas.                                                                                                                          | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** A velha `Random` era ok, mas a nova `RandomGenerator` √© como uma caixa de ferramentas cheia de geradores de n√∫meros diferentes üé≤, cada um bom para uma coisa, e com mais op√ß√µes. üí°**Dica:** Para PRNGs modernos e variados, use `RandomGenerator.of("L128X256MixRandom")` etc.                                                                                                                                                                                                                                                                                   |
| 119 | Ao usar `ScopedValue.where(scopedValue, value).run(runnable)` no Java 21, o `value` associado ao `scopedValue` estar√° dispon√≠vel para a `runnable` e para qualquer thread filha que ela criar, mas n√£o para chamadas de m√©todo dentro da `runnable` que ocorram em threads n√£o filhas.                                                                   | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `ScopedValue` √© como um "segredo" que voc√™ conta para uma tarefa e para os "ajudantes" (threads filhas) dela. Se a tarefa pedir ajuda para um "estranho" (thread n√£o filha), o estranho n√£o fica sabendo do segredo. üí°**Dica:** `ScopedValue` propaga para baixo na hierarquia de chamadas *dentro da mesma thread ou para threads filhas criadas no escopo*.                                                                                                                                                                                                     |
| 120 | Switch Expressions (JEP 361), finalizadas no Java 14, sempre exigem uma cl√°usula `default` para garantir a exaustividade, mesmo que todos os poss√≠veis valores do seletor sejam cobertos por `case` labels.                                                                                                                                              | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Se o `switch` que *retorna um valor* (expression) j√° cobre todos os casos poss√≠veis (tipo um `enum`), ele √© esperto o suficiente para n√£o precisar de um `default`. Mas se faltar algum, a√≠ sim ele pede o `default`. üí°**Dica:** Exaustividade em Switch Expressions pode dispensar `default` para enums e tipos selados. üëç                                                                                                                                                                                                                                      |
| 121 | O `Vector API` (Incubating no JDK 21, JEPs 438, 448, etc.) visa fornecer uma API para expressar computa√ß√µes vetoriais que compilam em tempo de execu√ß√£o para instru√ß√µes vetoriais √≥timas em arquiteturas de CPU suportadas, melhorando o desempenho de opera√ß√µes paralelas em arrays.                                                                    | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** O Vector API √© como dar "superpoderes" üí™ para o Java lidar com muitos n√∫meros de uma vez s√≥, usando instru√ß√µes especiais do processador que s√£o muito r√°pidas para isso. üí°**Dica:** Pense em SIMD (Single Instruction, Multiple Data) diretamente no Java para c√°lculos num√©ricos pesados. (Ainda em incuba√ß√£o!)                                                                                                                                                                                                                                                 |
| 122 | As `Sequenced Collections` no Java 21 garantem que a ordem de itera√ß√£o ser√° sempre a ordem de inser√ß√£o para todas as suas implementa√ß√µes, incluindo aquelas baseadas em √°rvores como `TreeSet`.                                                                                                                                                          | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** `Sequenced Collections` garantem *uma* ordem, mas n√£o necessariamente a de inser√ß√£o. Para `TreeSet`, a ordem √© a de ordena√ß√£o natural dos elementos (ou pelo `Comparator`). Para `LinkedHashSet`, sim, √© a de inser√ß√£o. üí°**Dica:** Ordem de encontro ‚â† Ordem de inser√ß√£o para todas as cole√ß√µes sequenciadas. Verifique a especifica√ß√£o de cada uma! üßê                                                                                                                                                                                                           |
| 123 | `Pattern Matching for switch` (JEP 441) permite o uso de `null` como um `case label` expl√≠cito, eliminando a necessidade de uma verifica√ß√£o pr√©via de nulidade antes da instru√ß√£o `switch`.                                                                                                                                                              | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** Antes, voc√™ tinha que ver se a caixa estava vazia (`null`) *antes* de olhar o que tinha dentro com o `switch`. Agora o `switch` esperto j√° pode ter um "lugar" (`case null:`) especial para caixas vazias. üí°**Dica:** `case null:` simplifica o tratamento de nulos diretamente no `switch`. Menos `if (obj == null)`! ‚ú®                                                                                                                                                                                                                                          |
| 124 | Com `String Templates` (JEP 430), o processador de template padr√£o `STR` realiza automaticamente a sanitiza√ß√£o de entradas para prevenir vulnerabilidades de inje√ß√£o (como SQL Injection ou XSS) ao interpolar valores em strings.                                                                                                                       | F        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** O processador `STR` √© para juntar texto de forma simples. Ele n√£o √© um "guarda-costas" üõ°Ô∏è autom√°tico contra truques maliciosos (inje√ß√£o). Para isso, voc√™ precisaria de processadores de template mais especializados ou validar as entradas. üí°**Dica:** `STR` √© sobre interpola√ß√£o, n√£o sanitiza√ß√£o autom√°tica. Seguran√ßa √© sua responsabilidade!                                                                                                                                                                                                               |
| 125 | `Scoped Values` (JEP 446) s√£o sempre imut√°veis. Uma vez que um `ScopedValue` √© definido com um valor dentro de um escopo usando `ScopedValue.where(...).run(...)`, seu valor n√£o pode ser alterado dentro daquele escopo ou por threads filhas.                                                                                                          | V        | üë®‚Äçüè´ **Explique como se eu tivesse 5 anos:** O "bilhetinho" (`ScopedValue`) que a thread pai deixa √© escrito com "tinta permanente". As threads filhas podem ler, mas n√£o podem rabiscar ou mudar o que est√° escrito nele naquele "turno" (escopo). üí°**Dica:** Imutabilidade por escopo √© uma caracter√≠stica chave de `Scoped Values`, garantindo previsibilidade. ‚úÖ                                                                                                                                                                                                                                           |
| 126 | No contexto da plataforma Java, um filtro de serializa√ß√£o JVM-wide, uma vez definido, √© sempre aplicado compulsoriamente, mesmo que um filtro espec√≠fico de stream seja configurado e n√£o o invoque.                                                                                                                                                     | F        | üë®‚Äçüè´: Um filtro JVM-wide pode ser combinado ou, se o filtro de stream n√£o o invocar explicitamente, pode ser efetivamente ignorado para aquele stream. üí° Dica: A intera√ß√£o entre filtros JVM-wide e de stream depende da implementa√ß√£o do filtro de stream.                                                                                                                                                                                                                                                                                                                                                    |
| 127 | A anota√ß√£o `@Deprecated` em Java com o atributo `forRemoval=true` indica que a API em quest√£o ser√° mantida por raz√µes de compatibilidade, mas seu uso n√£o √© mais recomendado.                                                                                                                                                                            | F        | üë®‚Äçüè´: `forRemoval=true` sinaliza que a API est√° sujeita √† remo√ß√£o em uma vers√£o futura do JDK, sendo um aviso mais forte para migra√ß√£o. üí° Dica: `forRemoval=true` √© um sinal de alerta m√°ximo üö®!                                                                                                                                                                                                                                                                                                                                                                                                              |
| 128 | O XML Catalog API em Java, ao resolver refer√™ncias externas, prioriza entradas `uri` sobre entradas `system` para DTDs, seguindo o padr√£o OASIS.                                                                                                                                                                                                         | F        | üë®‚Äçüè´: O padr√£o OASIS d√° prefer√™ncia a entradas `system` para DTDs. A API Java XML Catalog n√£o faz essa distin√ß√£o estrita, mas √© boa pr√°tica seguir o padr√£o. üí° Dica: Pense na origem da especifica√ß√£o; DTDs usam `SYSTEM` identifier.                                                                                                                                                                                                                                                                                                                                                                          |
| 129 | Por padr√£o, o recurso `USE_CATALOG` nos processadores XML do JDK Java √© definido como `false`, exigindo configura√ß√£o expl√≠cita para habilitar o uso de cat√°logos XML.                                                                                                                                                                                    | F        | üë®‚Äçüè´: O `USE_CATALOG` √© `true` por padr√£o. A API tentar√° usar cat√°logos se este estiver `true` E um arquivo de cat√°logo estiver dispon√≠vel. üí° Dica: O JDK tende a facilitar o uso de recursos √∫teis por padr√£o.                                                                                                                                                                                                                                                                                                                                                                                                |
| 130 | As cole√ß√µes criadas com `List.of()` em Java s√£o imut√°veis, mas permitem a modifica√ß√£o de seus elementos se estes forem mut√°veis, sem lan√ßar exce√ß√£o na cole√ß√£o em si.                                                                                                                                                                                    | V        | üë®‚Äçüè´: Correto. A cole√ß√£o √© estruturalmente imut√°vel (n√£o pode adicionar/remover). Se os objetos *dentro* dela forem mut√°veis, eles podem ser alterados. üí° Dica: Imutabilidade da cole√ß√£o ‚â† imutabilidade dos elementos contidos. Cuidado com essa pegadinha! üé£                                                                                                                                                                                                                                                                                                                                                |
| 131 | A ordem de itera√ß√£o para elementos de um `Set` criado com `Set.of()` √© garantida e consistente entre diferentes execu√ß√µes da JVM.                                                                                                                                                                                                                        | F        | üë®‚Äçüè´: A ordem de itera√ß√£o para `Set.of()` e `Map.of()` √© randomizada e provavelmente diferente entre execu√ß√µes da JVM, para ajudar a identificar depend√™ncias de ordem. üí° Dica: Se precisar de ordem, use `List.of()` ou cole√ß√µes ordenadas espec√≠ficas.                                                                                                                                                                                                                                                                                                                                                       |
| 132 | O m√©todo `getFirst()` da interface `SequencedCollection` √© aplic√°vel a qualquer cole√ß√£o que implemente esta interface, incluindo `LinkedHashSet` e `ArrayList`.                                                                                                                                                                                          | V        | üë®‚Äçüè´: `SequencedCollection` foi introduzida para prover uma API uniforme para cole√ß√µes com ordem definida, incluindo acesso ao primeiro/√∫ltimo elemento. üí° Dica: Lembre que `SequencedCollection` √© a chave para opera√ß√µes de extremidade uniformes. üîë                                                                                                                                                                                                                                                                                                                                                        |
| 133 | Ao usar a Process API, o m√©todo `ProcessBuilder.start()` retorna uma inst√¢ncia de `ProcessHandle`, permitindo controle direto sobre processos nativos.                                                                                                                                                                                                   | F        | üë®‚Äçüè´: `ProcessBuilder.start()` retorna uma inst√¢ncia de `Process`. `ProcessHandle` √© usado para interagir com processos nativos em geral, n√£o apenas os iniciados pela aplica√ß√£o. üí° Dica: `Builder` constr√≥i o `Process`, `Handle` "pega" qualquer um.                                                                                                                                                                                                                                                                                                                                                         |
| 134 | A Preferences API em Java armazena dados de prefer√™ncia exclusivamente no sistema de arquivos local, em um formato similar a arquivos `.properties`.                                                                                                                                                                                                     | F        | üë®‚Äçüè´: A Preferences API √© back-end neutral; pode usar o registro do Windows, arquivos, LDAP, etc., dependendo da implementa√ß√£o. üí° Dica: "Back-end neutral" √© a palavra-chave aqui, indicando flexibilidade de armazenamento.                                                                                                                                                                                                                                                                                                                                                                                   |
| 135 | Todas as classes `Handler` do Java Logging API, como `FileHandler` e `ConsoleHandler`, s√£o inerentemente thread-safe e podem ser compartilhadas entre m√∫ltiplos loggers sem sincroniza√ß√£o externa.                                                                                                                                                       | F        | üë®‚Äçüè´: Embora `Loggers` sejam thread-safe, a thread-safety de `Handlers` pode variar. `FileHandler` e `ConsoleHandler` geralmente s√£o, mas a documenta√ß√£o deve ser consultada. üí° Dica: Concorr√™ncia em `Handlers` √© um ponto de aten√ß√£o, verifique a documenta√ß√£o! üßê                                                                                                                                                                                                                                                                                                                                           |
| 136 | Em Java NIO, um `ByteBuffer` alocado com `ByteBuffer.allocateDirect()` reside fora do heap da JVM, o que pode oferecer vantagens de desempenho para opera√ß√µes de I/O nativas.                                                                                                                                                                            | V        | üë®‚Äçüè´: Correto. Buffers diretos s√£o alocados fora do heap e s√£o ideais para I/O com c√≥digo nativo, pois evitam c√≥pias entre o heap da JVM e a mem√≥ria nativa. üí° Dica: "Direct" = direto para o nativo, sem paradas no heap! üöÄ                                                                                                                                                                                                                                                                                                                                                                                  |
| 137 | A propriedade de sistema `http.nonProxyHosts` √© utilizada exclusivamente pelo protocolo HTTP, n√£o sendo considerada pelo handler de protocolo HTTPS.                                                                                                                                                                                                     | F        | üë®‚Äçüè´: O handler HTTPS tamb√©m utiliza a propriedade `http.nonProxyHosts` para determinar quais hosts devem ser acessados diretamente. üí° Dica: HTTPS √© HTTP sobre SSL; muitas configura√ß√µes de proxy s√£o compartilhadas.                                                                                                                                                                                                                                                                                                                                                                                         |
| 138 | Ao configurar um SOCKS proxy em Java, se um `java.net.Authenticator` estiver registrado, ele ser√° consultado para obter credenciais antes de verificar as propriedades de sistema `java.net.socks.username`.                                                                                                                                             | V        | üë®‚Äçüè´: Correto. A aquisi√ß√£o de credenciais SOCKS segue uma ordem: `Authenticator` primeiro, depois propriedades de sistema, e por fim `user.name` (sem senha). üí° Dica: `Authenticator` √© o "gerente" de senhas, tem prioridade.                                                                                                                                                                                                                                                                                                                                                                                 |
| 139 | Geradores de Pseudorandom Numbers (PRNGs) em Java, como os da classe `java.util.Random`, possuem um per√≠odo infinito, garantindo que nunca repetir√£o uma sequ√™ncia de n√∫meros.                                                                                                                                                                           | F        | üë®‚Äçüè´: PRNGs s√£o baseados em algoritmos determin√≠sticos e, portanto, t√™m um per√≠odo finito, ap√≥s o qual a sequ√™ncia de n√∫meros se repetir√°. üí° Dica: "Pseudo" em PRNG significa que n√£o √© verdadeiramente aleat√≥rio e tem ciclo. üîÑ                                                                                                                                                                                                                                                                                                                                                                              |
| 140 | A Foreign Function and Memory (FFM) API permite que programas Java interajam com c√≥digo nativo e acessem mem√≥ria nativa sem a necessidade do JNI (Java Native Interface).                                                                                                                                                                                | V        | üë®‚Äçüè´: Exato! A FFM API √© uma alternativa moderna ao JNI, buscando maior seguran√ßa e facilidade de uso para interoperabilidade nativa. üí° Dica: FFM API = JNI moderno e mais seguro.                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 141 | Ao usar a FFM API, um `Arena` do tipo `Arena.ofConfined()` pode ser fechado por qualquer thread, liberando a mem√≥ria associada, desde que a arena n√£o esteja mais em uso.                                                                                                                                                                                | F        | üë®‚Äçüè´: Uma `Arena` confinada (`Arena.ofConfined()`) possui uma "owner thread" (geralmente a que a criou) e somente esta thread pode fech√°-la. üí° Dica: "Confined" = confinado √† thread dona para o fechamento. üîí                                                                                                                                                                                                                                                                                                                                                                                                |
| 142 | A chamada `Linker.downcallHandle()` da FFM API, ao criar um handle para uma fun√ß√£o nativa, valida rigorosamente se o `FunctionDescriptor` fornecido corresponde √† assinatura real da fun√ß√£o C.                                                                                                                                                           | F        | üë®‚Äçüè´: O `Linker` n√£o tem como verificar se o `FunctionDescriptor` √© compat√≠vel com a fun√ß√£o nativa real. Um descritor incorreto pode levar a crashes na JVM. üí° Dica: A responsabilidade da corretude do descritor √© do desenvolvedor! üí£                                                                                                                                                                                                                                                                                                                                                                       |
| 143 | Scoped Values em Java s√£o projetados para compartilhar dados entre threads de forma segura e eficiente, substituindo completamente a necessidade de `ThreadLocal` para todos os casos de uso.                                                                                                                                                            | F        | üë®‚Äçüè´: Scoped Values s√£o uma alternativa em muitos cen√°rios, especialmente para imutabilidade e propaga√ß√£o controlada, mas `ThreadLocal` ainda pode ter usos, como cache de objetos mut√°veis (embora com ressalvas para Virtual Threads). üí° Dica: Scoped Values = foco na seguran√ßa e escopo definido.                                                                                                                                                                                                                                                                                                          |
| 144 | Virtual Threads em Java s√£o sempre mais r√°pidos que Platform Threads para executar qualquer tipo de tarefa, devido √† sua natureza leve.                                                                                                                                                                                                                  | F        | üë®‚Äçüè´: Virtual Threads aumentam a escalabilidade (throughput) para tarefas bloqueantes de I/O, mas n√£o executam c√≥digo CPU-bound mais r√°pido que Platform Threads. üí° Dica: Virtual Threads = mais tarefas concorrentes, n√£o CPU mais r√°pida. üèÉ‚Äç‚ôÇÔ∏è vs üèãÔ∏è‚Äç‚ôÄÔ∏è                                                                                                                                                                                                                                                                                                                                                    |
| 145 | Ao usar Virtual Threads, √© uma boa pr√°tica criar um pool de Virtual Threads usando `Executors.newFixedThreadPool()` para gerenciar seu ciclo de vida e reutiliza√ß√£o.                                                                                                                                                                                     | F        | üë®‚Äçüè´: Virtual Threads s√£o baratos e n√£o devem ser agrupados (pooled). Use `Executors.newVirtualThreadPerTaskExecutor()` que cria um novo Virtual Thread para cada tarefa. üí° Dica: Virtual Thread = um por tarefa, sem pool! üö´üèä                                                                                                                                                                                                                                                                                                                                                                               |
| 146 | A propriedade de sistema `jdk.httpclient.allowRestrictedHeaders` permite que o c√≥digo do usu√°rio defina qualquer cabe√ßalho HTTP, incluindo `Connection` e `Content-Length`, sem restri√ß√µes.                                                                                                                                                              | F        | üë®‚Äçüè´: Essa propriedade permite definir *alguns* cabe√ßalhos normalmente restritos, mas n√£o *todos*. Por exemplo, `Authorization` com `Authenticator` configurado n√£o pode ser sobrescrito. üí° Dica: "allow" n√£o significa "allow all". Cuidado com os "asteriscos"! ‚ú®                                                                                                                                                                                                                                                                                                                                            |
| 147 | O utilit√°rio `jextract`, usado com a FFM API, gera automaticamente bindings Java a partir de arquivos de cabe√ßalho C, eliminando a necessidade de criar manualmente `MethodHandle` para downcalls.                                                                                                                                                       | V        | üë®‚Äçüè´: Correto! `jextract` automatiza a cria√ß√£o dos bindings Java, incluindo os `MethodHandle` e `FunctionDescriptor` necess√°rios para chamar fun√ß√µes nativas. üí° Dica: `jextract` √© seu amigo para evitar o trabalho manual com FFM. üõ†Ô∏è                                                                                                                                                                                                                                                                                                                                                                        |
| 148 | Em Java Logging, um `LogRecord` formatado com `XMLFormatter` sempre ser√° um documento XML bem formado, mesmo em caso de crash da JVM durante a escrita do log.                                                                                                                                                                                           | F        | üë®‚Äçüè´: Em caso de crash da JVM, o `XMLFormatter` pode n√£o conseguir fechar a tag `<log>` raiz, resultando em um XML n√£o bem formado. Ferramentas de an√°lise devem estar preparadas para isso. üí° Dica: Logs XML podem ser "interrompidos" por falhas.                                                                                                                                                                                                                                                                                                                                                            |
| 149 | A ferramenta `jdeprscan` √© utilizada para analisar o c√≥digo-fonte Java (`.java`) em busca de usos de APIs obsoletas do JDK.                                                                                                                                                                                                                              | F        | üë®‚Äçüè´: `jdeprscan` analisa arquivos de classe compilados (`.class`) ou arquivos JAR, n√£o o c√≥digo-fonte diretamente. üí° Dica: `jdeprscan` opera no "p√≥s-compila√ß√£o". üîç                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 150 | A interface `SequencedMap` garante que o m√©todo `reversed()` sempre retorna uma vis√£o serializ√°vel do mapa, desde que o mapa original seja serializ√°vel.                                                                                                                                                                                                 | F        | üë®‚Äçüè´: A vis√£o reversa de um `SequencedMap` geralmente *n√£o* √© serializ√°vel, mesmo que o mapa original seja. üí° Dica: Serializa√ß√£o de vis√µes complexas nem sempre √© suportada ou trivial.                                                                                                                                                                                                                                                                                                                                                                                                                        |



