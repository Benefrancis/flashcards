| id  | afirma√ß√£o                                                                                                                                                                                                                        | resposta | explica√ß√£o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | Um sistema operacional atua como um intermedi√°rio entre o hardware do computador e os programas aplicativos, gerenciando os recursos do sistema.                                                                                 | V        | Correto! ‚úÖ Pense no SO como o maestro de uma orquestra (hardware e software). Ele garante que tudo funcione em harmonia. **Dica Cespe:** Essa √© a defini√ß√£o cl√°ssica, sempre visada!                                                                                                                                                                                                                                                                                                                       |
| 2   | O kernel √© um aplicativo opcional em um sistema operacional, utilizado principalmente para interfaces gr√°ficas.                                                                                                                  | F        | Falso! ‚ùå O kernel √© o *n√∫cleo* do SO, essencial e n√£o opcional. Ele lida com as tarefas mais cr√≠ticas (gerenciar CPU, mem√≥ria). A interface gr√°fica (GUI) √© uma camada acima. **Pegadinha:** Confundir kernel com GUI. O kernel √© o motor, a GUI √© o painel.                                                                                                                                                                                                                                               |
| 3   | Gerenciamento de mem√≥ria √© uma fun√ß√£o primordial do sistema operacional, incluindo aloca√ß√£o e desaloca√ß√£o de espa√ßo para processos.                                                                                              | V        | Verdadeiro! ‚úÖ O SO √© o "zelador" da mem√≥ria. Ele decide quem ganha espa√ßo e quando esse espa√ßo √© liberado. **Dica:** Sem isso, os programas "brigariam" por mem√≥ria, causando o caos.                                                                                                                                                                                                                                                                                                                      |
| 4   | Em um sistema multitarefa preemptivo, um processo s√≥ libera a CPU quando ele decide voluntariamente faz√™-lo.                                                                                                                     | F        | Falso! ‚ùå Isso descreve multitarefa *cooperativa*. Na preemptiva, o SO pode "expulsar" (preemptar) um processo da CPU para dar vez a outro. **Dica Cespe:** "Preemptivo" = o SO tem o poder de interromper. "Cooperativo" = o processo colabora.                                                                                                                                                                                                                                                            |
| 5   | O kernel Linux foi criado por Linus Torvalds e √© um software de c√≥digo aberto.                                                                                                                                                   | V        | Verdadeiro! ‚úÖ Linus Torvalds √© o pai do kernel Linux, e seu c√≥digo aberto permitiu uma colabora√ß√£o mundial. **Dica:** Fato hist√≥rico fundamental e muito cobrado.                                                                                                                                                                                                                                                                                                                                          |
| 6   | GNU/Linux e Linux referem-se exatamente √† mesma coisa, sendo "GNU" apenas uma marca alternativa.                                                                                                                                 | F        | Falso! ‚ùå Linux √© o kernel. GNU/Linux √© o sistema operacional completo (kernel Linux + ferramentas GNU). **Dica Cespe:** Adoram essa distin√ß√£o sutil! Richard Stallman (GNU) √© um grande defensor dessa nomenclatura. üòâ                                                                                                                                                                                                                                                                                    |
| 7   | Red Hat Enterprise Linux (RHEL) √© uma distribui√ß√£o Linux comercial focada no mercado corporativo, conhecida por sua estabilidade e suporte de longo prazo.                                                                       | V        | Verdadeiro! ‚úÖ RHEL √© o "peso-pesado" das distros para empresas. Estabilidade e suporte s√£o seus pontos fortes. **Dica:** Palavra-chave: "corporativo" e "subscri√ß√£o".                                                                                                                                                                                                                                                                                                                                      |
| 8   | Oracle Linux √© uma distribui√ß√£o completamente independente e n√£o possui qualquer compatibilidade com RHEL.                                                                                                                       | F        | Falso! ‚ùå Oracle Linux √© *altamente* compat√≠vel com RHEL (compatibilidade bin√°ria), sendo compilado a partir do mesmo c√≥digo fonte que a Red Hat disponibiliza. **Pegadinha:** Achar que s√£o mundos totalmente separados. Oracle Linux √© um "clone" com esteroides (UEK).                                                                                                                                                                                                                                   |
| 9   | O Unbreakable Enterprise Kernel (UEK) √© um kernel otimizado pela Oracle, oferecido como uma op√ß√£o no Oracle Linux, al√©m do kernel compat√≠vel com RHEL (RHCK).                                                                    | V        | Verdadeiro! ‚úÖ Oracle Linux d√° essa "escolha de motor": o padr√£o RHEL (RHCK) ou o tunado pela Oracle (UEK), especialmente bom para rodar softwares da Oracle. **Dica:** UEK √© um diferencial do Oracle Linux.                                                                                                                                                                                                                                                                                               |
| 10  | O comando `useradd` no Linux √© utilizado para criar novas contas de usu√°rio no sistema.                                                                                                                                          | V        | Verdadeiro! ‚úÖ `useradd nome_usuario` √© o b√°sico da cria√ß√£o de usu√°rios. **Dica Concurseiro:** Memorize os comandos de ger. de usu√°rios: `useradd`, `usermod`, `userdel`, `passwd`.                                                                                                                                                                                                                                                                                                                         |
| 11  | O arquivo `/etc/fstab` armazena as senhas criptografadas dos usu√°rios no Linux.                                                                                                                                                  | F        | Falso! ‚ùå As senhas criptografadas ficam no `/etc/shadow`! ü§´ O `/etc/fstab` define como os sistemas de arquivos s√£o montados. **Pegadinha Cl√°ssica:** Confundir arquivos de configura√ß√£o. Pense: `shadow` = sombra, segredo.                                                                                                                                                                                                                                                                               |
| 12  | Em sistemas RHEL/Oracle Linux 7 e posteriores, o `systemd` √© o sistema de init e gerenciador de servi√ßos padr√£o, e o comando `systemctl` √© usado para gerenci√°-los.                                                              | V        | Verdadeiro! ‚úÖ `systemd` substituiu o antigo System V init. Comandos como `systemctl start httpd` s√£o o novo normal. **Dica:** `systemd` e `systemctl` s√£o cruciais em distros modernas. Dominar `systemctl status`, `start`, `stop`, `enable`, `disable` √© essencial.                                                                                                                                                                                                                                      |
| 13  | O comando `rpm -i meu_pacote.rpm` √© utilizado para desinstalar um pacote RPM no Linux.                                                                                                                                           | F        | Falso! ‚ùå `rpm -i` √© para *instalar*. Para desinstalar (erase), usa-se `rpm -e nome_do_pacote`. **Dica Mnem√¥nica:** `i`=install, `e`=erase, `U`=update, `q`=query. As op√ß√µes do `rpm` s√£o intuitivas!                                                                                                                                                                                                                                                                                                       |
| 14  | `yum install <pacote>` ou `dnf install <pacote>` em RHEL/Oracle Linux n√£o apenas instala o pacote solicitado, mas tamb√©m resolve e instala suas depend√™ncias automaticamente.                                                    | V        | Verdadeiro! ‚úÖ Essa √© a m√°gica do `yum`/`dnf`: eles s√£o "inteligentes" e buscam tudo o que o pacote precisa para funcionar, a partir dos reposit√≥rios configurados. **Dica:** Sem isso, instalar software seria um pesadelo de ca√ßar depend√™ncias.                                                                                                                                                                                                                                                          |
| 15  | O diret√≥rio `/etc/skel` no Linux cont√©m arquivos e diret√≥rios que s√£o copiados para o diret√≥rio home de um novo usu√°rio no momento de sua cria√ß√£o.                                                                               | V        | Verdadeiro! ‚úÖ "Skel" vem de "skeleton" (esqueleto). √â o modelo para os novos diret√≥rios `/home/usuario`. **Dica:** √ötil para padronizar configura√ß√µes iniciais para novos usu√°rios (ex: `.bashrc` customizado).                                                                                                                                                                                                                                                                                            |
| 16  | O comando `chmod 777 arquivo.txt` atribui permiss√µes de apenas leitura para o propriet√°rio, grupo e outros.                                                                                                                      | F        | Falso! ‚ùå `777` √© permiss√£o *total* (leitura, escrita e execu√ß√£o) para todos. `r=4, w=2, x=1`. Ent√£o, 7 = 4+2+1. **Dica de Seguran√ßa:** `chmod 777` √© uma faca de dois gumes, use com extrema cautela! Geralmente √© um sinal de m√° configura√ß√£o. üö®                                                                                                                                                                                                                                                         |
| 17  | A Filesystem Hierarchy Standard (FHS) define uma estrutura de diret√≥rios padr√£o para sistemas Linux, como `/bin` para bin√°rios essenciais e `/etc` para arquivos de configura√ß√£o.                                                | V        | Verdadeiro! ‚úÖ A FHS organiza a "cidade" do Linux. Saber onde as coisas ficam (bin√°rios, configs, logs) √© fundamental. **Dica Concurseiro:** Conhecer os principais diret√≥rios da FHS (`/bin`, `/sbin`, `/etc`, `/var`, `/home`, `/usr`, `/opt`, `/tmp`) √© obrigat√≥rio.                                                                                                                                                                                                                                     |
| 18  | O comando `ip addr show` √© utilizado exclusivamente para configurar um novo endere√ßo IP est√°tico em uma interface de rede.                                                                                                       | F        | Falso! ‚ùå `ip addr show` (ou `ip a`) √© primariamente para *mostrar* as configura√ß√µes de IP atuais. Para configurar, voc√™ usaria `ip addr add` ou, mais comumente hoje, `nmcli` (NetworkManager). **Dica:** "Show" geralmente significa exibir, n√£o modificar.                                                                                                                                                                                                                                               |
| 19  | O arquivo `/etc/passwd` cont√©m informa√ß√µes sobre os usu√°rios do sistema, como nome de usu√°rio e UID, mas n√£o armazena a senha criptografada.                                                                                     | V        | Verdadeiro! ‚úÖ Informa√ß√£o crucial! As senhas est√£o no `/etc/shadow` por seguran√ßa, pois `/etc/passwd` √© leg√≠vel por todos. **Dica:** Lembre-se: `passwd` (informa√ß√µes b√°sicas, leg√≠vel) + `shadow` (segredos ü§´, restrito).                                                                                                                                                                                                                                                                                 |
| 20  | O comando `grep -i 'erro' arquivo.log` procura pela palavra 'erro' no arquivo `arquivo.log`, ignorando a diferen√ßa entre mai√∫sculas e min√∫sculas.                                                                                | V        | Verdadeiro! ‚úÖ `grep` √© o detetive dos textos. A op√ß√£o `-i` significa "ignore case". **Dica:** `grep` √© seu melhor amigo para encontrar informa√ß√µes em logs. `man grep` revela seu poder! (Ex: `grep -rni 'palavra' /diretorio/`)                                                                                                                                                                                                                                                                           |
| 21  | O comando `find / -name "*.txt"` lista apenas os arquivos com extens√£o `.txt` localizados diretamente no diret√≥rio raiz (`/`).                                                                                                   | F        | Falso! ‚ùå `find /` inicia a busca a partir do diret√≥rio raiz e percorre *toda* a √°rvore de diret√≥rios recursivamente. Para listar apenas no diret√≥rio raiz, seria `find / -maxdepth 1 -name "*.txt"`. **Dica:** `find` √© poderoso, mas entender seu escopo (onde ele procura) e op√ß√µes (`-type f`, `-mtime`, `-user`) √© vital.                                                                                                                                                                              |
| 22  | O comando `ps aux` lista todos os processos em execu√ß√£o no sistema, mostrando informa√ß√µes detalhadas como usu√°rio, PID, %CPU, %MEM e o comando.                                                                                  | V        | Verdadeiro! ‚úÖ `ps aux` (sintaxe BSD) ou `ps -ef` (sintaxe System V) s√£o seus "raios-X" para ver o que est√° rodando. **Dica:** Essencial para troubleshooting e an√°lise forense (identificar processos suspeitos).                                                                                                                                                                                                                                                                                          |
| 23  | O comando `tar -cvf backup.tar /home/usuario` cria um arquivo compactado chamado `backup.tar`.                                                                                                                                   | F        | Falso! ‚ùå `tar -cvf` cria um *arquivo de arquivamento* (um "pacote" de arquivos), mas *n√£o* o compacta. Para compactar com gzip, seria `tar -czvf backup.tar.gz /home/usuario` (note o `z`). **Dica:** `tar` agrupa, `gzip`/`bzip2`/`xz` compactam. Muitas vezes usados juntos!                                                                                                                                                                                                                             |
| 24  | O comando `tail -f /var/log/messages` exibe as √∫ltimas linhas do arquivo `/var/log/messages` e continua monitorando o arquivo, mostrando novas linhas √† medida que s√£o adicionadas.                                              | V        | Verdadeiro! ‚úÖ `tail -f` (follow) √© perfeito para acompanhar logs em tempo real. üëÅÔ∏è **Dica:** Indispens√°vel para depura√ß√£o e monitoramento de eventos. `CTRL+C` para parar.                                                                                                                                                                                                                                                                                                                                |
| 25  | O utilit√°rio `sed` √© um editor de fluxo (stream editor) que pode realizar transforma√ß√µes b√°sicas de texto em um fluxo de entrada ou em arquivos, como substituir palavras.                                                       | V        | Verdadeiro! ‚úÖ Exemplo: `sed 's/antigo/novo/g' arquivo.txt` substitui todas as ocorr√™ncias de "antigo" por "novo". **Dica:** `sed` √© poderoso para edi√ß√µes program√°ticas. Aprenda o b√°sico de substitui√ß√£o (`s/.../.../g`).                                                                                                                                                                                                                                                                                 |
| 26  | O comando `df -h` mostra o tamanho detalhado de cada arquivo dentro de um diret√≥rio espec√≠fico.                                                                                                                                  | F        | Falso! ‚ùå `df -h` (disk free) mostra o espa√ßo usado e livre nos *sistemas de arquivos* (parti√ß√µes). Para ver o tamanho de arquivos/diret√≥rios, usa-se `du -sh <diretorio_ou_arquivo>` (disk usage). **Mnem√¥nico:** `df` = Disco Fra√ß√µes (geral), `du` = Disco Uso (espec√≠fico).                                                                                                                                                                                                                             |
| 27  | O comando `lsof -i :80` listaria os processos que est√£o utilizando a porta de rede 80.                                                                                                                                           | V        | Verdadeiro! ‚úÖ `lsof` (List Open Files) √© incrivelmente √∫til. `-i :80` filtra por processos que t√™m um "arquivo" de rede aberto na porta 80. **Dica:** √ìtimo para descobrir qual servi√ßo est√° escutando em uma porta. Outro similar: `ss -tulnp [pipe] grep :80`.                                                                                                                                                                                                                                           |
| 28  | `echo "Ol√° Mundo" > arquivo.txt` adiciona a string "Ol√° Mundo" ao final do `arquivo.txt` se ele j√° existir.                                                                                                                      | F        | Falso! ‚ùå O redirecionador `>` *sobrescreve* o arquivo. Para adicionar ao final (append), usa-se `>>`. Assim: `echo "Ol√° Mundo" >> arquivo.txt`. **Dica:** Cuidado! Usar `>` por engano pode apagar dados. ‚ö†Ô∏è                                                                                                                                                                                                                                                                                               |
| 29  | Em um script Bash, `#!/bin/bash` na primeira linha, conhecido como shebang, especifica o interpretador que deve ser usado para executar o script.                                                                                | V        | Verdadeiro! ‚úÖ O shebang √© a "assinatura m√°gica" que diz ao sistema: "Ei, execute isso com o Bash!". **Dica:** Essencial para qualquer script shell ser execut√°vel diretamente (`./meu_script.sh`).                                                                                                                                                                                                                                                                                                         |
| 30  | Dentro de um shell script, a vari√°vel `$#` cont√©m o nome do pr√≥prio script.                                                                                                                                                      | F        | Falso! ‚ùå `$#` cont√©m o *n√∫mero* de argumentos passados para o script. O nome do script est√° em `$0`. **Dica Concurseiro:** `$0` (nome), `$1`, `$2`... (argumentos), `$#` (qtde args), `$@` (todos os args como strings separadas), `$?` (status do √∫ltimo comando).                                                                                                                                                                                                                                        |
| 31  | A estrutura `if [ -f "/tmp/meuarquivo" ]; then echo "Arquivo existe"; fi` em Bash verifica se `/tmp/meuarquivo` existe e √© um arquivo regular.                                                                                   | V        | Verdadeiro! ‚úÖ O teste `-f` √© para verificar a exist√™ncia de um arquivo regular. Outros: `-d` (diret√≥rio), `-z` (string vazia). **Dica:** Use `man test` para ver todas as condi√ß√µes. Sempre use aspas em vari√°veis dentro dos colchetes: `[ -f "$VARIAVEL" ]`.                                                                                                                                                                                                                                             |
| 32  | O comando `VAR=$(ls /tmp)` e `VAR=\`ls /tmp\`` s√£o fundamentalmente diferentes em Bash; o primeiro executa o comando em um subshell e o segundo no shell atual.                                                                  | F        | Falso! ‚ùå Ambos s√£o formas de *substitui√ß√£o de comando* e executam o comando em um subshell, capturando sua sa√≠da padr√£o. A sintaxe `$()` √© a mais moderna e preferida (mais f√°cil de aninhar). **Dica:** Prefira `$()` a menos que esteja lidando com scripts muito antigos.                                                                                                                                                                                                                               |
| 33  | Em um loop `for i in $(seq 1 3); do echo $i; done`, o script imprimir√° os n√∫meros 1, 2 e 3, cada um em uma nova linha.                                                                                                           | V        | Verdadeiro! ‚úÖ `seq 1 3` gera a sequ√™ncia "1 2 3". O loop `for` itera sobre cada item. **Dica:** Loops `for` s√£o √≥timos para iterar sobre listas de itens ou sequ√™ncias. Outra forma: `for ((i=1; i<=3; i++))`.                                                                                                                                                                                                                                                                                             |
| 35  | O comando `grep "palavra" arquivo.txt [pipe] wc -l` conta o n√∫mero de linhas no `arquivo.txt` que cont√™m a "palavra".                                                                                                            | V        | Verdadeiro! ‚úÖ `grep` encontra as linhas, e sua sa√≠da (as linhas correspondentes) √© enviada via pipe (`[pipe]`) para o `wc -l`, que conta as linhas. **Dica:** Pipes s√£o a "supercola" do shell! üöÄ                                                                                                                                                                                                                                                                                                         |
| 36  | O mecanismo de Copy-on-Write (CoW) otimiza a cria√ß√£o de processos com `fork()` ao permitir que pai e filho compartilhem inicialmente as mesmas p√°ginas de mem√≥ria, copiando uma p√°gina apenas quando um deles tenta modific√°-la. | V        | Verdadeiro! ‚úÖ CoW √© uma otimiza√ß√£o crucial. Sem ele, `fork()` seria muito mais lento e consumiria mais mem√≥ria. **Dica:** Conceito importante para entender efici√™ncia na cria√ß√£o de processos em SOs modernos.                                                                                                                                                                                                                                                                                            |
| 37  | `LD_PRELOAD` √© uma vari√°vel de ambiente no Linux usada exclusivamente para fins benignos de depura√ß√£o e n√£o apresenta riscos de seguran√ßa significativos.                                                                        | F        | Falso! ‚ùå `LD_PRELOAD` √© *extremamente* poderoso e pode ser usado para fins maliciosos (rootkits, roubo de dados). **Dica Per√≠cia:** Verificar `LD_PRELOAD` em sistemas comprometidos √© importante. `/etc/ld.so.preload` tamb√©m.                                                                                                                                                                                                                                                                            |
| 38  | No Linux, um Inode √© uma estrutura de dados do sistema de arquivos que armazena metadados sobre um arquivo (permiss√µes, propriet√°rio, timestamps, ponteiros para blocos de dados), mas n√£o o nome do arquivo.                    | V        | Verdadeiro! ‚úÖ O nome do arquivo fica na estrutura do diret√≥rio, que aponta para o inode. O inode √© o "RG" do arquivo. **Dica Forense:** Entender inodes √© chave para recupera√ß√£o de arquivos deletados e an√°lise de metadados. Comando `stat arquivo` mostra infos do inode.                                                                                                                                                                                                                               |
| 39  | O systemd utiliza runlevels numerados (0-6) da mesma forma que o System V init para gerenciar os estados do sistema e os servi√ßos a serem iniciados.                                                                             | F        | Falso! ‚ùå Systemd usa "targets" (ex: `multi-user.target`, `graphical.target`) que s√£o mais flex√≠veis e baseados em depend√™ncias. Embora possa haver mapeamento para compatibilidade, o conceito √© diferente. **Dica:** "Targets" no systemd, "runlevels" no System V init. `systemctl get-default` mostra o target padr√£o.                                                                                                                                                                                  |
| 40  | SELinux (Security-Enhanced Linux), quando habilitado em modo "enforcing" em RHEL/Oracle Linux, implementa pol√≠ticas de Controle de Acesso Obrigat√≥rio (MAC) que restringem as a√ß√µes dos processos, mesmo para o root.            | V        | Verdadeiro! ‚úÖ SELinux adiciona uma camada de seguran√ßa poderosa. Mesmo root comprometido pode ser contido. **Dica:** "Enforcing" = aplicando; "Permissive" = logando, mas n√£o bloqueando. `getenforce` ou `sestatus` para verificar.                                                                                                                                                                                                                                                                       |
| 41  | Journald, o sistema de logging do systemd, armazena logs em formato bin√°rio estruturado, oferecendo vantagens como indexa√ß√£o e metadados.                                                                                        | V        | Verdadeiro! ‚úÖ O `journalctl` permite consultas mais ricas nesses logs. Ex: `journalctl -u sshd --since "yesterday"`. **Dica:** Embora `/var/log` ainda exista, `journalctl` √© a ferramenta prim√°ria para logs de sistema em distros com systemd.                                                                                                                                                                                                                                                           |
| 42  | Alternate Data Streams (ADS) s√£o uma caracter√≠stica comum e amplamente utilizada em sistemas de arquivos Linux nativos como ext4 e XFS para ocultar dados.                                                                       | F        | Falso! ‚ùå ADS s√£o uma caracter√≠stica do NTFS (Windows). Sistemas Linux nativos n√£o suportam ADS da mesma forma. Atacantes em Linux usariam outras t√©cnicas (arquivos ocultos `.` , rootkits). **Dica Cespe:** Cuidado com conceitos espec√≠ficos de um SO ao aplicar em outro.                                                                                                                                                                                                                               |
| 43  | Um ataque de "timestomping" em Linux visa modificar os timestamps de um arquivo (MAC times - Modification, Access, Change) para dificultar a an√°lise forense.                                                                    | V        | Verdadeiro! ‚úÖ O comando `touch -t AAMMDDhhmm.SS arquivo` pode ser usado para isso. √â uma t√©cnica anti-forense. **Dica Per√≠cia:** Peritos devem estar cientes de que timestamps podem ser adulterados e buscar outras evid√™ncias correlatas.                                                                                                                                                                                                                                                                |
| 44  | O Logical Volume Manager (LVM) no Linux √© usado primariamente para compactar sistemas de arquivos e reduzir o espa√ßo em disco utilizado.                                                                                         | F        | Falso! ‚ùå LVM √© para gerenciamento flex√≠vel de volumes de disco: redimensionar parti√ß√µes online, criar snapshots, agregar discos. N√£o tem a ver com compacta√ß√£o. **Dica:** LVM = Flexibilidade de armazenamento. Comandos: `pvcreate`, `vgcreate`, `lvcreate`.                                                                                                                                                                                                                                              |
| 45  | Em um ambiente Linux, a descoberta de um Loadable Kernel Module (LKM) suspeito pode indicar a presen√ßa de um rootkit de kernel, que modifica o comportamento do SO para ocultar atividades maliciosas.                           | V        | Verdadeiro! ‚úÖ LKMs s√£o uma forma poderosa de estender o kernel, mas tamb√©m um vetor para rootkits. `lsmod` lista os m√≥dulos carregados. **Dica Per√≠cia:** Analisar LKMs (`/lib/modules`) e verificar assinaturas (se houver) √© uma tarefa avan√ßada.                                                                                                                                                                                                                                                        |
| 46  | O diret√≥rio `/proc` em um sistema Linux √© um sistema de arquivos virtual que exp√µe informa√ß√µes em tempo real sobre o kernel e os processos, n√£o consumindo espa√ßo em disco f√≠sico.                                               | V        | Verdadeiro! ‚úÖ `/proc` √© uma janela para o interior do kernel. Ler arquivos em `/proc` (ex: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/<PID>/status`) fornece dados din√¢micos. **Dica:** N√£o tente fazer backup do `/proc` como se fossem arquivos normais!                                                                                                                                                                                                                                                   |
| 47  | O comando `chattr +i arquivo` torna o arquivo `arquivo` execut√°vel por todos os usu√°rios.                                                                                                                                        | F        | Falso! ‚ùå `chattr +i` torna o arquivo *imut√°vel* (immutable). Ningu√©m (nem root) pode modific√°-lo ou exclu√≠-lo at√© `chattr -i`. Para tornar execut√°vel, usa-se `chmod +x`. **Dica:** `chattr` e `lsattr` gerenciam atributos estendidos do sistema de arquivos ext2/3/4.                                                                                                                                                                                                                                    |
| 48  | O utilit√°rio `strace` no Linux permite rastrear as chamadas de sistema (system calls) feitas e os sinais recebidos por um processo, sendo uma ferramenta poderosa para depura√ß√£o e an√°lise.                                      | V        | Verdadeiro! ‚úÖ `strace ./meuprograma` mostra todas as intera√ß√µes do `meuprograma` com o kernel. **Dica:** √ötil para entender por que um programa falha, trava ou onde ele est√° acessando arquivos/rede.                                                                                                                                                                                                                                                                                                     |
| 49  | O arquivo `/etc/hosts` no Linux √© respons√°vel por configurar os servidores DNS que o sistema utilizar√° para resolu√ß√£o de nomes.                                                                                                  | F        | Falso! ‚ùå `/etc/hosts` √© para mapeamentos *locais* de IP para hostname. A configura√ß√£o dos servidores DNS fica em `/etc/resolv.conf` (ou √© gerenciada pelo NetworkManager/systemd-resolved). **Dica:** `/etc/hosts` √© verificado *antes* da consulta DNS. Pode ser usado para bloquear sites ou para testes locais.                                                                                                                                                                                         |
| 50  | Em RHEL/Oracle Linux, `firewalld` √© um frontend din√¢mico para gerenciamento de firewall que utiliza o conceito de "zonas" para aplicar diferentes regras.                                                                        | V        | Verdadeiro! ‚úÖ `firewalld` (com `firewall-cmd`) √© o padr√£o em distros RHEL/Oracle mais recentes. Zonas (`public`, `internal`, `dmz`) simplificam a aplica√ß√£o de pol√≠ticas. **Dica:** `firewall-cmd --list-all` mostra a config da zona padr√£o.                                                                                                                                                                                                                                                              |
| 51  | Todas as distribui√ß√µes Linux utilizam exatamente o mesmo gerenciador de pacotes, chamado `apt-get`.                                                                                                                              | F        | Falso! ‚ùå `apt-get` √© caracter√≠stico de distribui√ß√µes baseadas em Debian (como Ubuntu). RHEL/Oracle Linux utilizam `yum` ou `dnf`, que gerenciam pacotes `.rpm`. **Dica Cespe:** Conhecer as fam√≠lias de distros (Debian-like vs. Red Hat-like) e seus gerenciadores de pacotes (`apt` vs. `yum/dnf`) √© fundamental!                                                                                                                                                                                        |
| 52  | Para obter atualiza√ß√µes e suporte t√©cnico oficial para RHEL, √© geralmente necess√°rio adquirir uma subscri√ß√£o paga.                                                                                                               | V        | Verdadeiro! ‚úÖ O modelo de neg√≥cios da Red Hat √© baseado em subscri√ß√µes. O software em si (c√≥digo fonte) √© aberto, mas os servi√ßos agregados (suporte, atualiza√ß√µes testadas e certificadas, acesso ao portal do cliente) s√£o pagos. √â o "p√£o com manteiga" da Red Hat. üçûüßà                                                                                                                                                                                                                                |
| 53  | Oracle Linux n√£o permite o uso gratuito de suas atualiza√ß√µes e erratas, exigindo sempre um contrato de suporte pago.                                                                                                             | F        | Falso! ‚ùå Um grande diferencial do Oracle Linux √© justamente que as atualiza√ß√µes e erratas (corre√ß√µes de bugs e seguran√ßa) s√£o **gratuitas** e publicamente acess√≠veis! O suporte t√©cnico pago da Oracle √© uma op√ß√£o, n√£o uma exig√™ncia para manter o sistema atualizado. Isso o torna uma alternativa atraente ao RHEL para quem busca compatibilidade sem o custo da subscri√ß√£o RHEL.                                                                                                                     |
| 54  | O comando `strings arquivo_binario` √© usado para modificar strings dentro de um arquivo bin√°rio diretamente.                                                                                                                     | F        | Falso! ‚ùå O comando `strings` serve apenas para *extrair* e *exibir* as sequ√™ncias de caracteres imprim√≠veis (strings de texto) de um arquivo, geralmente bin√°rio. Ele n√£o modifica o arquivo original. Para modificar, seriam necess√°rias ferramentas como editores hexadecimais (ex: `hexedit`, `bless`) ou descompiladores/debuggers, dependendo da complexidade. Pense no `strings` como um "leitor de legendas" de arquivos bin√°rios. üïµÔ∏è‚Äç‚ôÇÔ∏è                                                           |
| 55  | A express√£o `COUNT=$((COUNT + 1))` √© uma forma v√°lida e eficiente de incrementar uma vari√°vel num√©rica `COUNT` em Bash.                                                                                                          | V        | Verdadeiro! ‚úÖ A constru√ß√£o `$((...))` √© o padr√£o moderno para expans√£o aritm√©tica em Bash. √â mais limpa e geralmente preferida sobre alternativas mais antigas como `let "COUNT = COUNT + 1"` ou `COUNT=$(expr $COUNT + 1)`. **Dica:** Use `$((...))` sempre que precisar fazer contas no Bash!                                                                                                                                                                                                            |
| 56  | Em Bash, uma fun√ß√£o deve obrigatoriamente ser declarada com a palavra-chave `function` antes do nome da fun√ß√£o.                                                                                                                  | F        | Falso! ‚ùå A palavra-chave `function` √© opcional na declara√ß√£o de fun√ß√µes em Bash. Ambas as formas s√£o v√°lidas: `function minha_funcao { ... }` e `minha_funcao() { ... }`. A segunda forma (sem `function` mas com par√™nteses) √© mais comum e port√°vel para shells POSIX mais antigos. **Dica:** A forma com par√™nteses √© mais "estilo C". üòâ                                                                                                                                                               |
| 57  | O comando `read -p "Digite seu nome: " NOME_USUARIO` em um script Bash exibe a mensagem "Digite seu nome: " e armazena a entrada do usu√°rio na vari√°vel `NOME_USUARIO`.                                                          | V        | Verdadeiro! ‚úÖ O comando `read` √© o meio padr√£o para obter entrada do usu√°rio em scripts Bash. A op√ß√£o `-p "prompt"` exibe a mensagem antes de esperar pela entrada, e o que for digitado √© armazenado na vari√°vel especificada (aqui, `NOME_USUARIO`). **Dica:** Use `read -s` para entrada "silenciosa" (n√£o ecoa na tela), √∫til para senhas.                                                                                                                                                             |
| 58  | Apenas distribui√ß√µes Linux baseadas em Debian, como o Ubuntu, utilizam o sistema de inicializa√ß√£o `systemd`.                                                                                                                     | F        | Falso! ‚ùå `systemd` tornou-se o sistema de init padr√£o na grande maioria das distribui√ß√µes Linux modernas, incluindo RHEL 7+, Oracle Linux 7+, Fedora, SUSE Linux Enterprise Server, Arch Linux, e muitas outras. Embora tenha sido controverso, sua ado√ß√£o √© ampla. **Dica Cespe:** `systemd` √© um t√≥pico quente. Saber que ele n√£o √© exclusivo do Debian √© importante.                                                                                                                                    |
| 59  | O comando `nmcli dev status` em sistemas RHEL/Oracle Linux que utilizam NetworkManager exibe o status das interfaces de rede gerenciadas.                                                                                        | V        | Verdadeiro! ‚úÖ `nmcli` (NetworkManager Command Line Interface) √© a ferramenta de linha de comando para interagir com o NetworkManager, que √© o servi√ßo padr√£o para gerenciamento de rede em muitas distros desktop e servidor. `nmcli device status` (ou `nmcli d s`) mostra uma lista das interfaces de rede e seu estado (conectado, desconectado, etc.).                                                                                                                                                 |
| 60  | A t√©cnica de "pipelining" no shell Linux, usando o caractere `[pipe]`, permite que a stdout de um comando seja conectada √† stdin de outro.                                                                                       | V        | Verdadeiro! ‚úÖ Essa √© a ess√™ncia do poder e flexibilidade do shell Unix/Linux! O pipe (`[pipe]`) √© como um encanamento que leva a sa√≠da padr√£o (stdout) de um comando diretamente para a entrada padr√£o (stdin) do pr√≥ximo comando na sequ√™ncia. Ex: `ls -l [pipe] grep ".txt" [pipe] wc -l` (lista arquivos, filtra por .txt, conta as linhas resultantes). üö∞                                                                                                                                             |
| 61  | O comando `kill -9 <PID>` envia um sinal `SIGTERM` para o processo `<PID>`, solicitando que ele termine de forma graciosa.                                                                                                       | F        | Falso! ‚ùå `kill -9 <PID>` envia o sinal `SIGKILL`. `SIGKILL` (sinal 9) √© um sinal "fatal" que n√£o pode ser capturado ou ignorado pelo processo; ele termina o processo imediatamente e de forma abrupta. O sinal `SIGTERM` (sinal 15, que √© o padr√£o se nenhum sinal for especificado com `kill`) √© o que solicita uma termina√ß√£o graciosa. **Dica:** `kill -9` √© o "martelo" üî®, use como √∫ltimo recurso. `kill <PID>` (ou `kill -15 <PID>`) √© o pedido educado.                                           |
| 62  | Um "daemon" no Linux √© um programa que executa em segundo plano, sem intera√ß√£o direta do usu√°rio, realizando tarefas espec√≠ficas.                                                                                                | V        | Verdadeiro! ‚úÖ Daemons s√£o os "servi√ßais" do sistema operacional. Exemplos incluem servidores web (`httpd`, `nginx`), servidores SSH (`sshd`), servi√ßos de agendamento (`crond`). Eles geralmente s√£o iniciados no boot e ficam rodando silenciosamente. üëª                                                                                                                                                                                                                                                 |
| 63  | O comando `history` no Bash exibe uma lista dos comandos executados anteriormente pelo usu√°rio no shell atual.                                                                                                                   | V        | Verdadeiro! ‚úÖ O Bash mant√©m um hist√≥rico dos comandos digitados. O comando `history` exibe essa lista. √â muito √∫til para repetir comandos (`!<n√∫mero>`) ou buscar comandos (`CTRL+R`). O hist√≥rico √© geralmente salvo no arquivo `~/.bash_history` quando o shell √© fechado.                                                                                                                                                                                                                               |
| 64  | Em shell script, `if [ "$A" = "$B" ]` √© usado para comparar se os n√∫meros armazenados nas vari√°veis A e B s√£o aritmeticamente iguais.                                                                                            | F        | Falso! ‚ùå Dentro de colchetes simples `[ ... ]` (que √© um sin√¥nimo para o comando `test`), `=` √© para compara√ß√£o de *strings*. Para compara√ß√µes num√©ricas, deve-se usar operadores como `-eq` (igual), `-ne` (n√£o igual), `-gt` (maior que), `-lt` (menor que), etc. Ex: `if [ "$A" -eq "$B" ]`. **Dica:** Erro comum! Se usar `=` com n√∫meros, pode haver comportamento inesperado dependendo dos valores. Para robustez, `[[ "$A" == "$B" ]]` √© melhor para strings e `$((A == B))` para n√∫meros em `if`. |
| 65  | A substitui√ß√£o de comando em Bash, como em `DATA_ATUAL=$(date)`, captura a stdout do comando `date` e a atribui √† vari√°vel `DATA_ATUAL`.                                                                                         | V        | Verdadeiro! ‚úÖ A sintaxe `$()` (ou a mais antiga ` `` ` - crases) executa o comando interno em um subshell e sua sa√≠da padr√£o (stdout) substitui a constru√ß√£o `$()`. Isso permite que a sa√≠da de um comando seja usada como parte de outro comando ou atribu√≠da a uma vari√°vel. üóìÔ∏è‚û°Ô∏èüì¶                                                                                                                                                                                                                     |
| 66  | O conceito de "namespace" no kernel Linux √© fundamental para cont√™ineres (Docker), permitindo isolamento de recursos (PIDs, rede, montagens).                                                                                    | V        | Verdadeiro! ‚úÖ Namespaces s√£o um dos pilares da tecnologia de cont√™ineres no Linux. Eles permitem que um grupo de processos veja um conjunto isolado de recursos do sistema (ex: sua pr√≥pria √°rvore de PIDs, suas pr√≥prias interfaces de rede, seu pr√≥prio hostname). Isso d√° a ilus√£o de que o cont√™iner √© uma m√°quina separada. üê≥                                                                                                                                                                        |
| 67  | O comando `cat` √© a ferramenta mais apropriada e segura para exibir o conte√∫do de arquivos bin√°rios na tela.                                                                                                                     | F        | Falso! ‚ùå Usar `cat` para exibir arquivos bin√°rios diretamente no terminal pode resultar em uma tela cheia de caracteres "lixo", bipes, e at√© mesmo alterar as configura√ß√µes do terminal. Para visualizar conte√∫do bin√°rio de forma segura, use ferramentas como `hexdump`, `xxd`, `od`, ou `strings` (para extrair apenas texto). `cat` √© para arquivos de *texto*. üìÑüëç Bin√°rio üëé                                                                                                                        |
| 68  | O diret√≥rio `/var/log` no Linux √© o local padr√£o para a maioria dos arquivos de log do sistema e de aplica√ß√µes.                                                                                                                  | V        | Verdadeiro! ‚úÖ `/var/log` √© o reposit√≥rio central para logs. L√° voc√™ encontrar√° logs do sistema (`messages`, `syslog`), logs de seguran√ßa (`secure`, `auth.log`), logs de gerenciadores de pacotes (`yum.log`, `dpkg.log`), logs de aplica√ß√µes como servidores web, etc. √â o primeiro lugar a se olhar quando algo vai mal. üîç                                                                                                                                                                              |
| 69  | O comando `umask 000` configuraria as permiss√µes padr√£o para novos arquivos de forma que apenas o propriet√°rio teria permiss√µes de leitura e escrita.                                                                            | F        | Falso! ‚ùå `umask` funciona "ao contr√°rio": os bits definidos na umask s√£o *removidos* das permiss√µes base (666 para arquivos, 777 para diret√≥rios). Uma `umask 000` significa que *nenhum* bit de permiss√£o √© removido, resultando em permiss√µes `rw-rw-rw-` (666) para arquivos e `rwxrwxrwx` (777) para diret√≥rios (muito permissivo!). Para `rw-------` (600), a `umask` seria `077`.                                                                                                                    |
| 70  | "Hard links" e "soft links" (symlinks) s√£o dois tipos de links. Hard link √© outra entrada para o mesmo inode; soft link √© um arquivo com o caminho para outro.                                                                   | V        | Verdadeiro! ‚úÖ **Hard Link:** Pense em m√∫ltiplos nomes para o mesmo "RG" (inode). O arquivo s√≥ √© realmente removido quando o √∫ltimo hard link √© deletado. N√£o podem cruzar sistemas de arquivos. **Soft Link (Symbolic Link):** √â um atalho, um arquivo especial que aponta para o *nome* de outro arquivo. Se o original for deletado, o link quebra. Podem cruzar sistemas de arquivos. üîó                                                                                                                |
| 71  | Em teoria de SOs, "escalonamento de processos" refere-se ao algoritmo do kernel para decidir qual processo usa a CPU e por quanto tempo.                                                                                         | V        | Verdadeiro! ‚úÖ O escalonador (scheduler) √© uma parte cr√≠tica do kernel. Ele implementa pol√≠ticas para compartilhar a CPU entre m√∫ltiplos processos, visando objetivos como justi√ßa, tempo de resposta, throughput. O Linux usa o CFS (Completely Fair Scheduler). üïí                                                                                                                                                                                                                                        |
| 72  | O comando `dd if=/dev/zero of=/dev/sda bs=1M count=100` copia os primeiros 100MB do disco `/dev/sda` para um arquivo de imagem.                                                                                                  | F        | Falso! ‚ùå **PERIGO!** ‚ö†Ô∏è Este comando *sobrescreve* os primeiros 100MB do disco `/dev/sda` com zeros, apagando dados! `if` √© "input file", `of` √© "output file". Para copiar *do* disco para uma imagem, seria: `dd if=/dev/sda of=imagem_sda.img bs=1M count=100`. **Dica Cespe:** `dd` √© poderoso (apelidado de "disk destroyer" se usado errado). Aten√ß√£o m√°xima ao `if` e `of`.                                                                                                                         |
| 73  | O comando `awk '{print $1, $3}' arquivo.txt` processa `arquivo.txt` e imprime a primeira e a terceira coluna de cada linha.                                                                                                      | V        | Verdadeiro! ‚úÖ `awk` √© uma linguagem de processamento de texto poderosa. Por padr√£o, ele divide cada linha em campos (colunas) usando espa√ßos/tabs como delimitadores. `$0` representa a linha inteira, `$1` o primeiro campo, `$2` o segundo, e assim por diante. Este comando exibe o primeiro e o terceiro campo de cada linha. üìä                                                                                                                                                                       |
| 74  | O Red Hat Package Manager (RPM) √© capaz de resolver depend√™ncias automaticamente ao instalar um pacote.                                                                                                                          | F        | Falso! ‚ùå `rpm` √© uma ferramenta de gerenciamento de pacotes de *baixo n√≠vel*. Ele pode instalar, remover, atualizar e consultar pacotes `.rpm`, mas *n√£o* resolve depend√™ncias. Se um pacote requer outro que n√£o est√° instalado, `rpm` falhar√°. Ferramentas de alto n√≠vel como `yum` e `dnf` usam `rpm` por baixo dos panos e *s√£o* capazes de resolver depend√™ncias automaticamente a partir de reposit√≥rios.                                                                                            |
| 75  | A t√©cnica de "port knocking" √© um m√©todo para controlar o acesso a portas em um firewall, onde uma sequ√™ncia de "batidas" em portas fechadas abre uma porta real.                                                                | V        | Verdadeiro! ‚úÖ Port knocking √© uma t√©cnica de seguran√ßa por obscuridade. Um daemon no servidor monitora tentativas de conex√£o em portas espec√≠ficas (que est√£o fechadas no firewall). Se uma sequ√™ncia correta de "batidas" (tentativas de conex√£o) for detectada, o daemon instrui o firewall a abrir temporariamente uma porta real (ex: SSH). üö™‚úä                                                                                                                                                        |
| 76  | Em sistemas Linux, o diret√≥rio `/tmp` √© geralmente configurado para ser limpo durante a inicializa√ß√£o ou periodicamente.                                                                                                         | V        | Verdadeiro! ‚úÖ O diret√≥rio `/tmp` √© destinado a arquivos tempor√°rios. A maioria das distribui√ß√µes configura sistemas para limpar o `/tmp` no boot ou atrav√©s de jobs agendados (ex: `tmpwatch`, `systemd-tmpfiles`). Portanto, n√£o se deve armazenar dados persistentes ou importantes em `/tmp`. üóëÔ∏è                                                                                                                                                                                                       |
| 77  | O comando `sudo -l` executa o √∫ltimo comando do hist√≥rico como root.                                                                                                                                                             | F        | Falso! ‚ùå O comando `sudo -l` (list) exibe os comandos que o usu√°rio atual tem permiss√£o para executar via `sudo`, conforme definido no arquivo `/etc/sudoers`. Para executar o √∫ltimo comando do hist√≥rico como root, a sintaxe comum √© `sudo !!`.                                                                                                                                                                                                                                                         |
| 78  | Cgroups (control groups) no Linux s√£o um mecanismo do kernel para alocar, limitar e priorizar recursos (CPU, mem√≥ria, I/O) para cole√ß√µes de processos.                                                                           | V        | Verdadeiro! ‚úÖ Cgroups, juntamente com namespaces, s√£o fundamentais para a tecnologia de cont√™ineres (como Docker). Eles permitem que administradores de sistema controlem e isolem o uso de recursos por grupos de processos, evitando que um processo "faminto" prejudique outros. ‚öñÔ∏è                                                                                                                                                                                                                     |
| 79  | O bit `setuid` (SUID) em um arquivo execut√°vel faz com que ele seja sempre executado com os privil√©gios do propriet√°rio do diret√≥rio onde est√°.                                                                                  | F        | Falso! ‚ùå O bit SUID, quando definido em um arquivo execut√°vel, faz com que o processo seja executado com os privil√©gios do *propriet√°rio do arquivo execut√°vel*, n√£o do diret√≥rio. Se o arquivo √© propriedade do root e tem SUID, qualquer usu√°rio que o execute o far√° com privil√©gios de root (ex: o comando `passwd`). Isso √© poderoso, mas tamb√©m um risco de seguran√ßa se n√£o gerenciado corretamente. üîë                                                                                             |
| 80  | DTrace √© uma ferramenta de rastreamento din√¢mico abrangente dispon√≠vel no Oracle Linux (UEK) para vis√£o profunda do kernel e aplica√ß√µes.                                                                                         | V        | Verdadeiro! ‚úÖ DTrace, origin√°rio do Solaris, foi portado pela Oracle para o Linux e est√° dispon√≠vel no Unbreakable Enterprise Kernel (UEK). √â uma ferramenta extremamente poderosa para depura√ß√£o e an√°lise de desempenho em tempo real, permitindo instrumentar dinamicamente tanto o kernel quanto aplica√ß√µes em espa√ßo de usu√°rio. üî¨                                                                                                                                                                   |
| 81  | A diretiva `AllowUsers` no `/etc/ssh/sshd_config` pode restringir o acesso SSH a usu√°rios espec√≠ficos.                                                                                                                           | V        | Verdadeiro! ‚úÖ Configurar `AllowUsers usuario1 usuario2` no arquivo de configura√ß√£o do servidor SSH (`sshd_config`) √© uma boa pr√°tica de seguran√ßa para limitar quem pode acessar o sistema via SSH. Apenas os usu√°rios listados poder√£o logar. Similarmente, `AllowGroups` pode ser usado. üõ°Ô∏è                                                                                                                                                                                                             |
| 82  | O comando `fsck` pode ser executado com seguran√ßa em um sistema de arquivos montado e em uso ativo para corrigir erros.                                                                                                          | F        | Falso! ‚ùå **MUITO PERIGOSO!** Executar `fsck` (file system check) em um sistema de arquivos montado e em uso (especialmente se estiver em modo de escrita) pode levar √† corrup√ß√£o severa de dados. `fsck` deve ser executado em sistemas de arquivos desmontados ou montados em modo somente leitura (read-only). üõë                                                                                                                                                                                        |
| 83  | "Idempot√™ncia" em ferramentas como Ansible/Puppet significa que aplicar a mesma configura√ß√£o m√∫ltiplas vezes tem o mesmo resultado que aplic√°-la uma vez.                                                                        | V        | Verdadeiro! ‚úÖ Idempot√™ncia √© um conceito chave em gerenciamento de configura√ß√£o. Significa que a ferramenta verifica o estado atual do sistema e s√≥ faz altera√ß√µes se o estado desejado for diferente do atual. Reaplicar a configura√ß√£o n√£o causa mudan√ßas adicionais se o sistema j√° estiver no estado correto. Isso torna a automa√ß√£o mais segura e previs√≠vel. üîÅ=üëç                                                                                                                                   |
| 84  | No Linux, todos os dispositivos de hardware s√£o representados como arquivos regulares dentro do diret√≥rio `/opt`.                                                                                                                | F        | Falso! ‚ùå Dispositivos de hardware no Linux s√£o representados por arquivos *especiais* (de bloco ou de caractere) localizados no diret√≥rio `/dev` (ex: `/dev/sda` para o primeiro disco r√≠gido, `/dev/tty1` para um terminal). O diret√≥rio `/opt` √© tradicionalmente usado para instalar software "opcional" ou de terceiros que n√£o faz parte da distribui√ß√£o base.                                                                                                                                        |
| 85  | O "three-way handshake" (SYN, SYN-ACK, ACK) √© o processo pelo qual uma conex√£o TCP √© estabelecida.                                                                                                                               | V        | Verdadeiro! ‚úÖ Este √© o "aperto de m√£o" fundamental do protocolo TCP: 1. Cliente envia SYN (synchronize). 2. Servidor responde com SYN-ACK (synchronize-acknowledge). 3. Cliente envia ACK (acknowledge). Somente ap√≥s esses tr√™s passos a conex√£o √© considerada estabelecida e os dados podem come√ßar a ser trocados. ü§ù                                                                                                                                                                                   |
| 86  | Em RHEL/Oracle Linux, os arquivos de configura√ß√£o para reposit√≥rios `yum` ou `dnf` est√£o em `/etc/yum.repos.d/` (extens√£o `.repo`).                                                                                              | V        | Verdadeiro! ‚úÖ O diret√≥rio `/etc/yum.repos.d/` cont√©m arquivos com a extens√£o `.repo`. Cada um desses arquivos define um ou mais reposit√≥rios de software que o `yum` ou `dnf` utilizar√£o para buscar pacotes, informa√ß√µes de pacotes e depend√™ncias. üìú                                                                                                                                                                                                                                                    |
| 87  | Um "buffer overflow" geralmente resulta apenas no t√©rmino abrupto do programa, sem outras consequ√™ncias de seguran√ßa.                                                                                                            | F        | Falso! ‚ùå Embora um buffer overflow possa causar o crash do programa (t√©rmino abrupto), suas consequ√™ncias de seguran√ßa podem ser muito mais graves. Atacantes podem explorar overflows para sobrescrever √°reas da mem√≥ria e injetar c√≥digo malicioso, potencialmente ganhando controle sobre o programa ou o sistema. √â uma das vulnerabilidades mais antigas e perigosas. üí£                                                                                                                              |
| 88  | O comando `getenforce` em um sistema com SELinux exibe o modo atual: Enforcing, Permissive ou Disabled.                                                                                                                          | V        | Verdadeiro! ‚úÖ `getenforce` √© um comando simples que retorna o modo operacional atual do SELinux. **Enforcing:** Pol√≠ticas s√£o aplicadas e viola√ß√µes s√£o bloqueadas. **Permissive:** Viola√ß√µes s√£o apenas logadas, n√£o bloqueadas (√∫til para depura√ß√£o de pol√≠ticas). **Disabled:** SELinux est√° completamente desativado. `sestatus` fornece informa√ß√µes mais detalhadas.                                                                                                                                  |
| 89  | O protocolo UDP garante a entrega ordenada e confi√°vel de pacotes, reenviando pacotes perdidos.                                                                                                                                  | F        | Falso! ‚ùå Isso descreve o TCP (Transmission Control Protocol). O UDP (User Datagram Protocol) √© um protocolo "sem conex√£o", "n√£o confi√°vel" e "n√£o ordenado". Ele n√£o garante entrega, ordem ou duplicidade. Sua vantagem √© a baixa lat√™ncia e overhead, sendo usado para DNS, streaming de v√≠deo, jogos online. üì®üí®                                                                                                                                                                                       |
| 90  | A `glibc` (GNU C Library) √© uma implementa√ß√£o da biblioteca C padr√£o, fundamental na maioria dos sistemas GNU/Linux.                                                                                                             | V        | Verdadeiro! ‚úÖ `glibc` √© a biblioteca C padr√£o usada pela vasta maioria dos programas em sistemas GNU/Linux. Ela fornece as chamadas de sistema e outras fun√ß√µes b√°sicas que os programas C (e muitos outros programas que dependem de C) utilizam para interagir com o kernel e realizar opera√ß√µes. Vulnerabilidades na `glibc` podem ter um impacto muito amplo. üìö                                                                                                                                       |
| 91  | "Infrastructure as Code" (IaC) √© gerenciar infraestrutura (redes, VMs) atrav√©s de arquivos de defini√ß√£o leg√≠veis por m√°quina (c√≥digo).                                                                                           | V        | Verdadeiro! ‚úÖ IaC aplica pr√°ticas de desenvolvimento de software (versionamento, testes, automa√ß√£o) ao gerenciamento de infraestrutura. Ferramentas como Terraform, Ansible, CloudFormation permitem que a infraestrutura seja definida em c√≥digo, tornando-a reprodut√≠vel, escal√°vel e menos propensa a erros manuais. üèóÔ∏èüíª                                                                                                                                                                              |
| 92  | No modelo OSI, a camada de Enlace (Data Link Layer) √© respons√°vel pelo roteamento de pacotes entre diferentes redes.                                                                                                             | F        | Falso! ‚ùå A camada de Enlace (Camada 2 do OSI) √© respons√°vel pela transmiss√£o confi√°vel de *frames* entre dois n√≥s diretamente conectados na *mesma rede local* (ex: Ethernet, Wi-Fi, MAC addresses). O roteamento de *pacotes* entre *diferentes redes* √© fun√ß√£o da camada de Rede (Camada 3 do OSI), onde opera o protocolo IP. üåê                                                                                                                                                                        |
| 93  | O arquivo `~/.bashrc` √© um script que o Bash executa em cada nova sess√£o interativa n√£o-login, usado para aliases e customiza√ß√µes.                                                                                               | V        | Verdadeiro! ‚úÖ `~/.bashrc` (onde `~` √© o diret√≥rio home do usu√°rio) √© lido e executado pelo Bash quando um shell interativo *n√£o-login* √© iniciado (ex: abrir um novo terminal numa sess√£o gr√°fica). √â o local comum para definir aliases, fun√ß√µes de shell, customizar o prompt (`PS1`) e outras configura√ß√µes pessoais do ambiente de shell. J√° o `~/.bash_profile` (ou `~/.profile`) √© para shells de *login*.                                                                                           |
| 94  | Ksplice, da Oracle, permite aplicar atualiza√ß√µes a aplica√ß√µes de espa√ßo de usu√°rio (navegadores) sem reinici√°-las.                                                                                                               | F        | Falso! ‚ùå Ksplice √© uma tecnologia (originalmente desenvolvida independentemente, depois adquirida pela Oracle) que permite aplicar patches de seguran√ßa e corre√ß√µes de bugs ao *kernel Linux em execu√ß√£o* sem a necessidade de reiniciar o sistema. Seu foco √© o kernel, n√£o aplica√ß√µes de espa√ßo de usu√°rio. Isso √© crucial para sistemas que exigem alta disponibilidade. üë®‚Äç‚öïÔ∏è‚ù§Ô∏è                                                                                                                        |
| 95  | Em per√≠cia forense digital, "cadeia de cust√≥dia" √© o registro cronol√≥gico documentado da posse da evid√™ncia digital, garantindo sua integridade.                                                                                 | V        | Verdadeiro! ‚úÖ A cadeia de cust√≥dia √© um dos princ√≠pios mais fundamentais da per√≠cia forense. Ela documenta quem manuseou a evid√™ncia, quando, onde e por qu√™, desde a coleta at√© a apresenta√ß√£o em tribunal. Qualquer quebra ou falha na cadeia de cust√≥dia pode comprometer a admissibilidade da evid√™ncia. Para um Perito da PF, isso √© absolutamente cr√≠tico! üîóüìÑ                                                                                                                                      |
| 96  | O comando `pwd` (print working directory) exibe o caminho absoluto do diret√≥rio atual no shell Linux.                                                                                                                            | V        | Verdadeiro! ‚úÖ `pwd` √© um comando simples, mas essencial. Ele mostra o caminho completo, desde a raiz (`/`), do diret√≥rio em que o usu√°rio se encontra no momento no terminal. Ajuda a se orientar no sistema de arquivos. üó∫Ô∏è                                                                                                                                                                                                                                                                              |
| 97  | Em Linux, o diret√≥rio `/root` √© acess√≠vel para leitura por todos os usu√°rios do sistema, pois cont√©m informa√ß√µes b√°sicas sobre o superusu√°rio.                                                                                   | F        | Falso! ‚ùå O diret√≥rio `/root` √© o diret√≥rio *home* do usu√°rio `root` (o superusu√°rio). Por padr√£o, suas permiss√µes s√£o restritas (geralmente `drwx------` ou `rwxr-x---`) para proteger os arquivos e configura√ß√µes do root. Apenas o root (e processos com privil√©gios de root) podem acess√°-lo completamente. √â um local sens√≠vel. üîí                                                                                                                                                                     |
| 98  | O comando `nohup meu_comando &` permite que `meu_comando` continue executando em segundo plano mesmo ap√≥s o usu√°rio deslogar da sess√£o do terminal.                                                                              | V        | Verdadeiro! ‚úÖ `nohup` (NO HangUP) impede que o comando seja terminado pelo sinal `SIGHUP` quando o terminal de controle √© fechado (ex: ao deslogar). O `&` no final coloca o comando para rodar em segundo plano (background). A sa√≠da padr√£o e erro padr√£o do comando s√£o geralmente redirecionadas para um arquivo chamado `nohup.out` no diret√≥rio atual, a menos que especificado de outra forma. üèÉ‚Äç‚ôÇÔ∏èüí®                                                                                              |
| 99  | O sistema de arquivos XFS, comumente usado em RHEL/Oracle Linux, n√£o suporta journaling, tornando-o mais r√°pido, mas menos resiliente a falhas de energia.                                                                       | F        | Falso! ‚ùå XFS √© um sistema de arquivos de alta performance que *suporta journaling*. O journaling √© uma t√©cnica crucial que registra as altera√ß√µes que ser√£o feitas no sistema de arquivos em uma √°rea especial (o journal) antes de serem efetivamente escritas. Isso ajuda a garantir a consist√™ncia do sistema de arquivos e acelera a recupera√ß√£o ap√≥s uma falha de energia ou crash do sistema, evitando longas checagens (`fsck`).                                                                    |
| 100 | A ferramenta `rsync` √© frequentemente utilizada para sincronizar arquivos e diret√≥rios entre locais (locais ou remotos) de forma eficiente, transferindo apenas as diferen√ßas.                                                   | V        | Verdadeiro! ‚úÖ `rsync` √© uma ferramenta muito vers√°til e eficiente para copiar e sincronizar arquivos. Seu algoritmo delta-transfer permite que ele identifique e transfira apenas as partes dos arquivos que foram modificadas, economizando banda e tempo, especialmente em transfer√™ncias remotas (ex: via SSH). √â amplamente usado para backups, espelhamento de diret√≥rios e distribui√ß√£o de arquivos. üîÑ                                                                                              |
| 101 | O comando `journalctl -u sshd --since "1 hour ago"` exibe todas as entradas de log do servi√ßo `sshd` geradas na √∫ltima hora em sistemas que utilizam `systemd`.                                                                  | V        | Verdadeiro! ‚úÖ `journalctl` √© a ferramenta para consultar o journal do systemd. `-u sshd` filtra pelo servi√ßo `sshd`. `--since "1 hour ago"` filtra pelo tempo. **Dica:** `journalctl` √© seu canivete su√≠√ßo para logs em sistemas `systemd`! üá®üá≠                                                                                                                                                                                                                                                           |
| 102 | O arquivo `/var/log/messages` em RHEL/Oracle Linux mais antigos (pr√©-systemd ou com rsyslog configurado) cont√©m apenas mensagens de erro cr√≠ticas do kernel.                                                                     | F        | Falso! ‚ùå `/var/log/messages` (ou `/var/log/syslog` em algumas distros) √© um log geral do sistema que cont√©m uma variedade de mensagens, incluindo informa√ß√µes do kernel, mensagens de servi√ßos, eventos de dispositivos, etc., n√£o apenas erros cr√≠ticos. **Dica:** √â um bom ponto de partida, mas pode ser "barulhento". Filtre com `grep`!                                                                                                                                                               |
| 103 | Para visualizar as √∫ltimas 50 linhas do log de autentica√ß√£o `/var/log/secure` e continuar monitorando novas entradas, o comando `tail -n 50 -f /var/log/secure` √© adequado.                                                      | V        | Verdadeiro! ‚úÖ `tail -n 50` mostra as √∫ltimas 50 linhas. A op√ß√£o `-f` (follow) mant√©m o arquivo aberto e exibe novas linhas √† medida que s√£o adicionadas. Essencial para monitorar logins em tempo real. üëÅÔ∏è                                                                                                                                                                                                                                                                                                |
| 104 | O comando `cat /var/log/dmesg` √© a √∫nica forma de visualizar as mensagens do buffer de anel do kernel em um sistema Linux.                                                                                                       | F        | Falso! ‚ùå Embora `/var/log/dmesg` possa conter uma c√≥pia *est√°tica* das mensagens do boot, o comando din√¢mico e preferido para visualizar o buffer de anel do kernel (mensagens desde o boot e de eventos de hardware recentes) √© simplesmente `dmesg` (sem `cat` e sem caminho). Ele l√™ diretamente do buffer do kernel. **Dica:** `dmesg [pipe] less` para paginar.                                                                                                                                       |
| 105 | O comando `lastb` exibe um registro de tentativas de login malsucedidas no sistema, lendo do arquivo `/var/log/btmp`.                                                                                                            | V        | Verdadeiro! ‚úÖ `lastb` √© espec√≠fico para "bad logins". O arquivo `/var/log/btmp` (que precisa existir e ter permiss√µes corretas) armazena essas tentativas. √ötil para identificar ataques de for√ßa bruta. üïµÔ∏è‚Äç‚ôÄÔ∏è                                                                                                                                                                                                                                                                                            |
| 106 | O comando `grep "Failed password" /var/log/auth.log` funcionaria em um sistema RHEL para encontrar tentativas de senha falhas, assumindo que `/var/log/auth.log` √© o log de autentica√ß√£o padr√£o.                                 | F        | Falso! ‚ùå Em sistemas RHEL/Oracle Linux, o log de autentica√ß√£o padr√£o √© tipicamente `/var/log/secure` (ou gerenciado pelo `journald`). `/var/log/auth.log` √© mais comum em sistemas baseados em Debian. O `grep` em si estaria correto para o arquivo certo. **Dica Cespe:** Aten√ß√£o aos nomes de arquivos de log padr√£o entre fam√≠lias de distros!                                                                                                                                                         |
| 107 | Para visualizar logs de transa√ß√µes do `yum` (ou `dnf`), o arquivo `/var/log/yum.log` (ou `/var/log/dnf.log`) pode ser inspecionado para ver quais pacotes foram instalados, atualizados ou removidos.                            | V        | Verdadeiro! ‚úÖ Esses logs registram todas as opera√ß√µes realizadas pelo gerenciador de pacotes, incluindo datas, pacotes afetados e o usu√°rio que executou o comando (se via `sudo`). Muito √∫til para auditoria. üì¶                                                                                                                                                                                                                                                                                          |
| 108 | O comando `journalctl --list-boots` mostra uma lista de todos os arquivos de log rotacionados manualmente pelo administrador no diret√≥rio `/var/log/journal`.                                                                    | F        | Falso! ‚ùå `journalctl --list-boots` exibe uma lista das inicializa√ß√µes (boots) anteriores do sistema que foram registradas pelo journald. Cada boot tem um ID. √ötil para ver logs de um boot espec√≠fico com `journalctl -b <ID_DO_BOOT>`. N√£o tem a ver com rota√ß√£o manual.                                                                                                                                                                                                                                 |
| 109 | Para buscar por uma mensagem de erro espec√≠fica contendo "segmentation fault" em todos os arquivos de log dentro de `/var/log`, o comando `grep -r "segmentation fault" /var/log` √© eficaz.                                      | V        | Verdadeiro! ‚úÖ `grep -r` (recursivo) procura a string em todos os arquivos dentro do diret√≥rio `/var/log` e seus subdiret√≥rios. Uma forma r√°pida de varrer m√∫ltiplos logs. **Dica:** Pode gerar muita sa√≠da. Adicione `-i` para ignorar mai√∫sculas/min√∫sculas ou `-l` para listar apenas os nomes dos arquivos que cont√™m o padr√£o.                                                                                                                                                                         |
| 110 | Os logs do `cron` (agendador de tarefas) geralmente s√£o encontrados em `/var/log/cron` ou podem ser consultados via `journalctl -u crond.service`.                                                                               | V        | Verdadeiro! ‚úÖ O arquivo `/var/log/cron` registra a execu√ß√£o de jobs agendados. Em sistemas com `systemd`, o `journalctl -u crond` (ou `cronie` dependendo da distro) tamb√©m mostrar√° esses logs. ‚è∞                                                                                                                                                                                                                                                                                                         |
| 111 | O comando `ausearch -m avc -ts recent` √© usado para exibir logs de auditoria do SELinux (mensagens AVC - Access Vector Cache) a partir do √∫ltimo reboot.                                                                         | F        | Falso! ‚ùå `ausearch` √© para o subsistema de auditoria (`auditd`). `-m avc` filtra por mensagens de nega√ß√£o do SELinux. `-ts recent` significa "time start recent", geralmente os √∫ltimos 10 minutos. Para logs desde o boot, seria algo como `ausearch -m avc -ts boot`. **Dica:** `auditd` √© poderoso, mas complexo. `ausearch` e `aureport` s√£o seus amigos aqui.                                                                                                                                         |
| 112 | Para encontrar logs relacionados a um usu√°rio espec√≠fico, por exemplo "john", no `/var/log/secure`, pode-se usar `grep "john" /var/log/secure`.                                                                                  | V        | Verdadeiro! ‚úÖ Simples e direto. Se o nome de usu√°rio "john" aparecer em alguma linha do log de seguran√ßa (ex: login, `sudo`, falha de senha), o `grep` mostrar√° essa linha.                                                                                                                                                                                                                                                                                                                                |
| 113 | O comando `journalctl _PID=1234` exibe todas as mensagens de log geradas pelo processo com o Process ID (PID) 1234.                                                                                                              | V        | Verdadeiro! ‚úÖ O `journald` armazena metadados ricos, incluindo o PID do processo que gerou a mensagem. Filtrar por `_PID` √© muito √∫til para depurar um processo espec√≠fico.                                                                                                                                                                                                                                                                                                                                |
| 114 | Logs de sess√µes `sudo` (quais comandos foram executados com `sudo` e por quem) s√£o exclusivamente armazenados no arquivo pessoal `.bash_history` do usu√°rio que executou o `sudo`.                                               | F        | Falso! ‚ùå Logs de `sudo` s√£o registrados no sistema, tipicamente em `/var/log/secure` (ou via `journald` com o identificador `sudo`). Eles incluem o usu√°rio original, o comando executado e o diret√≥rio. O `.bash_history` registra comandos digitados no shell, mas n√£o √© o log de auditoria oficial do `sudo`. **Pegadinha de Seguran√ßa!**                                                                                                                                                               |
| 115 | O comando `less +F /var/log/httpd/error_log` abre o log de erros do Apache e se comporta de forma similar a `tail -f`, permitindo rolar para tr√°s e depois voltar a seguir o final do arquivo.                                   | V        | Verdadeiro! ‚úÖ `less +F` inicia o `less` no modo "follow" (similar ao `tail -f`). A vantagem √© que voc√™ pode pressionar `CTRL+C` para parar de seguir, navegar/pesquisar no buffer e depois `Shift+F` para voltar a seguir. Muito flex√≠vel! üìú‚û°Ô∏èüëÄ                                                                                                                                                                                                                                                          |
| 116 | Para ver os logs do kernel em tempo real √† medida que s√£o gerados, o comando `dmesg -w` ou `journalctl -kf` pode ser utilizado.                                                                                                  | V        | Verdadeiro! ‚úÖ `dmesg -w` (ou `--follow`) imprime novas mensagens do kernel. `journalctl -f` segue todos os logs do journal, e `-k` filtra apenas para mensagens do kernel. Ambos s√£o √∫teis para depurar problemas de hardware ou drivers.                                                                                                                                                                                                                                                                  |
| 117 | O comando `zgrep "pattern" /var/log/messages-*.gz` procura por "pattern" dentro de arquivos de log antigos que foram comprimidos com `gzip`.                                                                                     | V        | Verdadeiro! ‚úÖ Sistemas rotacionam e comprimem logs antigos para economizar espa√ßo (ex: `messages-20230101.gz`). `zgrep` funciona como `grep`, mas diretamente em arquivos `.gz` sem precisar descomprimi-los primeiro. Similarmente, `zcat`, `zless`, `bzgrep` para `.bz2`. ÂúßÁ∏Æ„É≠„Ç∞„ÇÇÊ§úÁ¥¢ÂèØËÉΩÔºÅ (Logs comprimidos tamb√©m podem ser pesquisados!) üóúÔ∏è                                                                                                                                                                |
| 118 | O comando `journalctl --vacuum-size=100M` apaga imediatamente todos os logs do journal, deixando apenas os √∫ltimos 100MB de logs.                                                                                                | F        | Falso! ‚ùå `journalctl --vacuum-size=100M` *reduzir√°* o tamanho total dos arquivos de journal arquivados para no m√°ximo 100MB, apagando os mais antigos se necess√°rio. Ele n√£o apaga "todos" os logs imediatamente, apenas gerencia o espa√ßo dos arquivados. Para limpar logs por tempo, use `--vacuum-time`. **Dica:** A configura√ß√£o de reten√ß√£o do journal est√° em `/etc/systemd/journald.conf`.                                                                                                          |
| 119 | O comando `lastlog` exibe informa√ß√µes sobre o √∫ltimo login de todos os usu√°rios do sistema, lendo do arquivo `/var/log/lastlog`.                                                                                                 | V        | Verdadeiro! ‚úÖ `lastlog` mostra o usu√°rio, a porta (tty/pts), o IP de origem (se login remoto) e a data/hora do √∫ltimo login. O arquivo `/var/log/lastlog` armazena esses dados.                                                                                                                                                                                                                                                                                                                            |
| 120 | Os logs de instala√ß√£o do sistema operacional (Anaconda em RHEL/Oracle) s√£o armazenados exclusivamente em `/var/log/anaconda/anaconda.log` e n√£o podem ser acessados de outra forma.                                              | F        | Falso! ‚ùå Embora `/var/log/anaconda/` seja o local principal durante e ap√≥s a instala√ß√£o, durante a instala√ß√£o em si, os logs tamb√©m podem estar em `/tmp/anaconda.log` ou outros locais tempor√°rios. Al√©m disso, `journald` tamb√©m pode capturar algumas mensagens relacionadas √† instala√ß√£o se estiver ativo. O arquivo `anaconda.log` √© o principal, mas n√£o o √∫nico.                                                                                                                                    |
| 121 | Para ver as mensagens de log do `firewalld` (firewall padr√£o em RHEL/Oracle 7+), pode-se usar `journalctl -u firewalld.service`.                                                                                                 | V        | Verdadeiro! ‚úÖ O `firewalld` registra suas atividades (como aplica√ß√£o de regras, in√≠cio, parada) no journal do `systemd`. Filtrar pela unidade `firewalld.service` √© a forma correta. üî•                                                                                                                                                                                                                                                                                                                    |
| 122 | O comando `ss -tulnp` mostra conex√µes de rede ativas e portas em escuta. Seus logs de atividade s√£o armazenados automaticamente em `/var/log/ss.log`.                                                                            | F        | Falso! ‚ùå `ss` √© uma ferramenta de *diagn√≥stico* de sockets, n√£o um servi√ßo que gera logs persistentes em `/var/log/ss.log`. Para logar conex√µes de rede, seriam necess√°rias ferramentas como `iptables` (com alvo LOG), `auditd` ou sniffers de pacotes como `tcpdump` configurados para registrar em arquivo. `ss` mostra o estado *atual*.                                                                                                                                                               |
| 123 | Para analisar logs de um servidor web Apache em RHEL/Oracle, os arquivos `/var/log/httpd/access_log` e `/var/log/httpd/error_log` s√£o os locais padr√£o a serem verificados.                                                      | V        | Verdadeiro! ‚úÖ `access_log` registra todas as requisi√ß√µes recebidas pelo servidor. `error_log` registra quaisquer erros encontrados pelo Apache durante o processamento de requisi√ß√µes ou em sua opera√ß√£o. Esses s√£o cruciais para troubleshooting e an√°lise de tr√°fego web. üåê                                                                                                                                                                                                                             |
| 124 | O comando `journalctl -p err` exibe todas as mensagens de log do journal com prioridade "erro" ou superior (crit, alert, emerg).                                                                                                 | V        | Verdadeiro! ‚úÖ `journalctl -p` (ou `--priority`) filtra mensagens por n√≠vel de severidade. `err` (ou `3`) mostra erros e mensagens mais cr√≠ticas. Outros n√≠veis: `debug` (7), `info` (6), `notice` (5), `warning` (4). **Dica:** `journalctl -p warning` para ver avisos e problemas mais s√©rios.                                                                                                                                                                                                           |
| 125 | Se o servi√ßo `rsyslog` for interrompido, o `systemd-journald` automaticamente para de coletar logs para evitar conflitos.                                                                                                        | F        | Falso! ‚ùå `systemd-journald` √© o coletor prim√°rio de logs na maioria dos sistemas `systemd`. `rsyslog` (se instalado e configurado) pode *ler* do journal e encaminhar logs para arquivos de texto tradicionais ou para servidores de log remotos. Se `rsyslog` parar, `journald` continua funcionando normalmente. Eles podem coexistir.                                                                                                                                                                   |
| 126 | O comando `who /var/log/wtmp` ou simplesmente `who` exibe quem est√° logado no sistema atualmente. O arquivo `/var/log/wtmp` armazena o hist√≥rico de logins e logouts.                                                            | V        | Verdadeiro! ‚úÖ `who` mostra usu√°rios logados no momento. `wtmp` (usado tamb√©m pelo `last`) √© o arquivo que registra o hist√≥rico de logins, logouts, reboots.                                                                                                                                                                                                                                                                                                                                                |
| 127 | O comando `sudo journalctl -f -u NetworkManager.service` permite a um usu√°rio n√£o-root monitorar em tempo real os logs do NetworkManager.                                                                                        | V        | Verdadeiro! ‚úÖ O `sudo` concede os privil√©gios necess√°rios para acessar os logs do `journald` (que geralmente s√£o protegidos). `-f` segue e `-u` filtra pela unidade. Isso √© √∫til para depurar problemas de conex√£o de rede.                                                                                                                                                                                                                                                                                |
| 128 | Os logs de auditoria (`auditd`) s√£o armazenados em formato bin√°rio no arquivo `/var/log/audit/audit.log` e podem ser lidos diretamente com `cat`.                                                                                | F        | Falso! ‚ùå Os logs do `auditd` em `/var/log/audit/audit.log` s√£o em formato de *texto*, mas com uma estrutura espec√≠fica. Eles n√£o s√£o bin√°rios. Podem ser lidos com `cat`, `less`, mas ferramentas como `ausearch` e `aureport` s√£o projetadas para interpret√°-los e consult√°-los de forma mais eficaz.                                                                                                                                                                                                     |
| 129 | Para extrair apenas as mensagens de log do kernel de um arquivo de journal exportado (`myjournal.log`), o comando `journalctl --file=myjournal.log -k` pode ser usado.                                                           | V        | Verdadeiro! ‚úÖ `journalctl --file=` permite ler de um arquivo de journal (que pode ter sido exportado de outro sistema ou de um backup). A op√ß√£o `-k` (ou `--dmesg`) filtra para mostrar apenas as mensagens do kernel contidas nesse arquivo.                                                                                                                                                                                                                                                              |
| 130 | O comando `logrotate` √© um daemon que monitora ativamente os arquivos de log e os rotaciona em tempo real assim que atingem um certo tamanho.                                                                                    | F        | Falso! ‚ùå `logrotate` √© um *utilit√°rio* que √© tipicamente executado periodicamente (ex: diariamente) via `cron`. Ele verifica os arquivos de log baseados em suas regras de configura√ß√£o (em `/etc/logrotate.conf` e `/etc/logrotate.d/`) e os rotaciona (renomeia, comprime, apaga antigos) de acordo. N√£o √© um daemon de monitoramento em tempo real.                                                                                                                                                     |
| 131 | Para encontrar a hora exata em que um pacote espec√≠fico (ex: `openssh-server`) foi instalado ou atualizado, o comando `rpm -q --last openssh-server` √© mais direto que `grep` no `yum.log`.                                      | V        | Verdadeiro! ‚úÖ `rpm -q --last <pacote>` mostra a data e hora da √∫ltima transa√ß√£o (instala√ß√£o/atualiza√ß√£o) do pacote especificado. √â mais preciso e r√°pido para essa informa√ß√£o espec√≠fica do que procurar manualmente no `yum.log`/`dnf.log`.                                                                                                                                                                                                                                                               |
| 132 | O comando `journalctl -S "YYYY-MM-DD HH:MM:SS" -U "YYYY-MM-DD HH:MM:SS"` exibe logs dentro do intervalo de tempo especificado, onde `-S` √© "since" (desde) e `-U` √© "until" (at√©).                                               | V        | Verdadeiro! ‚úÖ `-S` e `-U` s√£o as op√ß√µes para definir janelas de tempo precisas para consulta de logs no `journalctl`. O formato da data/hora √© flex√≠vel (ex: `journalctl -S "2023-01-15" -U "2023-01-16 10:00"`).                                                                                                                                                                                                                                                                                          |
| 133 | Todos os logs de aplica√ß√µes que n√£o s√£o servi√ßos do `systemd` s√£o automaticamente encaminhados para `/var/log/messages` por padr√£o em RHEL/Oracle Linux.                                                                         | F        | Falso! ‚ùå Muitas aplica√ß√µes (ex: bancos de dados, servidores web) t√™m seus pr√≥prios diret√≥rios e arquivos de log (ex: `/var/log/httpd/`, `/var/log/mysqld.log`). Elas podem ou n√£o ser configuradas para enviar c√≥pias para o syslog central. N√£o √© um encaminhamento autom√°tico universal para `/var/log/messages`.                                                                                                                                                                                        |
| 134 | O utilit√°rio `logger` pode ser usado em scripts para enviar mensagens personalizadas para o log do sistema (que ser√£o capturadas pelo `syslog` ou `journald`).                                                                   | V        | Verdadeiro! ‚úÖ `logger "Minha mensagem de script"` envia a string para o log do sistema. √ötil para registrar eventos importantes de scripts de automa√ß√£o.                                                                                                                                                                                                                                                                                                                                                   |
| 135 | O `systemd-journal-gatewayd` √© um servi√ßo que permite acessar logs do journal de um sistema remotamente via HTTP.                                                                                                                | V        | Verdadeiro! ‚úÖ Se `systemd-journal-gatewayd` estiver configurado e em execu√ß√£o, ele exp√µe uma API HTTP para consultar o journal, permitindo que ferramentas como `journal-remote` ou `curl` acessem os logs pela rede.                                                                                                                                                                                                                                                                                      |
| 136 | O comando `journalctl -o verbose` exibe as entradas de log em um formato JSON detalhado, mostrando todos os campos dispon√≠veis para cada entrada.                                                                                | F        | Falso! ‚ùå `journalctl -o verbose` mostra todos os campos de uma entrada do journal, mas em um formato de texto mais leg√≠vel, n√£o JSON. Para sa√≠da JSON, usa-se `journalctl -o json` (para JSON padr√£o) ou `journalctl -o json-pretty` (para JSON formatado e leg√≠vel).                                                                                                                                                                                                                                      |
| 137 | Em uma investiga√ß√£o forense, os timestamps nos logs do `journald` s√£o sempre confi√°veis e n√£o podem ser adulterados, mesmo por um atacante com privil√©gios de root.                                                              | F        | Falso! ‚ùå Embora o `journald` possa usar um rel√≥gio monot√¥nico e ter mecanismos de selagem (forward secure sealing - FSS) se configurado, um atacante com acesso root *pode* potencialmente alterar o rel√≥gio do sistema ou manipular os arquivos de journal diretamente (se n√£o selados ou se a chave for comprometida). Timestamps devem ser correlacionados com outras evid√™ncias. **Pegadinha de Per√≠cia!** üï∞Ô∏è                                                                                         |
| 138 | O comando `grep -Fx "Login Succeeded" /var/log/secure` procura pela linha exata "Login Succeeded" no arquivo, sem considerar substrings.                                                                                         | V        | Verdadeiro! ‚úÖ `grep -F` trata o padr√£o como uma string fixa (n√£o regex). `grep -x` casa a linha inteira. Combinados, `grep -Fx` busca por uma correspond√™ncia exata da linha inteira com a string fornecida. √ötil para padr√µes muito espec√≠ficos.                                                                                                                                                                                                                                                          |
| 139 | Logs de conex√µes de rede recusadas pelo `firewalld` podem ser visualizados com `journalctl -u firewalld [pipe] grep "REJECT"` ou `journalctl -u firewalld [pipe] grep "DROP"`.                                                   | V        | Verdadeiro! ‚úÖ O `firewalld` loga as a√ß√µes de pacotes que correspondem √†s suas regras (se o logging estiver habilitado para essas regras). Procurar por palavras-chave como `REJECT` (pacote recusado com uma mensagem ICMP) ou `DROP` (pacote descartado silenciosamente) nos logs do `firewalld` ajuda a identificar tr√°fego bloqueado.                                                                                                                                                                   |
| 140 | O comando `dnf history` exibe um hist√≥rico de transa√ß√µes do `dnf`, permitindo ver detalhes e at√© mesmo reverter (`dnf history undo <ID>`) ou refazer transa√ß√µes.                                                                 | V        | Verdadeiro! ‚úÖ `dnf history` (e `yum history`) √© muito √∫til para rastrear mudan√ßas de pacotes e, crucialmente, para desfazer uma transa√ß√£o problem√°tica. Cada transa√ß√£o tem um ID. `dnf history info <ID>` mostra detalhes.                                                                                                                                                                                                                                                                                 |
| 141 | A configura√ß√£o de rota√ß√£o de logs para a maioria dos servi√ßos em RHEL/Oracle Linux √© controlada exclusivamente pelo arquivo `/etc/systemd/journald.conf`.                                                                        | F        | Falso! ‚ùå `/etc/systemd/journald.conf` controla a rota√ß√£o e persist√™ncia do *journal do systemd*. A rota√ß√£o de logs de texto tradicionais (ex: `/var/log/messages`, `/var/log/httpd/access_log`) √© geralmente controlada pelo `logrotate` e seus arquivos de configura√ß√£o em `/etc/logrotate.conf` e `/etc/logrotate.d/`.                                                                                                                                                                                   |
| 142 | Para pesquisar logs do journal por um identificador de mensagem espec√≠fico (MESSAGE_ID), pode-se usar `journalctl MESSAGE_ID=<id_da_mensagem>`.                                                                                  | V        | Verdadeiro! ‚úÖ Desenvolvedores podem atribuir IDs √∫nicos a mensagens de log espec√≠ficas. Se voc√™ conhece o `MESSAGE_ID` de um evento particular, pode us√°-lo para filtrar logs do `journald` de forma precisa. Ex: `journalctl MESSAGE_ID=fc2e22bc6ee645b3b38e0495680280c4`.                                                                                                                                                                                                                                |
| 143 | Se o disco onde `/var/log/journal` est√° armazenado ficar cheio, o `journald` para de aceitar novas mensagens de log para evitar o travamento do sistema.                                                                         | F        | Falso! ‚ùå O `journald` √© projetado para ser resiliente. Se o armazenamento persistente (`/var/log/journal`) estiver cheio ou indispon√≠vel, ele pode continuar logando em mem√≥ria (`/run/log/journal` - vol√°til) ou reduzir a taxa de logging. Ele tentar√° n√£o perder mensagens, mas a persist√™ncia pode ser afetada. A prioridade √© manter o sistema funcionando.                                                                                                                                           |
| 144 | O comando `utmpdump /var/log/wtmp` exibe o conte√∫do do arquivo `wtmp` em um formato de texto leg√≠vel, mostrando cada registro de login/logout.                                                                                   | V        | Verdadeiro! ‚úÖ Arquivos como `wtmp` e `utmp` s√£o bin√°rios. `utmpdump` √© um utilit√°rio que os formata para inspe√ß√£o humana, mostrando detalhes como tipo de registro (login, logout, boot), usu√°rio, tty, timestamp, etc.                                                                                                                                                                                                                                                                                    |
| 145 | O comando `journalctl --verify` verifica a consist√™ncia e integridade dos arquivos de log do journal, reportando quaisquer corrup√ß√µes encontradas.                                                                               | V        | Verdadeiro! ‚úÖ `journalctl --verify` checa se os arquivos do journal est√£o intactos. Se a selagem (FSS) estiver habilitada, tamb√©m pode verificar se os arquivos foram adulterados. √ötil para garantir a confiabilidade dos logs. ‚úÖ                                                                                                                                                                                                                                                                         |
| 146 | Logs de atividades do `selinux-troubleshooter` (que ajuda a diagnosticar e resolver nega√ß√µes do SELinux) s√£o encontrados principalmente em `/var/log/selinux-troubleshooter.log`.                                                | F        | Falso! ‚ùå O `setroubleshootd` (daemon do `selinux-troubleshooter`) geralmente loga suas descobertas e sugest√µes no log de auditoria (`/var/log/audit/audit.log`) e tamb√©m via `journald`. As notifica√ß√µes podem aparecer em `gnome-shell` ou outras interfaces. O `sealert -a /var/log/audit/audit.log` √© usado para analisar as nega√ß√µes AVC e obter sugest√µes.                                                                                                                                            |
| 147 | Para ver logs de uma unidade `systemd` que falhou em iniciar durante o boot, o comando `systemctl status nome.unidade` seguido de `journalctl -xe -u nome.unidade` ap√≥s o boot √© uma boa abordagem.                              | V        | Verdadeiro! ‚úÖ `systemctl status` geralmente mostra as √∫ltimas linhas de log da unidade e indica se falhou. `journalctl -xe` mostra mais detalhes sobre o erro (`-x` adiciona explica√ß√µes, `-e` pula para o final) e `-u nome.unidade` filtra pela unidade.                                                                                                                                                                                                                                                 |
| 148 | O comando `find /var/log -name "*.gz" -exec zgrep "ERROR" {} \; -print` procura "ERROR" em todos os logs `.gz` e imprime o nome do arquivo se encontrar, mas n√£o o conte√∫do da linha.                                            | F        | Falso! ‚ùå A a√ß√£o padr√£o do `zgrep` (sem `-l`) √© imprimir as linhas que casam. O `-print` do `find` imprimiria o nome do arquivo ap√≥s a execu√ß√£o do `zgrep` para aquele arquivo. Se quisesse apenas os nomes dos arquivos, seria `find /var/log -name "*.gz" -exec zgrep -l "ERROR" {} \;`.                                                                                                                                                                                                                  |
| 149 | O `SystemMaxUse=` em `/etc/systemd/journald.conf` define o tamanho m√°ximo que o journal persistente (`/var/log/journal`) pode ocupar no disco, e o `journald` apagar√° logs antigos para respeit√°-lo.                             | V        | Verdadeiro! ‚úÖ Essa diretiva, junto com `SystemKeepFree=`, controla o uso de disco pelo `journald`. Se o limite `SystemMaxUse=` for atingido, logs mais antigos s√£o removidos. √â uma forma de gerenciar o espa√ßo ocupado pelos logs. üíæ                                                                                                                                                                                                                                                                     |
| 150 | Logs de sess√µes Xorg (servidor gr√°fico) s√£o tipicamente encontrados em `~/.xsession-errors` ou `/var/log/Xorg.0.log`.                                                                                                            | V        | Verdadeiro! ‚úÖ `/var/log/Xorg.0.log` (onde 0 √© o display) cont√©m logs detalhados da inicializa√ß√£o e opera√ß√£o do servidor X. `~/.xsession-errors` (no diret√≥rio home do usu√°rio) coleta erros de aplica√ß√µes gr√°ficas dentro da sess√£o X. Ambos s√£o √∫teis para depurar problemas gr√°ficos. üñ•Ô∏è                                                                                                                                                                                                                |
| 151 | O comando `journalctl -F _SYSTEMD_UNIT` lista todos os valores √∫nicos para o campo `_SYSTEMD_UNIT` presentes nos logs do journal.                                                                                                | V        | Verdadeiro! ‚úÖ `journalctl -F <NOME_DO_CAMPO>` √© uma forma √∫til de descobrir quais valores existem para um campo espec√≠fico no journal. Isso ajuda a saber por quais unidades voc√™ pode filtrar com `-u`.                                                                                                                                                                                                                                                                                                   |
| 152 | Logs de eventos do Network Time Protocol (NTP), gerenciados pelo `chronyd` em RHEL/Oracle 7+, podem ser visualizados usando `journalctl -u chronyd` ou verificando `/var/log/chrony/`.                                           | V        | Verdadeiro! ‚úÖ `chronyd` loga no journal do systemd. Adicionalmente, dependendo da configura√ß√£o em `/etc/chrony.conf`, ele pode manter logs mais detalhados (estat√≠sticas, medi√ß√µes) no diret√≥rio `/var/log/chrony/`.                                                                                                                                                                                                                                                                                       |
| 153 | O comando `aureport -l` exibe um relat√≥rio resumido de todos os logins e logouts registrados pelo subsistema de auditoria `auditd`.                                                                                              | V        | Verdadeiro! ‚úÖ `aureport` √© uma ferramenta para gerar relat√≥rios a partir dos logs do `auditd`. `-l` especificamente foca em eventos de login/logout. Outras op√ß√µes: `-u` (eventos de usu√°rio), `-x` (execut√°veis).                                                                                                                                                                                                                                                                                         |
| 154 | Para ver os logs de um "timer" do systemd (equivalente a um cron job), deve-se procurar pelos logs da unidade `.service` que o timer ativa, n√£o do timer em si.                                                                  | V        | Verdadeiro! ‚úÖ Um timer (`.timer`) apenas ativa uma unidade de servi√ßo (`.service`) em um hor√°rio espec√≠fico. Os logs da execu√ß√£o real da tarefa estar√£o associados √† unidade de servi√ßo. Ex: Se `meutimer.timer` ativa `meuservico.service`, procure com `journalctl -u meuservico.service`.                                                                                                                                                                                                               |
| 155 | O comando `journalctl --sync` for√ßa o `journald` a escrever imediatamente quaisquer dados de log em buffer para o armazenamento persistente em disco.                                                                            | V        | Verdadeiro! ‚úÖ Por performance, `journald` pode manter logs em buffer antes de escrev√™-los. `journalctl --sync` garante que tudo que est√° em mem√≥ria seja "descarregado" para o disco, √∫til antes de um desligamento ou para garantir que os logs estejam completos.                                                                                                                                                                                                                                        |
| 156 | Logs de erros do Postfix (servidor de email) s√£o geralmente encontrados em `/var/log/maillog` e podem ser filtrados por `grep "postfix/error" /var/log/maillog`.                                                                 | F        | Falso! ‚ùå Embora `/var/log/maillog` seja o log principal do Postfix, os erros espec√≠ficos do Postfix geralmente n√£o s√£o prefixados com "postfix/error". Mensagens de erro ter√£o contextos diferentes (ex: `postfix/smtpd`, `postfix/qmgr`) seguido da descri√ß√£o do erro. O `grep` precisaria ser mais gen√©rico ou espec√≠fico para o tipo de erro buscado.                                                                                                                                                   |
| 157 | O comando `journalctl -b -1 -p crit` exibe mensagens de log com prioridade "cr√≠tica" ou superior do boot anterior ao atual.                                                                                                      | V        | Verdadeiro! ‚úÖ `-b -1` seleciona o boot anterior (o pen√∫ltimo boot). `-p crit` (ou `-p 2`) filtra por mensagens de n√≠vel cr√≠tico e emerg√™ncia (alert). √ötil para investigar por que um sistema pode ter travado ou reiniciado inesperadamente.                                                                                                                                                                                                                                                              |
| 158 | O arquivo `/var/run/utmp` armazena o hist√≥rico de todos os logins desde a instala√ß√£o do sistema.                                                                                                                                 | F        | Falso! ‚ùå `/var/run/utmp` (ou `/run/utmp` que √© um link simb√≥lico) armazena informa√ß√µes sobre os usu√°rios *atualmente* logados no sistema. O hist√≥rico de logins √© armazenado em `/var/log/wtmp`.                                                                                                                                                                                                                                                                                                           |
| 159 | Para ver logs de um cont√™iner Docker espec√≠fico em um sistema RHEL/Oracle, o comando `docker logs <container_id_ou_nome>` √© a forma padr√£o.                                                                                      | V        | Verdadeiro! ‚úÖ O Docker gerencia os logs (stdout/stderr) de seus cont√™ineres. O comando `docker logs` permite visualiz√°-los. Logs tamb√©m podem ser encaminhados para o `journald` ou outros drivers de log, dependendo da configura√ß√£o do Docker. üê≥                                                                                                                                                                                                                                                        |
| 160 | O `Storage=persistent` em `/etc/systemd/journald.conf` garante que os logs do journal sejam sempre armazenados em `/var/log/journal` e sobrevivam a reboots.                                                                     | V        | Verdadeiro! ‚úÖ Se `Storage=persistent`, `journald` criar√° `/var/log/journal` (se n√£o existir) e armazenar√° logs l√°. Outras op√ß√µes: `volatile` (apenas em `/run/log/journal`, perdido no reboot) ou `auto` (padr√£o: persistente se `/var/log/journal` existir, sen√£o vol√°til).                                                                                                                                                                                                                               |
| 161 | O comando `last -f /var/log/btmp` exibe tentativas de login bem-sucedidas de um arquivo de log btmp alternativo.                                                                                                                 | F        | Falso! ‚ùå `lastb` (ou `last -f /var/log/btmp` se o sistema n√£o tiver `lastb`) l√™ do `btmp` para mostrar logins *malsucedidos*. `last` (sem `-f /var/log/btmp`) l√™ do `wtmp` para logins bem-sucedidos. Usar `last` com `btmp` mostraria os mesmos dados que `lastb`.                                                                                                                                                                                                                                        |
| 162 | Para exportar todos os logs do journal para um arquivo √∫nico que pode ser transferido para outra m√°quina, `journalctl -o export > meus_logs.export` √© um m√©todo v√°lido.                                                          | V        | Verdadeiro! ‚úÖ `journalctl -o export` produz um formato bin√°rio serializado que pode ser lido por `journalctl --file=` em outra m√°quina (ou na mesma). Redirecionar a sa√≠da para um arquivo salva essa exporta√ß√£o.                                                                                                                                                                                                                                                                                          |
| 163 | O comando `journalctl --disk-usage` mostra o espa√ßo em disco atualmente ocupado pelos arquivos de log do journal, tanto os ativos quanto os arquivados.                                                                          | V        | Verdadeiro! ‚úÖ Este comando fornece uma vis√£o r√°pida de quanto espa√ßo os logs do `journald` est√£o consumindo em `/var/log/journal/` (se persistente) e `/run/log/journal/` (vol√°til).                                                                                                                                                                                                                                                                                                                       |
| 164 | A presen√ßa de muitas mensagens "Connection closed by authenticating user" no `/var/log/secure` geralmente indica um problema com o servi√ßo `sshd` que est√° derrubando conex√µes leg√≠timas.                                        | F        | Falso! ‚ùå Essa mensagem geralmente indica que um *usu√°rio* (ou script) se conectou via SSH e depois se desconectou *normalmente*. Se fosse um problema do `sshd`, as mensagens de erro seriam diferentes e mais expl√≠citas sobre a falha do servi√ßo. Pode indicar logins/logouts frequentes, mas n√£o necessariamente um problema.                                                                                                                                                                           |
| 165 | Se um script chamado `meu_script.sh` √© executado via `cron`, sua sa√≠da padr√£o (stdout) e erro padr√£o (stderr) s√£o automaticamente logadas no `journald` com a unidade `meu_script.sh.service`.                                   | F        | Falso! ‚ùå `cron` por padr√£o envia a sa√≠da (stdout/stderr) dos scripts por email para o propriet√°rio da crontab. Para logar no `journald` de forma estruturada, o script precisaria usar `logger` ou ser executado como uma unidade de servi√ßo `systemd` ativada por um timer `systemd`. Se o `cron` for configurado para logar suas a√ß√µes, ele logar√° o *in√≠cio/fim* da execu√ß√£o do script, n√£o sua sa√≠da interna.                                                                                          |
| 166 | O comando `ausearch -k minha_chave_audit` procura por eventos de auditoria que foram marcados com a chave "minha_chave_audit" nas regras do `auditd`.                                                                            | V        | Verdadeiro! ‚úÖ Regras do `auditd` (em `/etc/audit/rules.d/`) podem ter um campo `-k <chave>` para facilitar a busca por eventos espec√≠ficos. `ausearch -k <chave>` √© a forma de filtrar por essa chave.                                                                                                                                                                                                                                                                                                     |
| 167 | O comando `journalctl -n 20 --no-pager` exibe as √∫ltimas 20 entradas do journal diretamente no terminal, sem usar um paginador como `less`.                                                                                      | V        | Verdadeiro! ‚úÖ `-n 20` especifica o n√∫mero de linhas. `--no-pager` envia a sa√≠da diretamente para stdout, o que √© √∫til se voc√™ quiser redirecionar para outro comando ou arquivo.                                                                                                                                                                                                                                                                                                                           |
| 168 | O arquivo `/var/log/boot.log` cont√©m um registro detalhado de todas as chamadas de sistema feitas durante o processo de inicializa√ß√£o do sistema.                                                                                | F        | Falso! ‚ùå `/var/log/boot.log` geralmente cont√©m as mensagens de console que s√£o exibidas durante o boot, mostrando o status de in√≠cio dos servi√ßos (no estilo System V init ou mensagens de compatibilidade). N√£o √© um log de *todas* as chamadas de sistema. Para isso, seria necess√°rio `strace` em processos espec√≠ficos ou auditoria detalhada, o que n√£o √© padr√£o para o `boot.log`.                                                                                                                   |
| 169 | Para ver logs de um kernel panic que ocorreu em um boot anterior e o `kdump` estava configurado, os arquivos de dump (`vmcore`) estariam em `/var/crash/` e poderiam ser analisados com `crash`.                                 | V        | Verdadeiro! ‚úÖ `kdump` √© um mecanismo que captura um dump da mem√≥ria do kernel quando ocorre um panic. Esses dumps s√£o salvos (por padr√£o) em `/var/crash/<data-hora>/vmcore`. A ferramenta `crash` √© usada para analisar esses `vmcore` e depurar a causa do panic.                                                                                                                                                                                                                                        |
| 170 | O `ForwardToSyslog=yes` no `/etc/systemd/journald.conf` faz com que o `journald` envie uma c√≥pia de todas as suas mensagens de log para um soquete Unix que o `rsyslogd` (ou similar) pode escutar.                              | V        | Verdadeiro! ‚úÖ Esta √© a configura√ß√£o padr√£o na maioria dos sistemas para permitir que daemons syslog tradicionais processem logs do `journald`. `journald` encaminha para `/run/systemd/journal/syslog`.                                                                                                                                                                                                                                                                                                    |
| 171 | O comando `journalctl --cursor=<cursor_salvo>` permite retomar a visualiza√ß√£o dos logs a partir de um ponto espec√≠fico salvo anteriormente.                                                                                      | V        | Verdadeiro! ‚úÖ Quando voc√™ visualiza logs, `journalctl` mostra um campo `-- cursor: ...` no final. Voc√™ pode copiar esse cursor e us√°-lo depois com `journalctl --after-cursor=<cursor>` ou `journalctl --cursor=<cursor>` para continuar de onde parou ou ver logs a partir daquele ponto. √ötil para an√°lises longas.                                                                                                                                                                                      |
| 172 | A rota√ß√£o de logs configurada no `logrotate` para um arquivo como `/var/log/myapp.log` s√≥ ocorrer√° se o servi√ßo `logrotate.service` do systemd estiver ativo e em execu√ß√£o.                                                      | F        | Falso! ‚ùå `logrotate` n√£o √© um servi√ßo/daemon. √â um utilit√°rio executado periodicamente (geralmente via `/etc/cron.daily/logrotate`). N√£o existe um `logrotate.service` padr√£o que precise estar ativo. A execu√ß√£o √© agendada pelo `cron`.                                                                                                                                                                                                                                                                  |
| 173 | Para ver logs do `tuned` (daemon de ajuste de performance), o comando `journalctl -u tuned.service` e a verifica√ß√£o de `/var/log/tuned/tuned.log` s√£o apropriados.                                                               | V        | Verdadeiro! ‚úÖ `tuned` loga no journal do systemd e tamb√©m mant√©m seu pr√≥prio log em `/var/log/tuned/tuned.log` com informa√ß√µes sobre os perfis aplicados e ajustes feitos.                                                                                                                                                                                                                                                                                                                                 |
| 174 | Se o `journald` estiver configurado com `Storage=volatile`, nenhum log sobreviver√° a um reboot, e `/var/log/journal` n√£o ser√° criado.                                                                                            | V        | Verdadeiro! ‚úÖ `Storage=volatile` significa que os logs s√£o mantidos apenas em mem√≥ria (em `/run/log/journal/`) e s√£o perdidos quando o sistema √© desligado ou reiniciado. O diret√≥rio `/var/log/journal/` n√£o ser√° usado.                                                                                                                                                                                                                                                                                  |
| 175 | O comando `grep -E "error                                                                                                                                                                                                        | warning  | critical" /var/log/messages` usa express√µes regulares estendidas para encontrar linhas contendo "error" OU "warning" OU "critical".                                                                                                                                                                                                                                                                                                                                                                        | V        | Verdadeiro! ‚úÖ `grep -E` ativa ERE (Extended Regular Expressions). O `|` atua como um operador "OU" l√≥gico. Isso permite buscar por m√∫ltiplos padr√µes em uma √∫nica passagem.                                                                                                                                                                                                                                                                                                                                                     |
| 176 | Os logs do servidor de banco de dados MariaDB/MySQL s√£o configurados exclusivamente atrav√©s de diretivas no arquivo `my.cnf` e nunca s√£o enviados ao `journald` ou `syslog`.                                                     | F        | Falso! ‚ùå Embora o arquivo principal de log de erros do MariaDB/MySQL seja definido no `my.cnf` (ex: `log-error=/var/log/mysql/error.log`), √© poss√≠vel configurar o servidor para enviar logs tamb√©m para o `syslog` (e consequentemente para o `journald` se o syslog estiver integrado), usando diretivas como `syslog` no `my.cnf` ou plugins espec√≠ficos.                                                                                                                                               |
| 177 | O comando `journalctl --since "09:00" --until "17:00" _COMM=sshd` mostra os logs do processo `sshd` gerados hoje entre 9h e 17h.                                                                                                 | V        | Verdadeiro! ‚úÖ Se a data n√£o for especificada em `--since` e `--until`, `journalctl` assume o dia atual. `_COMM=sshd` filtra pelo nome do execut√°vel do processo.                                                                                                                                                                                                                                                                                                                                           |
| 178 | `journalctl -q` executa o comando em modo "quiet" (silencioso), suprimindo todas as mensagens informativas do pr√≥prio `journalctl` e mostrando apenas as entradas de log.                                                        | V        | Verdadeiro! ‚úÖ O modo quieto (`-q`) √© √∫til quando a sa√≠da do `journalctl` est√° sendo usada em scripts ou quando se deseja uma visualiza√ß√£o mais limpa, sem as mensagens "Logs begin at..." ou "No new FSS entries".                                                                                                                                                                                                                                                                                         |
| 179 | O comando `rpm -qa --changelog [pipe] grep CVE-2023-XXXX` permite verificar se algum pacote instalado teve um changelog mencionando uma CVE espec√≠fica.                                                                          | V        | Verdadeiro! ‚úÖ `rpm -qa --changelog` lista o changelog de todos os pacotes instalados. Ao "pipar" para `grep`, voc√™ pode buscar por refer√™ncias a CVEs (Common Vulnerabilities and Exposures) para ver se patches para vulnerabilidades conhecidas foram aplicados.                                                                                                                                                                                                                                         |
| 180 | O comando `logwatch` √© uma ferramenta que analisa logs do sistema e gera um relat√≥rio resumido, geralmente enviado por email ao administrador.                                                                                   | V        | Verdadeiro! ‚úÖ `logwatch` (ou `logsentry`) √© um analisador de logs personaliz√°vel que processa v√°rios arquivos de log, resume atividades incomuns ou importantes e pode enviar um relat√≥rio. √â √∫til para uma vis√£o geral di√°ria da sa√∫de do sistema.                                                                                                                                                                                                                                                        |
| 181 | O comando `journalctl --merge` √© usado para combinar logs do journal de m√∫ltiplos sistemas remotos em uma √∫nica visualiza√ß√£o local.                                                                                              | F        | Falso! ‚ùå `journalctl --merge` √© usado para exibir entradas intercaladas de *todos os journals dispon√≠veis localmente* (ex: de m√∫ltiplos boots, ou de diferentes arquivos de journal se voc√™ especificou v√°rios com `--file` ou `--dir`). Para logs remotos, seriam necess√°rias ferramentas como `systemd-journal-remote` e `journal-upload`.                                                                                                                                                               |
| 182 | Se o `auditd` n√£o estiver em execu√ß√£o, o kernel Linux ainda realiza uma auditoria b√°sica de seguran√ßa e armazena os logs em `/var/log/kern.log`.                                                                                 | F        | Falso! ‚ùå O subsistema de auditoria do kernel depende do daemon `auditd` em espa√ßo de usu√°rio para coletar e registrar os eventos. Se `auditd` n√£o estiver rodando, os eventos de auditoria gerados pelo kernel geralmente s√£o perdidos (a menos que o `kauditd` esteja configurado para logar no `printk`, o que √© raro e limitado). `/var/log/kern.log` √© para mensagens gerais do kernel.                                                                                                                |
| 183 | O comando `journalctl _HOSTNAME=server01 -u nginx.service` exibe os logs do servi√ßo `nginx` especificamente do host chamado `server01`, assumindo que os logs foram centralizados.                                               | V        | Verdadeiro! ‚úÖ Se os logs est√£o sendo agregados em um servidor central (ex: usando `systemd-journal-upload` e `systemd-journal-remote`), o `journald` armazena o hostname de origem no campo `_HOSTNAME`. Filtrar por este campo permite isolar logs de uma m√°quina espec√≠fica.                                                                                                                                                                                                                             |
| 184 | `journalctl -p 0..2` exibe mensagens de log com prioridades de emerg√™ncia (0), alerta (1) e cr√≠tica (2).                                                                                                                         | V        | Verdadeiro! ‚úÖ A sintaxe `N..M` com a op√ß√£o `-p` permite especificar um intervalo de prioridades. 0=emerg, 1=alert, 2=crit, 3=err, 4=warning, 5=notice, 6=info, 7=debug.                                                                                                                                                                                                                                                                                                                                    |
| 185 | Os arquivos em `/var/log/sa/` (gerados pelo `sysstat`/`sar`) cont√™m logs textuais detalhados sobre o uso de CPU e mem√≥ria por cada processo individual.                                                                          | F        | Falso! ‚ùå Os arquivos em `/var/log/sa/` (ex: `saDD`, `sarDD`) s√£o arquivos de dados *bin√°rios* coletados pelo `sadc` (parte do `sysstat`). O comando `sar` √© usado para ler esses arquivos e gerar relat√≥rios textuais sobre a utiliza√ß√£o de recursos do sistema (CPU, mem√≥ria, I/O, rede) de forma agregada ou por dispositivo, mas n√£o tipicamente por processo individual de forma detalhada como um log cont√≠nuo.                                                                                       |
| 186 | O comando `journalctl --output-fields=MESSAGE,_PID,_COMM -u myapp` exibe apenas os campos MESSAGE, _PID e _COMM das entradas de log da unidade `myapp`.                                                                          | V        | Verdadeiro! ‚úÖ `--output-fields=` permite customizar quais campos do journal s√£o exibidos, √∫til para criar sa√≠das mais concisas e espec√≠ficas para an√°lise ou scripting.                                                                                                                                                                                                                                                                                                                                    |
| 187 | O `RateLimitIntervalSec=` e `RateLimitBurst=` no `/etc/systemd/journald.conf` controlam a taxa m√°xima de logs de erro que o `sshd` pode gerar.                                                                                   | F        | Falso! ‚ùå Essas op√ß√µes no `journald.conf` controlam a taxa com que o *pr√≥prio journald* aceita mensagens de *todos* os servi√ßos. Se um servi√ßo logar muito rapidamente, o `journald` pode come√ßar a descartar mensagens desse servi√ßo para proteger o sistema. N√£o √© espec√≠fico para `sshd` nem para logs de erro apenas.                                                                                                                                                                                   |
| 188 | `journalctl --no-hostname` suprime o campo de hostname da sa√≠da, √∫til se todos os logs s√£o do sistema local.                                                                                                                     | V        | Verdadeiro! ‚úÖ Se voc√™ est√° analisando logs apenas da m√°quina local, o hostname pode ser redundante. `--no-hostname` limpa a sa√≠da.                                                                                                                                                                                                                                                                                                                                                                         |
| 189 | O comando `dnf provides /usr/bin/somecommand` pode ajudar a identificar qual pacote instalou `somecommand`, e ent√£o o `dnf history info <package_name>` pode mostrar quando foi instalado.                                       | V        | Verdadeiro! ‚úÖ `dnf provides` (ou `yum provides`) identifica o pacote. Depois, `dnf history info <nome_do_pacote>` ou `rpm -q --last <nome_do_pacote>` podem ser usados para obter informa√ß√µes sobre a transa√ß√£o de instala√ß√£o/atualiza√ß√£o. Uma cadeia de comandos √∫til para rastrear a origem e o hist√≥rico de arquivos.                                                                                                                                                                                   |
| 190 | Logs de sess√µes `screen` ou `tmux` (multiplexadores de terminal) s√£o automaticamente armazenados em `/var/log/screen_tmux.log` para auditoria.                                                                                   | F        | Falso! ‚ùå `screen` e `tmux` por padr√£o n√£o logam o conte√∫do das sess√µes em um arquivo central de auditoria. `screen` pode ser configurado para logar a sa√≠da de uma janela espec√≠fica (`CTRL+A H`). `tmux` tem `pipe-pane`. Para auditoria robusta de sess√µes, seriam necess√°rias ferramentas dedicadas de grava√ß√£o de sess√£o ou configura√ß√£o de auditoria do shell.                                                                                                                                        |
| 191 | O comando `journalctl -g "Disconnected from user"` procura pela string "Disconnected from user" em qualquer campo de metadados de uma entrada do journal, n√£o apenas no campo MESSAGE.                                           | V        | Verdadeiro! ‚úÖ `journalctl -g` (grep) procura o padr√£o em todos os campos da entrada do journal, enquanto `journalctl <PADR√ÉO>` (sem op√ß√£o) geralmente procura apenas no campo MESSAGE. `-g` √© mais abrangente.                                                                                                                                                                                                                                                                                             |
| 192 | O comando `journalctl --flush` apaga todos os logs do journal que est√£o em armazenamento vol√°til (`/run/log/journal`) mas mant√©m os logs persistentes (`/var/log/journal`).                                                      | F        | Falso! ‚ùå `journalctl --flush` move todas as mensagens de log do armazenamento vol√°til (`/run/log/journal`) para o armazenamento persistente (`/var/log/journal`), se a persist√™ncia estiver habilitada. Ele n√£o apaga os logs vol√°teis, ele os "descarrega" para o disco. Se a persist√™ncia n√£o estiver habilitada, ele pode n√£o ter muito efeito.                                                                                                                                                         |
| 193 | O comando `ausearch -i -sc execve -uid admin` tenta interpretar numerics (como UID) em nomes e procura por todas as chamadas de sistema `execve` feitas pelo usu√°rio `admin`.                                                    | V        | Verdadeiro! ‚úÖ `-i` instrui `ausearch` a interpretar valores num√©ricos (como UIDs para nomes de usu√°rio, GIDs para nomes de grupo). `-sc execve` filtra por chamadas de sistema `execve` (execu√ß√£o de programas). `-uid admin` filtra pelo usu√°rio que iniciou o processo. √ötil para rastrear quais programas um usu√°rio espec√≠fico executou.                                                                                                                                                               |
| 194 | O comando `logresolve` √© um utilit√°rio que resolve endere√ßos IP em nomes de host em arquivos de log do Apache, modificando o arquivo de log original.                                                                            | F        | Falso! ‚ùå `logresolve` (parte do Apache) l√™ um arquivo de log do Apache contendo endere√ßos IP, realiza a resolu√ß√£o reversa de DNS para obter os hostnames e envia o resultado (com hostnames) para a *sa√≠da padr√£o*. Ele n√£o modifica o arquivo de log original. √â usado para p√≥s-processamento.                                                                                                                                                                                                            |
| 195 | O comando `journalctl -k --grep="memory error"` exibe mensagens do kernel que cont√™m a string "memory error".                                                                                                                    | V        | Verdadeiro! ‚úÖ `-k` filtra para mensagens do kernel. `--grep=` aplica um filtro adicional de express√£o regular √† mensagem dessas entradas do kernel. Combina√ß√£o poderosa para encontrar problemas espec√≠ficos do kernel.                                                                                                                                                                                                                                                                                    |
| 196 | A configura√ß√£o `MaxLevelStore=debug` no `/etc/systemd/journald.conf` far√° com que o `journald` armazene permanentemente apenas logs com n√≠vel `debug` ou inferior.                                                               | F        | Falso! ‚ùå `MaxLevelStore=` define o n√≠vel *m√°ximo* de mensagens que s√£o armazenadas no disco. Mensagens com prioridade *menor ou igual* (mais severas) a este n√≠vel s√£o armazenadas. `debug` √© o n√≠vel menos severo (7). Se `MaxLevelStore=debug`, todos os n√≠veis (0-7) seriam armazenados. Se fosse `MaxLevelStore=err` (3), apenas err, crit, alert, emerg (0-3) seriam armazenados no disco de forma persistente.                                                                                       |
| 197 | O comando `cat /var/log/secure [pipe] awk '{print $1, $2, $3, $6}' [pipe] grep "Accepted"` pode ser usado para extrair data, hora, hostname e usu√°rio de logins SSH bem-sucedidos.                                               | V        | Verdadeiro! ‚úÖ Assumindo um formato de log t√≠pico, `$1, $2, $3` seriam M√™s, Dia, Hora. `$6` poderia ser o nome de usu√°rio (ou parte da mensagem indicando o usu√°rio). Filtrar por "Accepted" focaria em logins bem-sucedidos. `awk` √© √≥timo para extrair campos espec√≠ficos.                                                                                                                                                                                                                                |
| 198 | O comando `journalctl --since=-3d --until=-1d` exibe logs gerados entre 3 dias atr√°s e 1 dia atr√°s, em rela√ß√£o ao momento atual.                                                                                                 | V        | Verdadeiro! ‚úÖ `journalctl` aceita tempos relativos. `-3d` significa "tr√™s dias atr√°s". `-1d` significa "um dia atr√°s". Isso cria uma janela de dois dias de logs (excluindo os logs de ontem e de hoje).                                                                                                                                                                                                                                                                                                   |
| 199 | O comando `sudo tail -F /var/log/audit/audit.log [pipe] grep 'op=PAM:accounting'` permite monitorar em tempo real eventos de auditoria relacionados ao in√≠cio e fim de sess√µes de usu√°rios via PAM.                              | V        | Verdadeiro! ‚úÖ `tail -F` √© robusto para seguir logs que podem ser rotacionados. O `audit.log` registra eventos PAM. `op=PAM:accounting` √© um tipo de registro que indica o in√≠cio/fim de sess√µes gerenciadas pelo PAM (Pluggable Authentication Modules), o que geralmente correlaciona com logins/logouts de usu√°rios.                                                                                                                                                                                     |
| 200 | Para garantir que os logs do `journald` sejam selados contra adultera√ß√£o (FSS - Forward Secure Sealing), basta criar o arquivo `/etc/systemd/journal-seal.key`.                                                                  | F        | Falso! ‚ùå A selagem (FSS) √© mais complexa. Envolve a gera√ß√£o de um par de chaves (com `journald-fss-setup` ou similar), a chave de verifica√ß√£o precisa ser armazenada de forma segura (idealmente offline ou em um sistema confi√°vel separado). A simples cria√ß√£o de um arquivo n√£o habilita FSS. O `journald` precisa ser configurado com `Seal=yes` e ter acesso √† chave de selagem (geralmente via `systemd-journal-gatewayd` ou `systemd-journal-remote` para selagem local).                           |