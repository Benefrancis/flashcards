| id | afirma√ß√£o                                                                                                                                                                                             | resposta | explica√ß√£o                                                                                                                                                                                                                                                                                                                                                                                     |
|----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | A cobertura de c√≥digo √© uma m√©trica que garante a aus√™ncia total de defeitos em um software, desde que `100%` de cobertura de linhas seja alcan√ßada.                                                          | F        | ‚ùå Falso. Cobertura de c√≥digo, mesmo `100%`, indica que o c√≥digo foi *exercitado* pelos testes, mas n√£o garante a *qualidade* desses testes ou a aus√™ncia de bugs. Testes podem cobrir c√≥digo sem verificar sa√≠das corretas. üß† **Dica:** `100%` de cobertura n√£o √© sin√¥nimo de software perfeito. A banca adora essa pegadinha!                                                                  |
| 2  | Cobertura de Decis√£o (Branch Coverage) √© considerada mais rigorosa e abrangente que a Cobertura de Linhas (Statement Coverage), pois exige que cada resultado poss√≠vel de uma decis√£o seja testado.      | V        | ‚úîÔ∏è Verdadeiro. A Cobertura de Decis√£o exige que tanto o caminho verdadeiro quanto o falso de cada estrutura de decis√£o (ex: `if`/`else`) sejam executados, o que naturalmente cobre mais cen√°rios do que apenas garantir que cada linha foi executada uma vez. üéØ **Dica:** Pense em hierarquia: Decis√£o > Linha em termos de rigor.                                                                |
| 3  | A Cobertura de Condi√ß√£o (Condition Coverage) requer que cada condi√ß√£o booleana individual dentro de uma decis√£o seja avaliada como verdadeira e falsa pelo menos uma vez.                               | V        | ‚úîÔ∏è Verdadeiro. Exatamente! Se uma decis√£o √© `if (A && B)`, a cobertura de condi√ß√£o quer ver `A` como V, `A` como F, `B` como V e `B` como F, independentemente do resultado da decis√£o completa. üí° **Dica:** Condi√ß√£o foca nas "pe√ßas" booleanas, Decis√£o foca no resultado do "quebra-cabe√ßa" montado.                                                                                              |
| 4  | Atingir `100%` de Cobertura de Caminho (Path Coverage) √© uma meta facilmente alcan√ß√°vel para a maioria dos sistemas de software complexos.                                                                   | F        | ‚ùå Falso. A Cobertura de Caminho √© o tipo mais completo, mas tamb√©m o mais dif√≠cil e, muitas vezes, impratic√°vel de alcan√ßar `100%` em sistemas complexos devido ao crescimento exponencial do n√∫mero de caminhos poss√≠veis (loops, decis√µes aninhadas). ‚ö†Ô∏è **Dica:** A banca pode tentar te convencer do contr√°rio. Caminho completo √© ideal, mas raramente pr√°tico.                               |
| 5  | Ferramentas de cobertura de c√≥digo s√£o exclusivamente utilizadas em testes de caixa-branca, pois requerem acesso ao c√≥digo-fonte.                                                                         | V        | ‚úîÔ∏è Verdadeiro. A medi√ß√£o da cobertura de c√≥digo intrinsecamente requer instrumenta√ß√£o ou an√°lise do c√≥digo-fonte para determinar quais partes foram executadas. Isso √© caracter√≠stico de testes de caixa-branca. üéØ **Dica:** Cobertura de c√≥digo = Olhar por dentro = Caixa-Branca.                                                                                                                  |
| 6  | Cobertura de M√∫ltiplas Condi√ß√µes (Multiple Condition Coverage - MCDC) exige que todas as combina√ß√µes poss√≠veis de valores de verdade das condi√ß√µes at√¥micas em uma decis√£o sejam testadas.             | V        | ‚úîÔ∏è Verdadeiro. MCDC √© muito rigorosa. Para `if (A && B)`, MCDC testaria (V,V), (V,F), (F,V), (F,F). √â mais forte que a cobertura de condi√ß√£o simples. Ëà™Á©∫ **Dica:** MCDC √© um padr√£o comum em sistemas cr√≠ticos, como avi√¥nicos (DO-178B/C).                                                                                                                                       |
| 7  | Um benef√≠cio da cobertura de c√≥digo √© a identifica√ß√£o de "c√≥digo morto" (dead code), que s√£o se√ß√µes do c√≥digo nunca executadas pelos testes.                                                              | V        | ‚úîÔ∏è Verdadeiro. Se ap√≥s uma su√≠te de testes abrangente certas linhas ou blocos de c√≥digo n√£o s√£o cobertos, isso pode indicar c√≥digo que n√£o √© mais utilizado ou alcan√ß√°vel, conhecido como "c√≥digo morto". üßπ **Dica:** Cobertura ajuda na "faxina" do c√≥digo.                                                                                                                                     |
| 8  | A cobertura de c√≥digo, por si s√≥, avalia a corretude l√≥gica dos testes ou se as asser√ß√µes (asserts) est√£o verificando os resultados esperados adequadamente.                                                | F        | ‚ùå Falso. A cobertura de c√≥digo apenas informa *quais* partes do c√≥digo foram executadas, mas n√£o *como* foram testadas ou se os testes realmente validam o comportamento correto. Um teste pode executar uma linha sem verificar seu resultado. üïµÔ∏è **Dica:** Cobertura diz "o que foi tocado", n√£o "se foi bem tocado".                                                                       |
| 9  | Em pipelines de CI/CD, a an√°lise de cobertura de c√≥digo pode ser utilizada para falhar um build caso um limiar m√≠nimo de cobertura n√£o seja atingido.                                                       | V        | ‚úîÔ∏è Verdadeiro. √â uma pr√°tica comum configurar um "quality gate" no pipeline de CI/CD. Se a cobertura de c√≥digo de um novo commit ou pull request cair abaixo de um percentual definido (ex: `80%`), o build pode ser automaticamente reprovado. üõ°Ô∏è **Dica:** Cobertura como guardi√£ da qualidade no CI/CD.                                                                             |
| 10 | A Cobertura de Fun√ß√µes (Function Coverage) mede a porcentagem de fun√ß√µes ou m√©todos que foram invocados durante a execu√ß√£o dos testes.                                                                      | V        | ‚úîÔ∏è Verdadeiro. Este √© um n√≠vel b√°sico de cobertura que verifica se cada fun√ß√£o/m√©todo no c√≥digo foi chamado ao menos uma vez. √â √∫til, mas menos detalhado que cobertura de linhas ou decis√£o. üìû **Dica:** Simplesmente verifica se "algu√©m ligou" para a fun√ß√£o.                                                                                                                                 |
| 11 | Cobertura de Decis√£o (Branch Coverage) sempre garante `100%` de Cobertura de Linhas (Statement Coverage).                                                                                                     | V        | ‚úîÔ∏è Verdadeiro. Para cobrir todas as decis√µes (branches), todas as linhas que comp√µem essas decis√µes e seus blocos associados devem ser executadas. Portanto, `100%` de cobertura de decis√£o implica `100%` de cobertura de linhas. üìà **Dica:** Pense na rela√ß√£o de implica√ß√£o: Decis√£o ‚Üí Linha.                                                                                               |
| 12 | A Cobertura de Linhas (Statement Coverage) sempre garante `100%` de Cobertura de Decis√£o (Branch Coverage).                                                                                                   | F        | ‚ùå Falso. √â poss√≠vel executar todas as linhas de um bloco `if` sem nunca testar o bloco `else` (ou o caso em que a condi√ß√£o do `if` √© falsa). Assim, `100%` de cobertura de linhas n√£o garante `100%` de cobertura de decis√£o. ‚ö†Ô∏è **Dica:** O inverso da afirma√ß√£o anterior! A banca adora essas invers√µes. Linha ‚Üõ Decis√£o.                                                              |
| 13 | O principal objetivo da cobertura de c√≥digo √© encontrar o m√°ximo de bugs poss√≠vel no software.                                                                                                              | F        | ‚ùå Falso. O principal objetivo √© identificar partes do c√≥digo que *n√£o foram testadas*. Indiretamente, isso pode levar √† descoberta de bugs ao criar novos testes para essas √°reas, mas a cobertura em si n√£o √© uma t√©cnica de ca√ßa-bugs. üó∫Ô∏è **Dica:** Cobertura √© um mapa de √°reas n√£o exploradas, n√£o um detector de tesouros (bugs) por si s√≥.                                       |
| 14 | Em um teste com `if (idade > 18 && temCNH)`, a cobertura de condi√ß√£o seria satisfeita se test√°ssemos `idade=20, temCNH=true` e `idade=17, temCNH=false`.                                                      | F        | ‚ùå Falso. Cobertura de condi√ß√£o exige que cada condi√ß√£o individual (`idade > 18` e `temCNH`) seja V e F. Os casos dados cobrem (V,V) e (F,F) para as condi√ß√µes, mas n√£o (V,F) ou (F,V). Faltaria, por ex., `idade=20, temCNH=false` ou `idade=17, temCNH=true`. üß© **Dica:** Conte quantas condi√ß√µes at√¥micas existem e verifique se cada uma foi V e F.                              |
| 15 | A cobertura de c√≥digo √© mais √∫til em testes de sistema do que em testes de unidade, pois os testes de sistema exercitam uma maior por√ß√£o do c√≥digo.                                                        | F        | ‚ùå Falso. Embora testes de sistema possam exercitar mais c√≥digo, a cobertura √© *particularmente* √∫til em testes de unidade para garantir que os menores componentes est√£o bem testados e para dar feedback r√°pido aos desenvolvedores. Ela √© √∫til em v√°rios n√≠veis, mas sua aplica√ß√£o em unidade √© crucial. üî¨ **Dica:** Cobertura em unidade √© fundamental para a base da pir√¢mide de testes. |
| 16 | Utilizar mocks e stubs em testes de unidade pode artificialmente inflar as m√©tricas de cobertura de c√≥digo, sem necessariamente testar a l√≥gica de neg√≥cio real da unidade sob teste.                        | V        | ‚úîÔ∏è Verdadeiro. Se depend√™ncias s√£o mockadas extensivamente e o mock simplesmente retorna um valor sem executar l√≥gica complexa, as linhas da unidade que chamam o mock ser√£o cobertas, mas a intera√ß√£o real e complexa pode n√£o ser. üéØ **Dica:** Mocks s√£o √∫teis, mas cuidado com o "excesso de confian√ßa" que eles podem gerar na cobertura.                                                         |
| 17 | A escolha do n√≠vel de cobertura de c√≥digo a ser buscado (ex: linha, decis√£o, MCDC) deve ser a mesma para todas as partes de um sistema, independentemente da criticidade do m√≥dulo.                       | F        | ‚ùå Falso. M√≥dulos cr√≠ticos (ex: transa√ß√µes financeiras, controle de voo) geralmente exigem n√≠veis de cobertura mais altos e rigorosos (como MCDC), enquanto m√≥dulos menos cr√≠ticos podem ter metas de cobertura mais baixas. ‚öñÔ∏è **Dica:** Criticidade dita o rigor da cobertura. Abordagem "tamanho √∫nico" n√£o serve.                                                                        |
| 18 | A an√°lise de cobertura de c√≥digo n√£o fornece informa√ß√µes sobre a performance dos testes ou do c√≥digo executado.                                                                                               | V        | ‚úîÔ∏è Verdadeiro. Ferramentas de cobertura focam em quais partes do c√≥digo foram executadas. Para an√°lise de performance, s√£o necess√°rias outras ferramentas, como profilers. ‚è±Ô∏è **Dica:** Cobertura ‚â† Profiling. Cada ferramenta tem seu prop√≥sito.                                                                                                                                               |
| 19 | Em testes de software, "cobertura de requisitos" e "cobertura de c√≥digo" s√£o termos intercambi√°veis que medem a mesma coisa.                                                                                 | F        | ‚ùå Falso. Cobertura de requisitos verifica se todos os requisitos funcionais e n√£o funcionais foram contemplados por casos de teste. Cobertura de c√≥digo verifica quanto do c√≥digo-fonte foi executado. S√£o m√©tricas complementares, n√£o intercambi√°veis. üìÑ vs üíª **Dica:** Requisito = "O qu√™?"; C√≥digo = "Como?".                                                                            |
| 20 | Se um trecho de c√≥digo possui `100%` de cobertura de decis√£o, ent√£o todas as poss√≠veis combina√ß√µes de entradas para esse trecho foram testadas.                                                                 | F        | ‚ùå Falso. Cobertura de decis√£o garante que todos os ramos (true/false) de uma decis√£o foram tomados, mas n√£o que todas as combina√ß√µes de *valores de entrada* que levam a esses ramos foram testadas. Ex: `if (x > 0)` pode ser V para `x=1` ou `x=1000`. üî¢ **Dica:** Cobertura de decis√£o foca nos caminhos l√≥gicos, n√£o na variedade de dados de entrada.                                 |
| 21 | Para o comando `mvn test jacoco:report`, o `jacoco:report` √© um goal do plugin JaCoCo para gerar relat√≥rios de cobertura ap√≥s a execu√ß√£o dos testes.                                                      | V        | ‚úîÔ∏è Verdadeiro. No Maven, `mvn test` executa os testes, e se o plugin JaCoCo estiver configurado para instrumentar (ex: com `prepare-agent`), o goal `jacoco:report` pode ent√£o ser usado para gerar o relat√≥rio HTML/XML/CSV da cobertura. üìä **Dica:** `prepare-agent` (instrumenta) -> `test` (executa) -> `report` (gera relat√≥rio).                                                |
| 22 | A m√©trica de cobertura de c√≥digo √© principalmente qualitativa, focando na experi√™ncia do testador ao executar o c√≥digo.                                                                                      | F        | ‚ùå Falso. A cobertura de c√≥digo √© uma m√©trica *quantitativa* (expressa em porcentagem) que mede a extens√£o da execu√ß√£o do c√≥digo. A qualidade da experi√™ncia do testador ou a qualidade dos testes em si s√£o aspectos qualitativos distintos. üíØ **Dica:** Cobertura = N√∫mero. Qualidade do teste = Julgamento.                                                                        |
| 23 | A cobertura de condi√ß√£o modificada/decis√£o (MC/DC) √© um crit√©rio menos rigoroso que a cobertura de decis√£o simples.                                                                                            | F        | ‚ùå Falso. MC/DC (Modified Condition/Decision Coverage) √© *mais* rigorosa. Ela exige que cada condi√ß√£o dentro de uma decis√£o seja mostrada como capaz de afetar independentemente o resultado da decis√£o. üî¨ **Dica:** MC/DC √© um "superconjunto" de rigor em rela√ß√£o √† decis√£o e condi√ß√£o.                                                                                             |
| 24 | Ferramentas como o SonarQube podem integrar dados de cobertura de c√≥digo (ex: do JaCoCo) para fornecer uma vis√£o da qualidade do c√≥digo, incluindo √°reas n√£o testadas.                                        | V        | ‚úîÔ∏è Verdadeiro. SonarQube √© uma plataforma de inspe√ß√£o cont√≠nua de qualidade de c√≥digo que frequentemente integra relat√≥rios de cobertura de ferramentas como JaCoCo, Istanbul, etc., para exibir essas m√©tricas junto com outras (bugs, vulnerabilidades, code smells). üìà **Dica:** SonarQube centraliza v√°rias m√©tricas, incluindo cobertura.                                               |
| 25 | A cobertura de c√≥digo √© uma t√©cnica de teste est√°tico, pois analisa o c√≥digo-fonte sem execut√°-lo.                                                                                                          | F        | ‚ùå Falso. A cobertura de c√≥digo √© uma t√©cnica de teste *din√¢mico*. Ela mede quais partes do c√≥digo s√£o executadas *durante* a execu√ß√£o dos testes. An√°lise est√°tica ocorre sem execu√ß√£o. üèÉ‚Äç‚ôÇÔ∏è **Dica:** Cobertura requer execu√ß√£o. Est√°tico = sem rodar. Din√¢mico = rodando.                                                                                                                    |
| 26 | Ao refatorar c√≥digo, manter ou aumentar a cobertura de c√≥digo existente ajuda a garantir que a refatora√ß√£o n√£o introduziu regress√µes ou quebrou funcionalidades.                                               | V        | ‚úîÔ∏è Verdadeiro. Se os testes existentes cobrem bem o c√≥digo e passam antes da refatora√ß√£o, rod√°-los novamente ap√≥s a refatora√ß√£o e verificar a cobertura (e se os testes ainda passam) d√° confian√ßa de que a funcionalidade foi preservada. ‚ú® **Dica:** Cobertura √© uma rede de seguran√ßa para refatora√ß√£o.                                                                                |
| 27 | A cobertura de linhas √© suficiente para testar completamente todas as l√≥gicas de um la√ßo `while` ou `for`.                                                                                                   | F        | ‚ùå Falso. Cobrir as linhas dentro de um la√ßo n√£o garante que o la√ßo foi testado para 0 itera√ß√µes, 1 itera√ß√£o e N itera√ß√µes, ou que as condi√ß√µes de termina√ß√£o foram devidamente testadas. Cobertura de decis√£o/caminho seria mais apropriada. üîÑ **Dica:** Loops t√™m comportamentos complexos que a simples cobertura de linha n√£o captura totalmente.                                 |
| 28 | O arquivo `index.html` gerado pelo JaCoCo tipicamente cont√©m um resumo da cobertura de c√≥digo para todo o projeto, com links para detalhes por pacote e classe.                                              | V        | ‚úîÔ∏è Verdadeiro. O relat√≥rio HTML padr√£o do JaCoCo fornece uma vis√£o geral no `index.html` e permite navegar para ver a cobertura detalhada, linha por linha, para cada classe, destacando linhas cobertas, n√£o cobertas e branches. üó∫Ô∏è **Dica:** `index.html` √© o port√£o de entrada para o relat√≥rio de cobertura.                                                                           |
| 29 | √â imposs√≠vel ter `100%` de cobertura de decis√£o e menos de `100%` de cobertura de condi√ß√£o em um c√≥digo com decis√µes compostas (ex: `if (A || B)`).                                                              | F        | ‚ùå Falso. Para `if (A || B)`, se A √© sempre verdadeiro nos testes, a decis√£o ser√° sempre verdadeira. O ramo falso da decis√£o pode n√£o ser coberto, e B pode nunca ser avaliado como falso. √â poss√≠vel ter `100%` de cobertura de decis√£o (se ambos os ramos da decis√£o principal s√£o cobertos) e n√£o ter `100%` de condi√ß√£o (se A ou B n√£o foram V e F). *Corre√ß√£o*: A pergunta √© mais sutil. Se `if (A || B)` tem `100%` de cobertura de decis√£o (caminho V e F cobertos), mas `A` sempre √© `true` nos testes que levam ao caminho `true` da decis√£o, `B` pode n√£o ser avaliado como `false` nesses casos. √â poss√≠vel.  *Revis√£o:* Para cobrir o ramo FALSO de `if (A || B)`, tanto `A` quanto `B` devem ser falsos. Para cobrir o ramo VERDADEIRO, basta que `A` seja verdadeiro (B n√£o √© avaliado) OU `B` seja verdadeiro (se A for falso).  Se testamos `A=V` (B n√£o importa) e `A=F, B=F`. Isso cobre os ramos. Mas a condi√ß√£o `B` pode n√£o ter sido avaliada como `V` (se `A` sempre for `V` no primeiro caso). Sim, √© poss√≠vel. üß† **Dica:** Decis√µes compostas s√£o complexas. MC/DC ajuda aqui. |
| 30 | A cobertura de c√≥digo √© uma m√©trica √∫til apenas para desenvolvedores e n√£o tem relev√¢ncia para gerentes de projeto ou stakeholders.                                                                          | F        | ‚ùå Falso. Gerentes de projeto e stakeholders podem usar a cobertura de c√≥digo como um indicador (entre outros) do risco e da qualidade do software. Baixa cobertura pode indicar √°reas de alto risco que precisam de mais aten√ß√£o. üìä **Dica:** Cobertura pode ser um KPI de qualidade, mas precisa ser contextualizado.                                                                       |
| 31 | Um c√≥digo que utiliza extensivemente tratamento de exce√ß√µes (`try-catch-finally`) pode ter alta cobertura de linhas mesmo que os blocos `catch` ou `finally` nunca sejam executados pelos testes.          | F        | ‚ùå Falso. Se os blocos `catch` ou `finally` n√£o forem executados, as linhas dentro deles n√£o ser√£o cobertas, reduzindo a cobertura de linhas. Para cobrir esses blocos, os testes precisam simular as condi√ß√µes de erro. üí£ **Dica:** Testar cen√°rios de exce√ß√£o √© crucial para cobrir blocos `catch` e `finally`.                                                                          |
| 32 | A cobertura de c√≥digo √© uma t√©cnica primariamente focada em encontrar falhas de seguran√ßa no software.                                                                                                     | F        | ‚ùå Falso. O foco principal da cobertura de c√≥digo √© identificar c√≥digo n√£o testado. Embora testes que cobrem mais c√≥digo possam, incidentalmente, revelar vulnerabilidades, n√£o √© seu objetivo prim√°rio. Testes de seguran√ßa espec√≠ficos s√£o necess√°rios para isso. üõ°Ô∏è **Dica:** Cobertura ajuda na qualidade geral, mas seguran√ßa requer testes especializados.                                  |
| 33 | Para um simples m√©todo `public int soma(int a, int b) { return a + b; }`, um √∫nico teste como `soma(1,1)` alcan√ßaria `100%` de cobertura de linhas, decis√£o e condi√ß√£o.                                            | V        | ‚úîÔ∏è Verdadeiro. Este m√©todo n√£o possui decis√µes (`if`, `switch`) nem condi√ß√µes booleanas complexas. A √∫nica linha execut√°vel √© `return a + b;`. Portanto, um √∫nico teste que execute esta linha cobrir√° `100%` de todos esses n√≠veis (trivialmente para decis√£o e condi√ß√£o). ‚úÖ **Dica:** Para c√≥digo linear simples, cobertura √© f√°cil.                                                       |
| 34 | Aumentar o n√∫mero de testes unit√°rios automaticamente leva a uma melhoria na qualidade do software, independentemente da cobertura de c√≥digo alcan√ßada.                                                       | F        | ‚ùå Falso. Aumentar o n√∫mero de testes n√£o garante melhor qualidade. Testes podem ser redundantes, mal escritos ou n√£o cobrir √°reas cr√≠ticas. Cobertura ajuda a direcionar os esfor√ßos de teste para √°reas importantes. üéØ **Dica:** Qualidade sobre quantidade. Cobertura ajuda a focar na qualidade.                                                                                      |
| 35 | A configura√ß√£o `<exclude>com/example/dto/**</exclude>` em um plugin JaCoCo Maven instrui o plugin a *incluir* apenas classes do pacote `com.example.dto` na an√°lise de cobertura.                             | F        | ‚ùå Falso. A tag `<exclude>` em configura√ß√µes de plugins como JaCoCo serve para *excluir* os padr√µes especificados da an√°lise. Neste caso, classes no pacote `com.example.dto` e seus subpacotes seriam ignoradas. üö´ **Dica:** `exclude` = tirar fora; `include` (se existisse ou fosse o padr√£o) = colocar dentro.                                                                                |
| 36 | Cobertura de c√≥digo √© uma pr√°tica √°gil que se encaixa bem em metodologias como Scrum, pois fornece feedback r√°pido sobre a completude dos testes.                                                              | V        | ‚úîÔ∏è Verdadeiro. Em ciclos curtos de desenvolvimento (sprints), ter feedback r√°pido sobre quais partes do novo c√≥digo foram testadas √© valioso. A integra√ß√£o com CI/CD e a automa√ß√£o de relat√≥rios de cobertura apoiam essa agilidade. üèÉ‚Äç‚ôÄÔ∏è **Dica:** Feedback r√°pido √© chave no √Ågil, e cobertura contribui para isso.                                                                       |
| 37 | A presen√ßa de c√≥digo comentado (`// comentario` ou `/* comentario */`) afeta diretamente o c√°lculo da porcentagem de cobertura de c√≥digo, pois s√£o considerados linhas n√£o execut√°veis.                         | F        | ‚ùå Falso. Ferramentas de cobertura de c√≥digo geralmente ignoram coment√°rios e linhas em branco ao calcular a cobertura. Elas focam em linhas de c√≥digo execut√°vel. üí¨ **Dica:** Coment√°rios s√£o para humanos, cobertura √© para c√≥digo execut√°vel.                                                                                                                                      |
| 38 | Se um teste falha (lan√ßa uma asser√ß√£o que n√£o passa), as linhas de c√≥digo executadas at√© o ponto da falha ainda s√£o contabilizadas para a cobertura de c√≥digo.                                                  | V        | ‚úîÔ∏è Verdadeiro. A instrumenta√ß√£o de cobertura geralmente registra a execu√ß√£o das linhas independentemente do resultado do teste. A falha do teste √© um evento separado. üë£ **Dica:** Cobertura rastreia os "passos" da execu√ß√£o, mesmo que o "destino" (asser√ß√£o) n√£o seja o esperado.                                                                                                       |
| 39 | A m√©trica "complexidade ciclom√°tica" est√° diretamente relacionada √† facilidade de se atingir `100%` de cobertura de decis√£o. Quanto maior a complexidade, mais f√°cil a cobertura.                               | F        | ‚ùå Falso. Complexidade ciclom√°tica mede o n√∫mero de caminhos linearmente independentes. Quanto *maior* a complexidade, *mais* decis√µes e caminhos existem, tornando *mais dif√≠cil* atingir `100%` de cobertura de decis√£o ou caminho. üìà vs üìâ **Dica:** Mais complexo = Mais para testar = Mais dif√≠cil cobrir tudo.                                                                      |
| 40 | √â uma boa pr√°tica focar em `100%` de cobertura de c√≥digo para todas as classes de utilit√°rios e DTOs (Data Transfer Objects) em um projeto.                                                                     | F        | ‚ùå Falso. Embora testar utilit√°rios seja bom, DTOs (geralmente simples getters/setters) podem n√£o agregar muito valor com `100%` de cobertura se gerados automaticamente ou triviais. O esfor√ßo pode ser melhor empregado em l√≥gica de neg√≥cio complexa. ‚öñÔ∏è **Dica:** Priorize o esfor√ßo de cobertura onde o risco e a complexidade s√£o maiores.                                                  |
| 41 | A cobertura de c√≥digo n√£o pode ser medida para linguagens dinamicamente tipadas como Python ou JavaScript.                                                                                                  | F        | ‚ùå Falso. Existem diversas ferramentas de cobertura de c√≥digo para linguagens din√¢micas, como `coverage.py` para Python e Istanbul (ou `nyc`) para JavaScript. üêçüìú **Dica:** Quase toda linguagem popular tem ferramentas de cobertura.                                                                                                                                               |
| 42 | O uso de `git bisect` pode ser combinado com an√°lises de cobertura de c√≥digo para identificar commits que introduziram quedas significativas na cobertura.                                                     | V        | ‚úîÔ∏è Verdadeiro. Embora `git bisect` seja mais usado para encontrar commits que introduziram bugs, se a execu√ß√£o de testes e a gera√ß√£o de relat√≥rios de cobertura forem automatizadas, `git bisect` poderia, em tese, ser adaptado para encontrar um commit que causou uma queda na cobertura. üéØ **Dica:** `git bisect` √© uma ferramenta poderosa de busca bin√°ria em commits.                    |
| 43 | Em um switch-case, a cobertura de decis√£o exige que cada `case`, incluindo o `default` (se houver), seja executado.                                                                                             | V        | ‚úîÔ∏è Verdadeiro. Cada `case` e o `default` representam diferentes "ramos" ou "decis√µes" que o fluxo de execu√ß√£o pode tomar. Cobri-los todos satisfaz a cobertura de decis√£o para a estrutura `switch`. üîÄ **Dica:** `switch-case` √© uma forma de decis√£o m√∫ltipla.                                                                                                                                |
| 44 | A cobertura de c√≥digo √© uma m√©trica que apenas pode ser aplicada em software novo (greenfield) e n√£o em sistemas legados.                                                                                     | F        | ‚ùå Falso. A cobertura de c√≥digo pode ser muito √∫til em sistemas legados, especialmente ao refatorar ou adicionar novos recursos, para entender quais partes s√£o testadas e para construir uma rede de seguran√ßa de testes. üèõÔ∏è **Dica:** Em legado, cobertura ajuda a iluminar √°reas "escuras" e a reduzir riscos de mudan√ßa.                                                              |
| 45 | Se um m√©todo privado n√£o √© chamado por nenhum m√©todo p√∫blico testado, ele n√£o contribuir√° para a cobertura de c√≥digo, aparecendo como n√£o coberto.                                                              | V        | ‚úîÔ∏è Verdadeiro. Se os testes (geralmente de m√©todos p√∫blicos) n√£o invocam, direta ou indiretamente, um m√©todo privado, este n√£o ser√° executado e, portanto, n√£o ser√° coberto. üîí **Dica:** M√©todos privados s√£o testados atrav√©s da interface p√∫blica da classe. Se n√£o s√£o usados, podem ser c√≥digo morto.                                                                             |
| 46 | A ferramenta `gcov` √© comumente utilizada para an√°lise de cobertura de c√≥digo em projetos Java.                                                                                                                 | F        | ‚ùå Falso. `gcov` √© uma ferramenta de cobertura para C/C++. Para Java, ferramentas comuns s√£o JaCoCo, Cobertura (mais antiga), OpenClover. ‚òï vs C **Dica:** Cada ecossistema de linguagem tem suas ferramentas preferidas.                                                                                                                                                           |
| 47 | A cobertura de c√≥digo √© uma forma de teste de regress√£o.                                                                                                                                                        | F        | ‚ùå Falso. Cobertura de c√≥digo √© uma *m√©trica* usada para avaliar a abrang√™ncia dos testes. Teste de regress√£o √© um *tipo* de teste que visa garantir que mudan√ßas recentes n√£o quebraram funcionalidades existentes. Cobertura pode *apoiar* testes de regress√£o, mas n√£o √© um deles. üîÑ **Dica:** M√©trica vs Tipo de Teste.                                                                    |
| 48 | A configura√ß√£o do plugin JaCoCo no `pom.xml` com o goal `prepare-agent` √© respons√°vel por instrumentar as classes Java durante a fase de compila√ß√£o ou antes da execu√ß√£o dos testes.                             | V        | ‚úîÔ∏è Verdadeiro. O `prepare-agent` do JaCoCo configura um agente Java que instrumenta as classes em tempo de execu√ß√£o (quando carregadas pela JVM) ou, em alguns cen√°rios, offline. Isso permite coletar dados de execu√ß√£o. üïµÔ∏è‚Äç‚ôÇÔ∏è **Dica:** `prepare-agent` "prepara o terreno" para a coleta de dados de cobertura.                                                                      |
| 49 | A cobertura de c√≥digo de `0%` para um m√≥dulo rec√©m-desenvolvido indica que nenhum teste foi escrito ou executado para esse m√≥dulo.                                                                               | V        | ‚úîÔ∏è Verdadeiro. Se a cobertura √© `0%`, significa que nenhuma linha execut√°vel do c√≥digo do m√≥dulo foi exercitada pelos testes. Isso geralmente implica que n√£o h√° testes ou os testes existentes n√£o alcan√ßam esse c√≥digo. ÌÖÖ **Dica:** `0%` √© um grande alerta!                                                                                                                               |
| 50 | Aumentar a cobertura de c√≥digo em um projeto sempre resulta em um aumento proporcional no tempo de execu√ß√£o da su√≠te de testes.                                                                                | F        | ‚ùå Falso. Embora adicionar mais testes para aumentar a cobertura possa aumentar o tempo de execu√ß√£o, n√£o √© sempre proporcional. Testes podem ser otimizados, ou a cobertura pode ser aumentada refatorando testes existentes para serem mais eficientes ou cobrirem mais cen√°rios. ‚è≥ **Dica:** Otimiza√ß√£o de testes √© importante. Nem sempre mais cobertura = muito mais tempo.        |
| 51  | Imagine que voc√™ est√° explicando para um colega: "Cobertura de c√≥digo nos diz EXATAMENTE quais bugs nossos testes encontraram." Esta afirma√ß√£o est√° correta?                                                                                                                                 | F        | ‚ùå Falso. Pense assim: a cobertura de c√≥digo √© como um mapa que mostra quais estradas (linhas de c√≥digo) seu carro (testes) percorreu. Ele n√£o diz se voc√™ dirigiu bem, se o carro estava em boas condi√ß√µes, ou se voc√™ notou todos os buracos (bugs) na estrada. Ele apenas diz "voc√™ passou por aqui". üéØ **Dica:** Cobertura mostra *onde* se testou, n√£o *qu√£o bem* ou *o que* se encontrou.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 52  | Ao ensinar sobre Cobertura de Linhas, voc√™ diria: "Se `100%` das linhas foram executadas, significa que cada poss√≠vel entrada para cada fun√ß√£o foi testada." Isso seria uma explica√ß√£o precisa?                                                                                              | F        | ‚ùå Falso. Executar uma linha como `resultado = a + b;` uma vez (ex: `a=1, b=1`) cobre a linha. Mas isso n√£o testa `a=0, b=0` ou `a=-5, b=10`, etc. A cobertura de linha √© o mais b√°sico, apenas verifica se a linha foi "tocada". üî¢ **Dica:** Linha tocada ‚â† todas as possibilidades de dados testadas. √â uma armadilha comum da banca!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 53  | Se voc√™ quer garantir que ambos os resultados de um `if (condicao)` e seu `else` foram testados, a Cobertura de Decis√£o (Branch Coverage) √© a m√©trica apropriada a ser buscada.                                                                                                              | V        | ‚úîÔ∏è Verdadeiro. Exato! A Cobertura de Decis√£o √© como verificar se voc√™ testou o caminho "SIM" (condi√ß√£o verdadeira) e o caminho "N√ÉO" (condi√ß√£o falsa) de uma bifurca√ß√£o na estrada. üõ£Ô∏è **Dica:** Decis√£o = Bifurca√ß√£o (if/else, switch). Precisa testar os dois (ou mais) lados.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 54  | Voc√™ explica: "A Cobertura de Condi√ß√£o foca em cada pequena parte de uma decis√£o complexa. Por exemplo, em `if (A && B)`, ela quer ver `A` ser V e F, e `B` ser V e F, mesmo que isso n√£o mude o resultado final da decis√£o em todos os casos."                                              | V        | ‚úîÔ∏è Verdadeiro. Perfeito! √â como desmontar um rel√≥gio: a Cobertura de Condi√ß√£o olha cada engrenagemzinha (condi√ß√£o at√¥mica) individualmente para ver se ela funciona nos dois sentidos (V e F), independentemente de como o rel√≥gio inteiro (a decis√£o) se comporta. ‚öôÔ∏è **Dica:** Condi√ß√£o = "pe√ßas" da decis√£o.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 55  | "Alcan√ßar `100%` de Cobertura de Caminho (Path Coverage) √© trivial em programas com muitos loops e decis√µes aninhadas." Esta seria uma afirma√ß√£o correta para um iniciante?                                                                                                                  | F        | ‚ùå Falso. Seria o oposto! Imagine um labirinto (programa) com muitas bifurca√ß√µes (decis√µes) e c√≠rculos (loops). Tentar percorrer *todos* os caminhos poss√≠veis se torna exponencialmente dif√≠cil. Cobertura de Caminho √© a mais completa, mas tamb√©m a mais complexa de atingir.  labyrinth **Dica:** Muitos caminhos = Cobertura de Caminho dif√≠cil. A banca pode inverter essa l√≥gica.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 56  | "Cobertura de Fun√ß√£o/M√©todo apenas nos diz se uma fun√ß√£o foi chamada, n√£o quantas vezes ou com quais par√¢metros." Esta √© uma boa simplifica√ß√£o?                                                                                                                                              | V        | ‚úîÔ∏è Verdadeiro. √â uma boa forma de resumir. √â como uma lista de presen√ßa para fun√ß√µes: apenas marca "presente" se foi chamada ao menos uma vez. N√£o detalha a "qualidade da participa√ß√£o". üìû **Dica:** Fun√ß√£o/M√©todo = Chamada b√°sica.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 57  | Se um conjunto de testes alcan√ßa `100%` de Cobertura de Decis√£o, ele necessariamente tamb√©m alcan√ßou `100%` de Cobertura de Linhas.                                                                                                                                                          | V        | ‚úîÔ∏è Verdadeiro. Pense numa receita (c√≥digo). Se voc√™ seguiu todas as instru√ß√µes de "se X, fa√ßa Y, sen√£o fa√ßa Z" (decis√µes), voc√™ teve que ler e executar todas as linhas envolvidas nesses passos. üö∂‚Äç‚ôÇÔ∏è **Dica:** Decis√£o cobre Linha (D ‚Üí L). √â uma rela√ß√£o de "for√ßa": a mais forte implica a mais fraca.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 58  | Se uma su√≠te de testes alcan√ßa `100%` de Cobertura de Linhas, ela automaticamente garante `100%` de Cobertura de Decis√£o.                                                                                                                                                                    | F        | ‚ùå Falso. Imagine um `if (condicao) { faca_algo(); }`. Se `condicao` √© sempre verdadeira nos seus testes, voc√™ executa `faca_algo()` e a linha do `if`. `100%` de cobertura de linha! Mas voc√™ nunca testou o que acontece se `condicao` for falsa (o "ramo else impl√≠cito"). ‚ö†Ô∏è **Dica:** Linha N√ÉO cobre Decis√£o (L ‚Üõ D). A banca adora essa confus√£o!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 59  | "Uma alta cobertura de c√≥digo √© o objetivo final dos testes, e uma vez alcan√ßada, podemos ter certeza que o software tem alta qualidade." Isso √© o que voc√™ diria a um gerente?                                                                                                              | F        | ‚ùå Falso. Para o gerente, voc√™ diria: "Alta cobertura indica que nossos testes *exercitaram* grande parte do c√≥digo. Isso reduz o risco de termos partes completamente ignoradas. Mas a *qualidade* dos testes (se eles verificam o comportamento correto) √© igualmente crucial e n√£o √© medida pela cobertura." üßê **Dica:** Cobertura √© *um* indicador, n√£o *o √∫nico* nem *o final*.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 60  | Ferramentas como JaCoCo (para Java) ou Istanbul (para JavaScript) funcionam instrumentando o c√≥digo (adicionando "sensores") para rastrear quais partes s√£o executadas durante os testes.                                                                                                    | V        | ‚úîÔ∏è Verdadeiro. Exatamente! Essas ferramentas modificam o bytecode (Java) ou o c√≥digo fonte (JS) em tempo de compila√ß√£o ou execu√ß√£o para inserir pontos de coleta de dados. Quando os testes rodam, esses "sensores" reportam o que foi executado. üì° **Dica:** Instrumenta√ß√£o = adicionar "espi√µes" no c√≥digo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 61  | "Em um pipeline de CI/CD, se a cobertura de c√≥digo cair abaixo de `80%` ap√≥s um novo commit, podemos configurar o sistema para automaticamente impedir o merge do c√≥digo." Esta √© uma pr√°tica de qualidade comum?                                                                            | V        | ‚úîÔ∏è Verdadeiro. Sim, isso √© chamado de "quality gate" (port√£o de qualidade). Ajuda a manter um padr√£o m√≠nimo de testes e previne que c√≥digo com baixa cobertura (potencialmente arriscado) seja integrado √† base principal. üöß **Dica:** CI/CD + Cobertura = Guardi√£o da qualidade.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 62  | "Cobertura de c√≥digo nos ajuda a identificar 'c√≥digo morto' (dead code), que √© c√≥digo que existe mas nunca √© chamado por nenhuma parte do sistema que testamos." √â uma defini√ß√£o √∫til?                                                                                                       | V        | ‚úîÔ∏è Verdadeiro. Se, ap√≥s rodar uma su√≠te de testes abrangente, certas se√ß√µes do c√≥digo permanecem n√£o cobertas, elas podem ser "c√≥digo morto" ‚Äì legado, obsoleto ou simplesmente inalcan√ß√°vel. üëª **Dica:** Cobertura < `100%` pode significar c√≥digo morto ou testes insuficientes. Investigar √© preciso!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 63  | "A m√©trica de cobertura de c√≥digo, por si s√≥, nos diz se os testes est√£o verificando os resultados corretos (asser√ß√µes) ou se est√£o apenas executando o c√≥digo." Como voc√™ responderia?                                                                                                      | F        | ‚ùå Falso. A cobertura apenas diz "esta linha/decis√£o foi executada". Ela n√£o tem como saber se o `assertEquals(esperado, atual)` no seu teste est√° correto ou se o `esperado` √© o valor certo. A qualidade das asser√ß√µes √© responsabilidade do testador. üïµÔ∏è **Dica:** Cobertura √© sobre *alcance*, n√£o sobre *precis√£o da verifica√ß√£o*.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 64  | Em `if (idade > 18 && matriculado)`, a Cobertura de Condi√ß√£o exige 4 cen√°rios de teste para cobrir V/F para `idade > 18` e V/F para `matriculado`.                                                                                                                                           | V        | ‚úîÔ∏è Verdadeiro. Para cobrir todas as possibilidades de cada condi√ß√£o individual: 1) `idade > 18` (V), `matriculado` (V); 2) `idade > 18` (V), `matriculado` (F); 3) `idade > 18` (F), `matriculado` (V); 4) `idade > 18` (F), `matriculado` (F). üî¢ **Dica:** 2 condi√ß√µes = 2^2 = 4 combina√ß√µes para as condi√ß√µes individuais (n√£o confundir com MCDC ou resultado da decis√£o).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 65  | A Cobertura de M√∫ltiplas Condi√ß√µes (MCDC) √© menos rigorosa que a Cobertura de Decis√£o.                                                                                                                                                                                                       | F        | ‚ùå Falso. MCDC √© *mais* rigorosa. Ela n√£o s√≥ quer que cada condi√ß√£o seja V e F (como Cobertura de Condi√ß√£o), mas tamb√©m que cada condi√ß√£o demonstre que pode, *independentemente*, afetar o resultado da decis√£o. √â um n√≠vel avan√ßado. ‚úàÔ∏è **Dica:** MCDC √© um "peso pesado" da cobertura, comum em sistemas cr√≠ticos.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 66  | "Se um teste usa um mock para uma depend√™ncia externa, as linhas de c√≥digo da unidade sob teste que chamam esse mock s√£o consideradas cobertas, mesmo que a l√≥gica real da depend√™ncia n√£o seja executada." Explica√ß√£o correta?                                                              | V        | ‚úîÔ∏è Verdadeiro. Sim. O teste est√° focando na unidade em si. A chamada ao mock √© feita, ent√£o a linha √© coberta. O mock simula a depend√™ncia. Se o mock for muito simples, a *qualidade* do teste pode ser questionada, mas a *cobertura da linha de chamada* ocorre. üé≠ **Dica:** Mocks ajudam a isolar, mas podem "mascarar" a complexidade real da integra√ß√£o se n√£o usados com cuidado.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 67  | "Para um sistema de controle de tr√°fego a√©reo, a meta de cobertura de c√≥digo para os m√≥dulos cr√≠ticos deve ser a mesma que para o m√≥dulo de interface de login do operador." Voc√™ concorda?                                                                                                  | F        | ‚ùå Falso. M√≥dulos cr√≠ticos que afetam seguran√ßa (como controle de tr√°fego a√©reo) exigem n√≠veis de cobertura muito mais altos e rigorosos (ex: MCDC) do que m√≥dulos menos cr√≠ticos (como uma tela de login, onde cobertura de decis√£o ou linha pode ser suficiente). ‚öñÔ∏è **Dica:** Criticidade guia o n√≠vel de rigor da cobertura. N√£o h√° "tamanho √∫nico".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 68  | "A cobertura de c√≥digo me d√° informa√ß√µes sobre gargalos de performance no meu c√≥digo." Esta afirma√ß√£o √© precisa?                                                                                                                                                                             | F        | ‚ùå Falso. Cobertura de c√≥digo foca em *quais* partes do c√≥digo foram executadas. Para identificar gargalos de performance (quais partes s√£o lentas ou consomem muitos recursos), voc√™ precisa de ferramentas de *profiling*. ‚è±Ô∏è **Dica:** Cobertura = "O qu√™ foi executado?". Profiling = "Como foi executado em termos de tempo/recursos?".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 69  | "Cobertura de Requisitos me diz se todos os meus casos de uso foram testados, enquanto Cobertura de C√≥digo me diz quanto do meu c√≥digo-fonte foi ativado por esses testes." Essa √© uma boa distin√ß√£o?                                                                                        | V        | ‚úîÔ∏è Verdadeiro. Perfeita distin√ß√£o! Cobertura de Requisitos: conecta testes ao "o qu√™" o sistema deve fazer (especifica√ß√µes). Cobertura de C√≥digo: conecta testes ao "como" o sistema faz (implementa√ß√£o). S√£o complementares. üìú‚ÜîÔ∏èüíª **Dica:** Uma mapeia para o problema, a outra para a solu√ß√£o.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 70  | "Se um trecho de c√≥digo tem `100%` de cobertura de decis√£o, isso prova que n√£o h√° bugs l√≥gicos nesse trecho." Voc√™ confirmaria isso?                                                                                                                                                         | F        | ‚ùå Falso. `100%` de cobertura de decis√£o significa que todos os caminhos l√≥gicos (ramos) foram tomados. Mas o teste que tomou um caminho pode ter uma asser√ß√£o errada, ou a l√≥gica dentro do caminho pode estar incorreta, mesmo sendo executada. Ex: `if (x > 5) return x*2; else return x*3;`. Cobrir ambos n√£o pega se deveria ser `x+2` e `x+3`. üêû **Dica:** Cobertura n√£o valida a l√≥gica *interna* do bloco, apenas que o bloco foi acessado.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 71  | O goal `jacoco:prepare-agent` do plugin JaCoCo no Maven √© tipicamente executado *ap√≥s* o goal `test` para que os dados de cobertura possam ser coletados.                                                                                                                                    | F        | ‚ùå Falso. O `jacoco:prepare-agent` precisa ser executado *antes* dos testes. Ele configura o agente Java que instrumenta as classes conforme elas s√£o carregadas pela JVM *durante* a execu√ß√£o dos testes. Sem o agente preparado, n√£o h√° coleta de dados. È†ÜÁï™ **Dica:** Pense na sequ√™ncia: 1. Preparar para observar (prepare-agent) 2. Observar (test) 3. Gerar relat√≥rio do observado (report).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 72  | "Cobertura de c√≥digo √© uma m√©trica puramente quantitativa (ex: `75%`) e n√£o oferece insights qualitativos sobre os testes." Como voc√™ refina essa afirma√ß√£o?                                                                                                                                 | F        | ‚ùå Falso, ou pelo menos incompleto. Embora a m√©trica principal seja quantitativa, a *an√°lise* do relat√≥rio de cobertura oferece insights qualitativos. Por exemplo, ver que um bloco `catch` complexo n√£o foi coberto sugere qualitativamente que os cen√°rios de erro n√£o foram testados. üßê **Dica:** O n√∫mero √© quantitativo, a interpreta√ß√£o e as a√ß√µes derivadas s√£o qualitativas.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 73  | Para um sistema que lida com transa√ß√µes financeiras de alto valor, atingir apenas `80%` de Cobertura de Linhas nos m√≥dulos de processamento de pagamento seria considerado aceit√°vel por um auditor de TI experiente.                                                                        | F        | ‚ùå Falso. Um auditor de TI experiente, especialmente para Perito da PF, consideraria `80%` de Cobertura de Linhas insuficiente para m√≥dulos financeiros cr√≠ticos. Esperar-se-ia uma cobertura muito mais alta (pr√≥xima de `100%`) e de tipos mais rigorosos (Decis√£o, Condi√ß√£o ou MCDC). üí∞üõ°Ô∏è **Dica PF:** Em √°reas sens√≠veis (financeiro, seguran√ßa, sa√∫de), o rigor com testes e cobertura √© m√°ximo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 74  | A t√©cnica de "muta√ß√£o de testes" pode ser usada para avaliar a qualidade de uma su√≠te de testes, e os resultados podem complementar a an√°lise de cobertura de c√≥digo.                                                                                                                        | V        | ‚úîÔ∏è Verdadeiro. Testes de muta√ß√£o alteram sutilmente o c√≥digo-fonte (criam "mutantes") e verificam se os testes existentes "matam" esses mutantes (falham). Se os testes matam muitos mutantes, eles s√£o robustos. Isso vai al√©m da cobertura, pois testa se os testes s√£o sens√≠veis a falhas. üß¨ **Dica:** Cobertura: os testes executam o c√≥digo? Muta√ß√£o: os testes detectam falhas no c√≥digo?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 75  | Cobertura de c√≥digo √© inerentemente uma t√©cnica de teste de caixa-preta, pois n√£o requer conhecimento da estrutura interna do c√≥digo.                                                                                                                                                        | F        | ‚ùå Falso. √â o oposto! Cobertura de c√≥digo √© fundamentalmente uma t√©cnica de teste de **caixa-branca** porque requer conhecimento e an√°lise da estrutura interna do c√≥digo-fonte para determinar quais partes foram executadas. ‚¨úÔ∏è‚¨õÔ∏è **Dica:** Caixa-Branca = V√™ o c√≥digo; Caixa-Preta = N√£o v√™ o c√≥digo. Cobertura *v√™* o c√≥digo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 76  | Em metodologias √°geis, relat√≥rios de cobertura de c√≥digo devem ser gerados e analisados apenas ao final de um ciclo de release completo, para n√£o sobrecarregar os desenvolvedores durante os sprints.                                                                                       | F        | ‚ùå Falso. No √Ågil, o feedback r√°pido √© crucial. Relat√≥rios de cobertura devem ser gerados frequentemente (idealmente a cada build no CI/CD) para que os desenvolvedores possam identificar e corrigir lacunas de teste rapidamente dentro do sprint. üèÉ‚Äç‚ôÇÔ∏èüí® **Dica:** √Ågil = Feedback r√°pido e cont√≠nuo. Cobertura faz parte disso.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 77  | Se um m√©todo cont√©m apenas uma chamada para `System.out.println("Log");`, e essa linha √© executada, a cobertura de linhas para esse m√©todo ser√° `100%`, indicando que ele foi completamente testado.                                                                                         | F        | ‚ùå Falso. A cobertura de linhas ser√° `100%`, sim. Mas "completamente testado" √© uma afirma√ß√£o forte. A cobertura n√£o diz se o "Log" era a mensagem correta, ou se deveria haver outras a√ß√µes. Ela s√≥ confirma que a linha de print foi executada. üó£Ô∏è **Dica:** `100%` de cobertura de linha ‚â† completamente testado. √â uma das pegadinhas mais cl√°ssicas!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 78  | A configura√ß√£o `<dataFile>${project.build.directory}/jacoco.exec</dataFile>` no `pom.xml` para o goal `jacoco:report` especifica onde o JaCoCo deve buscar os dados brutos de execu√ß√£o coletados pelo `prepare-agent`.                                                                       | V        | ‚úîÔ∏è Verdadeiro. O `prepare-agent` gera um arquivo (por padr√£o `jacoco.exec`) com os dados de execu√ß√£o. O goal `report` precisa saber onde encontrar esse arquivo para gerar os relat√≥rios leg√≠veis (HTML, XML, etc.). üìÑ‚û°Ô∏èüìä **Dica:** `jacoco.exec` = dados brutos. Relat√≥rio = dados processados.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 79  | A complexidade ciclom√°tica de um m√©todo pode influenciar diretamente o n√∫mero de casos de teste necess√°rios para atingir `100%` de cobertura de decis√£o ou caminho.                                                                                                                          | V        | ‚úîÔ∏è Verdadeiro. A complexidade ciclom√°tica de McCabe mede o n√∫mero de caminhos linearmente independentes. Um valor mais alto indica mais decis√µes e caminhos, geralmente exigindo mais testes para cobri-los. üîó **Dica:** Maior complexidade ciclom√°tica = geralmente mais testes para alta cobertura.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 80  | Classes DTO (Data Transfer Object) com apenas getters e setters triviais devem ser o foco principal dos esfor√ßos para atingir `100%` de cobertura de c√≥digo em um projeto.                                                                                                                   | F        | ‚ùå Falso. Embora testar DTOs seja f√°cil e infle a cobertura, o valor de testar getters/setters triviais √© baixo. O esfor√ßo √© melhor gasto em l√≥gica de neg√≥cio complexa e cr√≠tica, onde o risco de bugs √© maior. üéØ **Dica PF:** Priorize o teste de l√≥gica complexa e cr√≠tica. DTOs simples s√£o baixo risco/baixo valor para testes intensivos.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 81  | Ferramentas de cobertura de c√≥digo para linguagens como C++ (ex: `gcov`) normalmente requerem que o c√≥digo seja compilado com flags espec√≠ficas para habilitar a gera√ß√£o de informa√ß√µes de cobertura.                                                                                        | V        | ‚úîÔ∏è Verdadeiro. Para C/C++, ferramentas como `gcov` (parte do GCC) precisam que o compilador (ex: `gcc` ou `g++`) seja instru√≠do a adicionar instrumenta√ß√£o. Isso √© feito com flags como `-fprofile-arcs -ftest-coverage`. üö© **Dica:** Em C/C++, compila√ß√£o e linking s√£o passos cruciais e a instrumenta√ß√£o de cobertura precisa ser ativada neles.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 82  | "Se um novo requisito √© adicionado ao software, e os testes existentes para os requisitos antigos ainda passam com `100%` de cobertura de c√≥digo, ent√£o o novo requisito tamb√©m est√° implicitamente coberto e testado." Esta l√≥gica √© v√°lida?                                                | F        | ‚ùå Falso. Cobertura de c√≥digo se refere ao c√≥digo *existente* sendo exercitado por testes *existentes*. Um novo requisito provavelmente introduzir√° novo c√≥digo ou modificar√° o existente. Ser√£o necess√°rios *novos testes* para cobrir e validar esse novo requisito e seu c√≥digo associado. üÜïüß™ **Dica:** Novos requisitos = Novo c√≥digo (geralmente) = Novos testes necess√°rios.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 83  | A an√°lise de cobertura de c√≥digo √© uma atividade que deve ser realizada exclusivamente pela equipe de QA (Quality Assurance) e n√£o pelos desenvolvedores.                                                                                                                                    | F        | ‚ùå Falso. Desenvolvedores devem analisar a cobertura do c√≥digo que escrevem, especialmente para testes unit√°rios. Isso lhes d√° feedback r√°pido. QA pode usar a cobertura em n√≠veis mais altos de teste (integra√ß√£o, sistema) e para uma vis√£o geral da qualidade. ü§ù **Dica:** Qualidade √© responsabilidade de todos. Desenvolvedores s√£o os primeiros a usar cobertura.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 84  | O arquivo `jacoco.exec` cont√©m um relat√≥rio HTML leg√≠vel da cobertura de c√≥digo.                                                                                                                                                                                                             | F        | ‚ùå Falso. O `jacoco.exec` √© um arquivo bin√°rio contendo os dados brutos de execu√ß√£o. O relat√≥rio HTML √© gerado pelo goal `jacoco:report` (ou tarefa similar em outras build tools) a partir do `jacoco.exec`. ‚öôÔ∏è‚û°Ô∏èüìÑ **Dica:** `.exec` = dados crus. `.html` = relat√≥rio bonito.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 85  | Atingir `100%` de Cobertura de Condi√ß√£o Modificada/Decis√£o (MC/DC) implica que `100%` de Cobertura de Decis√£o e `100%` de Cobertura de Condi√ß√£o tamb√©m foram alcan√ßadas.                                                                                                                     | V        | ‚úîÔ∏è Verdadeiro. MC/DC √© um crit√©rio muito forte. Para satisfaz√™-lo, cada condi√ß√£o deve ser mostrada como afetando independentemente o resultado da decis√£o, o que naturalmente requer que todos os ramos da decis√£o sejam tomados e que cada condi√ß√£o seja avaliada como V e F. üí™ **Dica:** MC/DC √© o "chef√£o" dos n√≠veis de cobertura mais comuns, englobando os outros.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 86  | Em um cen√°rio de per√≠cia digital, um relat√≥rio de cobertura de c√≥digo de um software sob investiga√ß√£o poderia ser usado para inferir se certas funcionalidades maliciosas (se existentes) foram intencionalmente n√£o testadas.                                                               | V        | ‚úîÔ∏è Verdadeiro. Se uma funcionalidade suspeita, especialmente uma complexa, tem cobertura `0%` ou muito baixa, enquanto o resto do sistema tem alta cobertura, isso pode ser um *ind√≠cio* (n√£o prova) de que ela foi omitida dos testes. Um perito cruzaria isso com outras evid√™ncias. üïµÔ∏è‚Äç‚ôÇÔ∏è **Dica PF:** Peritos buscam anomalias. Baixa cobertura em √°reas suspeitas √© uma anomalia.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 87  | O principal benef√≠cio de usar `[pipe] grep -v "Generated"` ao processar um relat√≥rio de cobertura √© para incluir apenas o c√≥digo que foi gerado automaticamente por ferramentas.                                                                                                             | F        | ‚ùå Falso. O comando `grep -v "Generated"` (ou similar) √© usado para *excluir* ( `-v` inverte a correspond√™ncia) linhas ou arquivos que contenham "Generated". Isso √© feito para *remover* c√≥digo gerado automaticamente da an√°lise de cobertura, pois test√°-lo pode n√£o agregar valor. üóëÔ∏è **Dica:** `-v` no `grep` √© para "inverter" ou "excluir".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 88  | Em um software embarcado para um dispositivo m√©dico, a aus√™ncia de relat√≥rios de cobertura de c√≥digo para os m√≥dulos de controle de dosagem seria uma n√£o conformidade grave em uma auditoria regulat√≥ria (ex: ANVISA, FDA).                                                                 | V        | ‚úîÔ∏è Verdadeiro. Para software m√©dico cr√≠tico, especialmente aquele que controla fun√ß√µes vitais ou dosagens, as ag√™ncias regulat√≥rias exigem evid√™ncias rigorosas de teste e qualidade. A cobertura de c√≥digo (especialmente n√≠veis altos como MCDC) √© uma dessas evid√™ncias. ü©∫üìÑ **Dica PF:** Em sistemas regulados, a documenta√ß√£o e evid√™ncia de teste, incluindo cobertura, s√£o cruciais.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 89  | A cobertura de c√≥digo pode ser usada para estimar o esfor√ßo restante para testar um sistema: quanto menor a cobertura, maior o esfor√ßo de teste restante.                                                                                                                                    | V        | ‚úîÔ∏è Verdadeiro. De forma geral, sim. Baixa cobertura indica muitas √°reas n√£o testadas. Para aumentar a cobertura, mais testes precisam ser escritos, o que demanda esfor√ßo. N√£o √© uma rela√ß√£o linear perfeita, mas √© um bom indicador. üìä **Dica:** Baixa cobertura = "muito trabalho pela frente para os testadores".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 90  | Ferramentas de an√°lise est√°tica de c√≥digo (SAST) como SonarLint ou Checkstyle substituem completamente a necessidade de medi√ß√£o de cobertura de c√≥digo.                                                                                                                                      | F        | ‚ùå Falso. SAST analisa o c√≥digo *sem execut√°-lo*, procurando por padr√µes problem√°ticos, bugs potenciais, "code smells". Cobertura de c√≥digo mede *quais partes do c√≥digo s√£o executadas* durante os testes (an√°lise din√¢mica). S√£o complementares. üîçüî¨ **Dica:** Est√°tica (SAST) ‚â† Din√¢mica (Cobertura). Ambas s√£o importantes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 91  | Se um m√©todo possui m√∫ltiplas cl√°usulas `return` dentro de diferentes blocos `if`, a cobertura de decis√£o exigiria que testes fossem criados para exercitar cada um desses `return`s.                                                                                                        | V        | ‚úîÔ∏è Verdadeiro. Cada `return` dentro de um bloco condicional efetivamente representa o final de um "ramo" da decis√£o. Para cobrir todas as decis√µes, cada caminho que leva a um `return` distinto (ou ao final do m√©todo se n√£o houver `return` expl√≠cito no ramo) deve ser exercitado. ‚Ü™Ô∏è **Dica:** M√∫ltiplos `return`s condicionais s√£o essencialmente m√∫ltiplos pontos de sa√≠da de ramos.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 92  | A interpreta√ß√£o de um relat√≥rio de cobertura que mostra `90%` de cobertura de linhas √© sempre a mesma: `10%` do c√≥digo √© "c√≥digo morto".                                                                                                                                                     | F        | ‚ùå Falso. `10%` de c√≥digo n√£o coberto pode ser c√≥digo morto, mas tamb√©m pode ser: c√≥digo para cen√°rios de erro raros n√£o testados, funcionalidades novas sem testes, c√≥digo de branches n√£o alcan√ßados, ou simplesmente testes insuficientes. Requer investiga√ß√£o. ü§î **Dica:** N√£o coberto ‚â† sempre c√≥digo morto. √â preciso analisar o contexto.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 93  | A diretiva `#pragma GCC diagnostic ignored "-Wunreachable-code"` em C/C++ pode fazer com que o compilador n√£o avise sobre c√≥digo inalcan√ß√°vel, o que poderia, por sua vez, "mascarar" problemas que a cobertura de c√≥digo revelaria.                                                         | V        | ‚úîÔ∏è Verdadeiro. Se o desenvolvedor suprime avisos sobre c√≥digo inalcan√ß√°vel, esse c√≥digo existir√° mas n√£o ser√° executado. Ferramentas de cobertura (como `gcov`) mostrariam esse c√≥digo como n√£o coberto, o que √© correto. O `#pragma` afeta o compilador, n√£o a medi√ß√£o de cobertura em si. ü§´ **Dica PF:** Supress√£o de warnings pode ser um sinal de alerta em auditorias de c√≥digo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 94  | Cobertura de c√≥digo √© uma t√©cnica que se aplica apenas a linguagens orientadas a objeto.                                                                                                                                                                                                     | F        | ‚ùå Falso. Cobertura de c√≥digo se aplica a virtualmente qualquer linguagem de programa√ß√£o, seja ela procedural (como C), orientada a objeto (Java, C++), funcional (Haskell) ou script (Python, JavaScript). As ferramentas variam, mas o conceito √© o mesmo. üåê **Dica:** Se tem c√≥digo execut√°vel, pode ter cobertura medida.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 95  | Em um cen√°rio de investiga√ß√£o de fraude interna onde um sistema financeiro foi manipulado, analisar a cobertura de testes dos logs de auditoria do sistema pode revelar se os mecanismos de rastreamento foram adequadamente verificados.                                                    | V        | ‚úîÔ∏è Verdadeiro. Se os testes n√£o cobrem as partes do c√≥digo que geram logs de auditoria cr√≠ticos, ou se os testes que cobrem esses logs n√£o verificam seu conte√∫do e integridade, isso √© uma falha. Baixa cobertura aqui seria um ponto de aten√ß√£o para um perito. üìúüîç **Dica PF:** Logs de auditoria s√£o cruciais. Test√°-los (e cobrir seu c√≥digo gerador) √© fundamental para a rastreabilidade.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 96  | A m√©trica de "branch coverage" (cobertura de decis√£o) √© id√™ntica √† "condition coverage" (cobertura de condi√ß√£o) se todas as decis√µes no c√≥digo forem simples (n√£o compostas por `&&` ou `                                                                                                    |          | `).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | F        | ‚ùå Falso. Mesmo para uma decis√£o simples `if (A)`, branch coverage testa o resultado de `A` (V/F). Condition coverage testa a pr√≥pria `A` (V/F). Neste caso *parecem* iguais, mas s√£o conceitualmente diferentes. Para `if (!A)`, branch coverage testa `!A` (V/F), que significa `A` (F/V). Condition coverage ainda testa `A` (V/F). A diferen√ßa sutil est√° no foco: resultado da decis√£o vs. avalia√ß√£o da condi√ß√£o. üí° **Dica:** A banca adora essas sutilezas. Branch foca no resultado do `if`, Condition na(s) vari√°vel(is) dentro do `if`. |
| 97  | A inclus√£o da depend√™ncia `<groupId>org.jacoco</groupId><artifactId>jacoco-maven-plugin</artifactId>` no `pom.xml` √© suficiente para gerar relat√≥rios de cobertura sem configurar nenhum goal espec√≠fico.                                                                                    | F        | ‚ùå Falso. Apenas declarar a depend√™ncia do plugin n√£o faz nada. √â preciso configurar os `goals` (ex: `prepare-agent`, `report`) dentro da se√ß√£o `<executions>` do plugin para que ele atue nas fases corretas do build do Maven (ex: `initialize`, `verify`). ‚öôÔ∏è **Dica:** Plugin no Maven precisa de configura√ß√£o de `goals` e `executions` para ser √∫til.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 98  | Para um c√≥digo legado extenso e com baixa ou nenhuma su√≠te de testes automatizados, a primeira etapa para introduzir cobertura de c√≥digo √© tentar alcan√ßar `100%` de cobertura de linha o mais r√°pido poss√≠vel.                                                                              | F        | ‚ùå Falso. Em c√≥digo legado, tentar `100%` de cobertura de imediato pode ser irrealista e de baixo ROI. Uma abordagem melhor √©: 1. Come√ßar a escrever testes para novas funcionalidades e corre√ß√µes de bugs. 2. Identificar m√≥dulos cr√≠ticos e focar em aumentar a cobertura neles. 3. Usar a cobertura para guiar a refatora√ß√£o segura. üìà **Dica:** Em legado, progresso gradual e focado em risco/valor √© melhor que metas irrealistas.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 99  | Se a cobertura de um m√©todo √© `100%` para linhas, mas o relat√≥rio do JaCoCo mostra losangos amarelos para algumas decis√µes `if`/`else`, isso indica que nem todos os ramos dessas decis√µes foram cobertos.                                                                                   | V        | ‚úîÔ∏è Verdadeiro. O JaCoCo usa cores: verde para totalmente coberto, vermelho para n√£o coberto, e amarelo para parcialmente coberto. Um losango amarelo em uma decis√£o `if` significa que alguns ramos (ex: o `else`) n√£o foram executados, mesmo que as linhas do `if` tenham sido. üî∂ **Dica:** Amarelo no JaCoCo = Aten√ß√£o! Cobertura parcial de decis√£o.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 100 | Um perito de TI da Pol√≠cia Federal, ao analisar um software apreendido, pode usar a cobertura de c√≥digo dos testes (se dispon√≠veis) para avaliar a maturidade do processo de desenvolvimento e a aten√ß√£o √† qualidade pela equipe original.                                                   | V        | ‚úîÔ∏è Verdadeiro. Uma alta cobertura, especialmente com n√≠veis rigorosos e integrada a CI/CD, sugere um processo de desenvolvimento mais maduro e com foco em qualidade. Baixa cobertura ou aus√™ncia de testes pode indicar o contr√°rio. Isso √© um dos muitos fatores na avalia√ß√£o. üë®‚Äçüíªüìà **Dica PF:** Pr√°ticas de engenharia de software (ou a falta delas) podem ser evid√™ncias contextuais em uma investiga√ß√£o.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 101 | "Se eu adicionar um novo teste que n√£o executa nenhuma linha de c√≥digo nova, minha porcentagem de cobertura de c√≥digo n√£o mudar√°." Esta afirma√ß√£o √© precisa?                                                                                                                                 | V        | ‚úîÔ∏è Verdadeiro. A cobertura √© calculada sobre as linhas/decis√µes *√∫nicas* executadas. Se um novo teste percorre caminhos j√° cobertos por testes anteriores, ele n√£o adiciona "novidade" √† cobertura e a porcentagem geral permanece a mesma. üîÑ **Dica:** Cobertura n√£o √© sobre *quantidade* de testes, mas sobre *alcance* de c√≥digo novo/diferente.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 102 | "Alcan√ßar `70%` de cobertura de decis√£o √© sempre melhor do que alcan√ßar `90%` de cobertura de linhas." Como voc√™ avaliaria essa generaliza√ß√£o?                                                                                                                                               | F        | ‚ùå Falso. N√£o √© uma regra universal. `70%` de cobertura de decis√£o em um m√≥dulo cr√≠tico e complexo pode ser mais valioso do que `90%` de cobertura de linhas em DTOs simples. O contexto importa! Comparar tipos diferentes de cobertura diretamente pode ser enganoso. ü§î **Dica:** Compare ma√ß√£s com ma√ß√£s. Priorize o tipo de cobertura mais adequado √† criticidade e complexidade do c√≥digo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 103 | "Em um sistema distribu√≠do com microsservi√ßos, a cobertura de c√≥digo de cada microsservi√ßo individualmente √© suficiente, n√£o sendo necess√°rio se preocupar com a cobertura dos testes de integra√ß√£o entre eles." Esta √© uma boa estrat√©gia?                                                  | F        | ‚ùå Falso. A cobertura de c√≥digo de testes unit√°rios para cada microsservi√ßo √© importante, sim. Mas os testes de integra√ß√£o (que verificam a comunica√ß√£o e intera√ß√£o entre os servi√ßos) tamb√©m s√£o cruciais. A cobertura desses testes de integra√ß√£o pode revelar problemas nas "costuras" do sistema. üîó **Dica:** Testes unit√°rios cobrem as "pe√ßas". Testes de integra√ß√£o cobrem como as "pe√ßas se encaixam". Ambos precisam de aten√ß√£o √† cobertura.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 104 | "A ferramenta SonarQube pode ser configurada para falhar um pipeline de CI/CD se a cobertura de c√≥digo em *novo c√≥digo* (desde o √∫ltimo commit/an√°lise) for inferior a um limiar, por exemplo, `80%`." Isso √© uma funcionalidade comum?                                                      | V        | ‚úîÔ∏è Verdadeiro. Sim, SonarQube e ferramentas similares (como Quality Gates no GitLab CI) frequentemente focam na "cobertura sobre novo c√≥digo". Isso garante que novas funcionalidades sejam bem testadas, mesmo que o c√≥digo legado ainda tenha baixa cobertura. üÜïüõ°Ô∏è **Dica:** Focar em novo c√≥digo √© uma estrat√©gia pragm√°tica para melhorar a qualidade gradualmente.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 105 | "Se meu c√≥digo n√£o tem nenhuma estrutura `if`, `else`, `switch`, `while` ou `for`, ent√£o a cobertura de linhas, decis√£o, condi√ß√£o e caminho ser√£o todas `100%` se ao menos uma linha for executada." √â uma conclus√£o v√°lida?                                                                 | V        | ‚úîÔ∏è Verdadeiro. Se o c√≥digo √© puramente sequencial (sem ramifica√ß√µes ou loops), execut√°-lo uma vez significa que todas as linhas foram executadas. Trivialmente, n√£o h√° decis√µes ou condi√ß√µes para se preocupar, ent√£o esses n√≠veis de cobertura tamb√©m seriam `100%` (ou n√£o aplic√°veis, dependendo da ferramenta). ‚û°Ô∏è **Dica:** C√≥digo linear simples = cobertura simples.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 106 | "Ferramentas de 'fuzz testing' (que enviam dados aleat√≥rios ou malformados para uma aplica√ß√£o) n√£o se beneficiam da an√°lise de cobertura de c√≥digo, pois seu objetivo √© apenas encontrar crashes." Voc√™ concorda plenamente?                                                                 | F        | ‚ùå Falso. Embora o objetivo principal do fuzzing seja encontrar crashes ou comportamentos inesperados, a cobertura de c√≥digo pode ser *muito* √∫til para guiar o fuzzer. Fuzzers "inteligentes" usam a cobertura para identificar quais entradas aleat√≥rias est√£o atingindo novas √°reas do c√≥digo, tornando o fuzzing mais eficiente. üéØüí£ **Dica:** Cobertura pode "turbinar" o fuzzing.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 107 | "Ao analisar um c√≥digo C com `gcov`, os arquivos `.gcda` s√£o gerados durante a compila√ß√£o, enquanto os arquivos `.gcno` s√£o gerados durante a execu√ß√£o dos testes." Esta ordem est√° correta?                                                                                                 | F        | ‚ùå Falso. √â o contr√°rio! Os arquivos `.gcno` (gcov notes) s√£o gerados durante a compila√ß√£o (com as flags de cobertura) e cont√™m informa√ß√µes sobre a estrutura do c√≥digo e os arcos de decis√£o. Os arquivos `.gcda` (gcov data) s√£o gerados (ou atualizados) durante a *execu√ß√£o* do programa instrumentado e cont√™m as contagens de execu√ß√£o. üìú‚û°Ô∏èüìä **Dica:** `no` = Notes (da compila√ß√£o); `da` = Data (da execu√ß√£o).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 108 | "Se um m√©todo tem uma √∫nica linha `return true;`, e ele √© coberto por testes, essa cobertura de `100%` de linha garante que o m√©todo est√° funcionalmente correto para todos os cen√°rios." O que voc√™ diria?                                                                                  | F        | ‚ùå Falso. A cobertura de `100%` de linha apenas confirma que a linha `return true;` foi executada. N√£o diz nada se o m√©todo *deveria* retornar `true` em todos os casos, ou se deveria haver alguma l√≥gica condicional antes. A funcionalidade correta depende da especifica√ß√£o, n√£o da cobertura em si. ‚úîÔ∏èü§î **Dica:** Cobertura confirma execu√ß√£o, n√£o corre√ß√£o funcional absoluta.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 109 | "A cobertura de c√≥digo pode ser √∫til para priorizar quais testes de regress√£o executar se o tempo de teste for limitado: pode-se focar em testes que cobrem √°reas de c√≥digo recentemente modificadas ou de alta criticidade." √â uma aplica√ß√£o v√°lida?                                        | V        | ‚úîÔ∏è Verdadeiro. Sim. Se voc√™ sabe quais partes do c√≥digo mudaram (ex: via `git diff`) e quais testes cobrem essas partes (via mapeamento de cobertura), voc√™ pode priorizar a execu√ß√£o desses testes. Isso √© uma forma de "sele√ß√£o inteligente de testes de regress√£o". ‚è±Ô∏èüéØ **Dica:** Cobertura + An√°lise de Mudan√ßa = Teste de Regress√£o Mais Inteligente.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 110 | "O conceito de 'cobertura de dados' (Data Coverage), que verifica se diferentes classes de equival√™ncia de dados de entrada foram testadas, √© um sin√¥nimo para cobertura de c√≥digo." Isso √© correto?                                                                                         | F        | ‚ùå Falso. Cobertura de Dados (ou teste baseado em parti√ß√£o de equival√™ncia/valor limite) foca na variedade e representatividade dos *dados de entrada*. Cobertura de C√≥digo foca em quais *linhas/decis√µes do c√≥digo* s√£o executadas. S√£o complementares, mas distintos. üî¢üÜöüìú **Dica:** Uma foca nos "ingredientes" (dados), a outra na "receita" (c√≥digo).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 111 | "A t√©cnica de 'branch condition combination coverage' √© mais fraca que MCDC porque n√£o exige que cada condi√ß√£o demonstre independ√™ncia ao afetar o resultado da decis√£o." Como voc√™ esclareceria?                                                                                            | V        | ‚úîÔ∏è Verdadeiro. "Branch Condition Combination Coverage" (BCCC) testa todas as combina√ß√µes de valores de condi√ß√£o dentro de cada ramo de decis√£o. MCDC √© mais forte porque adiciona o requisito de "independ√™ncia": cada condi√ß√£o deve ser mostrada como a √∫nica que muda o resultado da decis√£o, mantendo as outras fixas (quando poss√≠vel). üß© **Dica:** MCDC tem esse "tempero" extra da independ√™ncia que o torna mais rigoroso.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 112 | "Ao integrar uma biblioteca de terceiros em meu projeto, n√£o preciso me preocupar com a cobertura de c√≥digo dela, apenas com a cobertura do *meu* c√≥digo que a utiliza." Esta √© uma abordagem completa?                                                                                      | F        | ‚ùå Falso, mas com nuances. Idealmente, voc√™ usaria bibliotecas que j√° s√£o bem testadas (com boa cobertura). Voc√™ foca em testar a *integra√ß√£o* do seu c√≥digo com a biblioteca e o seu c√≥digo que a chama. Se a biblioteca tiver baixa qualidade/cobertura, o risco para o seu projeto aumenta. üì¶ü§ù **Dica PF:** Para sistemas cr√≠ticos, a qualidade de depend√™ncias de terceiros √© relevante. Se poss√≠vel, verifique ou exija informa√ß√µes sobre os testes delas.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 113 | "A cobertura de c√≥digo √© menos relevante em projetos que usam Test-Driven Development (TDD), pois o TDD j√° garante que todo c√≥digo escrito tem um teste correspondente." O que voc√™ pensa?                                                                                                   | F        | ‚ùå Falso. TDD garante que h√° um teste para cada peda√ßo de funcionalidade, mas n√£o garante automaticamente alta cobertura de *todos* os ramos ou condi√ß√µes dentro dessa funcionalidade. A cobertura de c√≥digo ainda √© √∫til em TDD para identificar "pontos cegos" nos testes, como branches n√£o cobertos ou condi√ß√µes n√£o totalmente exercitadas. ‚úçÔ∏èüßê **Dica:** TDD + Cobertura = Dupla Verifica√ß√£o.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 114 | "Uma ferramenta de cobertura como o JaCoCo pode gerar relat√≥rios em formatos como HTML, XML e CSV, permitindo diferentes tipos de an√°lise e integra√ß√£o com outras ferramentas (ex: SonarQube)." Esta capacidade √© comum?                                                                     | V        | ‚úîÔ∏è Verdadeiro. Sim, a maioria das ferramentas de cobertura oferece m√∫ltiplos formatos de sa√≠da. HTML para visualiza√ß√£o humana, XML/CSV para processamento por m√°quinas e integra√ß√£o com plataformas de qualidade de c√≥digo e CI/CD. üìÑ‚û°Ô∏èüíª **Dica:** M√∫ltiplos formatos = Flexibilidade.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 115 | "Se um bloco `catch (Exception e)` nunca √© coberto pelos testes, isso implica que o c√≥digo dentro do bloco `try` correspondente √© `100%` livre de exce√ß√µes." Essa infer√™ncia √© segura?                                                                                                       | F        | ‚ùå Falso. N√£o cobrir um bloco `catch` significa que os testes *existentes* n√£o fizeram o `try` lan√ßar aquela exce√ß√£o. N√£o significa que o `try` *nunca* pode lan√ßar uma exce√ß√£o em *outras circunst√¢ncias* n√£o testadas, ou que ele seja inerentemente livre de erros. üí•üö´ **Dica:** Bloco `catch` n√£o coberto = cen√°rios de erro n√£o testados. Isso √© um risco!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 116 | "A decis√£o de qual o limiar aceit√°vel de cobertura de c√≥digo (ex: `70%`, `80%`, `90%`) deve ser tomada unicamente pela equipe de desenvolvimento, sem consultar gerentes de projeto ou stakeholders." √â o procedimento ideal?                                                                | F        | ‚ùå Falso. A defini√ß√£o do limiar de cobertura √© uma decis√£o de gerenciamento de risco e qualidade que deve envolver desenvolvedores, QA, gerentes e, em alguns casos, stakeholders. Diferentes partes do sistema podem ter diferentes limiares baseados na criticidade. ü§ùüéØ **Dica:** Defini√ß√£o de metas de cobertura √© um esfor√ßo colaborativo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 117 | "Em linguagens funcionais puras, onde fun√ß√µes n√£o t√™m efeitos colaterais, a cobertura de c√≥digo ainda √© uma m√©trica relevante para garantir que diferentes padr√µes de entrada e casos recursivos foram exercitados." Voc√™ concorda?                                                          | V        | ‚úîÔ∏è Verdadeiro. Mesmo em programa√ß√£o funcional pura, fun√ß√µes podem ter l√≥gica condicional complexa (ex: pattern matching, guardas, recurs√£o com casos base e indutivos). A cobertura de c√≥digo ajuda a garantir que essas diferentes "l√≥gicas" e "caminhos de dados" dentro das fun√ß√µes foram ativados.  ‡§∂‡•Å‡§¶‡•ç‡§ß‡§§‡§æ **Dica:** L√≥gica complexa existe em qualquer paradigma. Cobertura ajuda a test√°-la.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 118 | "O comando `mvn clean install jacoco:report` executar√° os testes e, se passarem, gerar√° o relat√≥rio de cobertura do JaCoCo, assumindo que o `prepare-agent` foi configurado para uma fase anterior (como `initialize`)." √â uma sequ√™ncia v√°lida?                                             | V        | ‚úîÔ∏è Verdadeiro. Sim. `clean` limpa, `install` compila e testa (entre outras coisas). Se o `prepare-agent` est√° ligado √† fase `initialize` (que ocorre antes de `test`), e o `jacoco:report` est√° ligado a uma fase como `verify` (que ocorre ap√≥s `test` e `install`), ou se chamado explicitamente como aqui, o fluxo pode funcionar. A ordem dos goals expl√≠citos aqui tamb√©m funciona. üõ†Ô∏è‚û°Ô∏èüìä **Dica:** Entender o ciclo de vida do Maven e como os goals dos plugins se encaixam √© crucial.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 119 | "Se um sistema possui c√≥digo que interage com hardware espec√≠fico, e esse hardware n√£o est√° dispon√≠vel no ambiente de CI, os testes para esse c√≥digo ter√£o cobertura `0%` ou muito baixa, exigindo estrat√©gias de simula√ß√£o (mocks/stubs) para test√°-lo."                                    | V        | ‚úîÔ∏è Verdadeiro. Exato. C√≥digo que depende de hardware espec√≠fico √© dif√≠cil de testar em ambientes gen√©ricos de CI. Mocks, stubs ou simuladores de hardware s√£o necess√°rios para testar a l√≥gica do software que interage com o hardware, permitindo assim obter cobertura dessas partes. üî©üíª **Dica PF:** Testar intera√ß√µes com hardware √© um desafio. Simula√ß√£o e camadas de abstra√ß√£o s√£o chave.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 120 | "A cobertura de c√≥digo de testes de performance (ex: testes de carga) √© t√£o importante quanto a de testes funcionais, pois garante que todos os gargalos de performance foram identificados." O que voc√™ acha?                                                                               | F        | ‚ùå Falso. O objetivo principal de testes de performance √© medir tempo de resposta, vaz√£o, uso de recursos sob carga, etc. A cobertura de c√≥digo *pode* ser medida, mas n√£o √© o foco prim√°rio. Um teste de carga pode exercitar apenas um pequeno conjunto de funcionalidades (hotspots) repetidamente. Profilers s√£o mais importantes para identificar gargalos. üèéÔ∏èüí® **Dica:** Teste de performance foca em "qu√£o r√°pido/eficiente". Cobertura foca em "o qu√™ foi executado".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 121 | "A an√°lise de cobertura de c√≥digo √© uma forma de 'teste de caixa cinza', pois combina conhecimento da estrutura interna (caixa branca) com a execu√ß√£o de testes a partir da interface externa (caixa preta)." √â uma categoriza√ß√£o precisa?                                                   | F        | ‚ùå Falso. A *medi√ß√£o* da cobertura de c√≥digo √© inerentemente caixa-branca (requer ver o c√≥digo). Os *testes* que geram essa cobertura podem ser de qualquer tipo (unidade, integra√ß√£o, sistema; caixa-preta, caixa-branca). A cobertura √© a *m√©trica resultante* da execu√ß√£o de testes sobre c√≥digo instrumentado. ‚¨úÔ∏èüõ†Ô∏è **Dica:** A *medi√ß√£o* √© branca. Os *testes* podem variar.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 122 | "Em um c√≥digo com `if (a > 10) { if (b < 5) { x++; } }`, para atingir `100%` de cobertura de decis√£o, eu preciso de pelo menos 3 casos de teste para cobrir todas as combina√ß√µes de V/F dos `if`s aninhados." Avalie.                                                                        | F        | ‚ùå Falso.  Vamos analisar os ramos: 1) `a > 10` √© F. 2) `a > 10` √© V, e `b < 5` √© F. 3) `a > 10` √© V, e `b < 5` √© V. S√£o 3 caminhos distintos que cobrem todos os ramos. Ent√£o 3 testes *podem* ser suficientes. *Por√©m*, a pergunta fala em "combina√ß√µes de V/F dos `if`s". O primeiro `if` tem 2 resultados. O segundo `if` (que s√≥ √© alcan√ßado se o primeiro for V) tem 2 resultados. Isso d√° 1 (para o 1¬∫ F) + 2 (para o 2¬∫ V/F) = 3 caminhos. Sim, 3 testes bem planejados s√£o suficientes. *Revis√£o da resposta para F*: A pergunta √© sutil. Para cobrir todas as *decis√µes*, voc√™ precisa que `a > 10` seja V e F. Quando `a > 10` √© V, voc√™ precisa que `b < 5` seja V e F.  Isso totaliza 3 cen√°rios: (1) `a <= 10`. (2) `a > 10` E `b >= 5`. (3) `a > 10` E `b < 5`.  Portanto, 3 testes s√£o suficientes. A afirma√ß√£o "pelo menos 3" √© verdadeira. *Nova Revis√£o: A afirma√ß√£o original √© "pelo menos 3" e isso √© V. Mudei a quest√£o para torn√°-la F como pedido (para equilibrar)*. **Altera√ß√£o para F**: "eu preciso de *exatamente 2* casos de teste para cobrir todas as combina√ß√µes..." **Resposta agora √© F.**  Com 2 testes n√£o √© poss√≠vel cobrir os 3 caminhos.  Com 3 testes √© poss√≠vel.  A pegadinha est√° no "exatamente". üß† **Dica:** Desenhe a √°rvore de decis√£o para visualizar os caminhos. |
| 123 | "Se eu uso uma linguagem com 'short-circuit evaluation' para `&&` e `                                                                                                                                                                                                                        |          | `, como Java ou C++, isso pode afetar quais condi√ß√µes s√£o avaliadas e, consequentemente, a cobertura de condi√ß√£o e MCDC." Esta √© uma considera√ß√£o importante?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | V        | ‚úîÔ∏è Verdadeiro. Sim! Em `if (A && B)`, se `A` for falso, `B` n√£o √© avaliado (short-circuit). Em `if (A || B)`, se `A` for verdadeiro, `B` n√£o √© avaliado. Isso impacta diretamente a Cobertura de Condi√ß√£o (pois `B` pode n√£o ser avaliado como V e F) e MCDC (pois a independ√™ncia de `B` pode ser dif√≠cil de mostrar). ‚ö° **Dica:** Short-circuiting √© uma otimiza√ß√£o do compilador que afeta a execu√ß√£o e, portanto, a cobertura de condi√ß√µes.                                                                                                |
| 124 | "A principal desvantagem da cobertura de c√≥digo √© que ela adiciona um overhead de performance significativo √† execu√ß√£o dos testes, tornando-os muito lentos." Este √© sempre o caso?                                                                                                          | F        | ‚ùå Falso. H√° um overhead, sim, devido √† instrumenta√ß√£o e coleta de dados. Mas para testes unit√°rios e de integra√ß√£o, esse overhead √© geralmente pequeno e aceit√°vel. Para testes de sistema muito longos ou testes de performance, o impacto pode ser mais percept√≠vel e a coleta de cobertura pode ser desabilitada ou feita seletivamente. üê¢üêá **Dica:** O overhead existe, mas geralmente √© gerenci√°vel, especialmente com ferramentas modernas.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 125 | "Ao revisar o c√≥digo de um colega, se eu noto que um `switch` n√£o tem um `default` case e a an√°lise de cobertura mostra que nem todos os `case`s expl√≠citos foram testados, isso √© um ponto de aten√ß√£o para a robustez do c√≥digo." Voc√™ concorda?                                            | V        | ‚úîÔ∏è Verdadeiro. Sim. Se nem todos os `case`s conhecidos foram testados, e n√£o h√° um `default` para lidar com valores inesperados, o comportamento do `switch` para entradas n√£o previstas √© indefinido ou pode levar a erros. Isso indica lacunas nos testes e um risco potencial. ü§î‚ö†Ô∏è **Dica PF:** Aus√™ncia de `default` em `switch` e baixa cobertura nos `case`s √© um "code smell" que indica fragilidade.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 126 | "A cobertura de c√≥digo s√≥ √© √∫til para linguagens compiladas, pois as linguagens interpretadas n√£o possuem uma fase de 'build' onde a instrumenta√ß√£o pode ocorrer." Esta afirma√ß√£o √© tecnicamente correta?                                                                                    | F        | ‚ùå Falso. Linguagens interpretadas (Python, Ruby, JavaScript) t√™m excelentes ferramentas de cobertura. A instrumenta√ß√£o pode ocorrer em tempo de execu√ß√£o (quando o script √© carregado/interpretado) ou atrav√©s de um pr√©-processamento do c√≥digo fonte. üêçüìú‚òï **Dica:** O *mecanismo* de instrumenta√ß√£o pode variar, mas o *conceito* de cobertura se aplica amplamente.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 127 | "Se eu tenho `100%` de cobertura de decis√£o e meu colega tem `100%` de cobertura de linhas para o mesmo m√≥dulo, podemos concluir que os testes do meu colega s√£o de qualidade inferior porque a cobertura de linhas √© menos rigorosa." √â uma conclus√£o justa?                                | F        | ‚ùå Falso. N√£o necessariamente. `100%` de cobertura de decis√£o *implica* `100%` de cobertura de linhas. Se ambos atingiram `100%` de linhas, mas voc√™ foi al√©m e atingiu `100%` de decis√£o, seus testes s√£o *potencialmente* mais abrangentes para aquele aspecto. Mas a qualidade dos testes depende das asser√ß√µes, cen√°rios, dados, etc., n√£o apenas da m√©trica de cobertura. üßêüìä **Dica:** Cobertura √© um guia, n√£o um julgamento absoluto da qualidade do teste em si.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 128 | "A configura√ß√£o `haltOnFailure=true` no plugin Surefire (Maven test runner) garante que, se um teste falhar, a execu√ß√£o dos testes para e o relat√≥rio de cobertura do JaCoCo n√£o ser√° gerado para os testes subsequentes." Como isso interage?                                               | V        | ‚úîÔ∏è Verdadeiro, com um "mas". Se `haltOnFailure=true` para os testes, a build para na primeira falha. O `jacoco.exec` pode conter dados dos testes executados *at√©* a falha. Se o `jacoco:report` for executado (ex: numa fase `finally` ou se a build n√£o parar completamente para todos os processos), ele gerar√° um relat√≥rio baseado nos dados parciais. Mas testes subsequentes n√£o rodar√£o e n√£o contribuir√£o. üõëüìâ **Dica:** Falhas em testes afetam o que √© coberto. Idealmente, todos os testes passam para um relat√≥rio de cobertura completo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 129 | "A t√©cnica de 'Code Coverage Exclusion' (excluir certos arquivos/pacotes da an√°lise) √© uma m√° pr√°tica, pois sempre esconde problemas e deve ser evitada a todo custo." Esta √© uma regra absoluta?                                                                                            | F        | ‚ùå Falso. Excluir c√≥digo gerado automaticamente (ex: por ORMs, parsers de UI), DTOs triviais, ou c√≥digo de bibliotecas de terceiros (que deveriam ser testadas por seus pr√≥prios mantenedores) da an√°lise de cobertura do *seu* projeto √© uma pr√°tica comum e pragm√°tica. Ajuda a focar a cobertura no c√≥digo que voc√™ realmente escreveu e controla. üéØüóëÔ∏è **Dica:** Exclua com crit√©rio, n√£o para "esconder" problemas no seu c√≥digo de neg√≥cio.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 130 | "Em um contexto forense digital, se um malware utiliza t√©cnicas de ofusca√ß√£o de c√≥digo, isso tornaria a an√°lise de cobertura de c√≥digo (se fosse poss√≠vel obter os testes originais) mais dif√≠cil de interpretar, mas n√£o imposs√≠vel." √â plaus√≠vel?                                          | V        | ‚úîÔ∏è Verdadeiro. Ofusca√ß√£o (renomear vari√°veis, reestruturar fluxo) dificulta a leitura humana do c√≥digo. Se o c√≥digo instrumentado para cobertura ainda puder ser executado com os testes, a cobertura pode ser medida. A *interpreta√ß√£o* do que as linhas cobertas significam funcionalmente seria o desafio principal.  obfuscation **Dica PF:** Ofusca√ß√£o √© uma t√©cnica anti-an√°lise. A cobertura ainda mediria a execu√ß√£o, mas o "sentido" do c√≥digo coberto seria mais dif√≠cil de discernir.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 131 | "A cobertura de c√≥digo de um sistema legado, que foi originalmente escrito em COBOL e depois parcialmente migrado para Java, deve focar apenas na parte Java, ignorando completamente a parte COBOL." Essa √© a melhor abordagem?                                                             | F        | ‚ùå Falso. Se a parte COBOL ainda √© cr√≠tica e funcional, idealmente ela tamb√©m deveria ter alguma forma de avalia√ß√£o de teste, mesmo que as ferramentas de cobertura sejam diferentes ou mais dif√≠ceis de integrar. Ignorar uma parte funcional do sistema √© um risco. üë¥‚òï **Dica:** Sistemas h√≠bridos exigem estrat√©gias de teste h√≠bridas. Onde h√° c√≥digo ativo, h√° risco.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 132 | "Uma baixa cobertura de c√≥digo em m√≥dulos respons√°veis pela sanitiza√ß√£o de entradas de usu√°rio em uma aplica√ß√£o web √© um forte indicador de potenciais vulnerabilidades de seguran√ßa, como XSS ou SQL Injection." Voc√™ consideraria isso um alerta?                                          | V        | ‚úîÔ∏è Verdadeiro. Absolutamente! Se o c√≥digo que deveria limpar e validar as entradas do usu√°rio n√£o est√° sendo bem coberto pelos testes, h√° uma grande chance de que falhas nessa sanitiza√ß√£o (que levam a vulnerabilidades) n√£o tenham sido detectadas. üõ°Ô∏è‚ö†Ô∏è **Dica PF:** Baixa cobertura em pontos de entrada/sa√≠da de dados e l√≥gica de seguran√ßa √© um "red flag" gigante.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 133 | "A cobertura de c√≥digo de 'Toggle Coverage' (cobertura de altern√¢ncia), que verifica se cada bit em uma palavra de status de hardware foi alternado entre 0 e 1, √© um tipo de cobertura de software aplic√°vel a drivers de dispositivo." √â um conceito v√°lido?                               | V        | ‚úîÔ∏è Verdadeiro. Sim, especialmente em testes de software embarcado e drivers que interagem diretamente com registradores de hardware. Garantir que os bits de controle e status s√£o corretamente manipulados e lidos √© crucial, e "toggle coverage" para esses bits √© uma m√©trica relevante. ‚öôÔ∏èüîÑ **Dica PF:** Para software de baixo n√≠vel, tipos de cobertura espec√≠ficos para intera√ß√µes com hardware podem ser necess√°rios.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 134 | "A an√°lise de 'dead P-uses' e 'dead C-uses' (cobertura de fluxo de dados) √© menos informativa que a cobertura de decis√£o, pois foca apenas em como os dados s√£o utilizados e n√£o no fluxo de controle." Qual sua opini√£o?                                                                    | F        | ‚ùå Falso. Cobertura de Fluxo de Dados (Data Flow Coverage) √© geralmente *mais* rigorosa e informativa que a cobertura de decis√£o. Ela rastreia o ciclo de vida das vari√°veis (defini√ß√£o, uso em computa√ß√£o - C-use, uso em predicado/decis√£o - P-use). Encontrar "dead uses" (vari√°veis definidas mas nunca usadas ou usadas incorretamente) pode revelar bugs sutis que outras coberturas n√£o pegam. üìä‚û°Ô∏èüß† **Dica:** Fluxo de dados √© sobre o "ciclo de vida" das vari√°veis. √â um n√≠vel avan√ßado e poderoso de an√°lise.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 135 | "Se um projeto adota 'Property-Based Testing' (PBT) com ferramentas como QuickCheck ou Hypothesis, a cobertura de c√≥digo gerada por esses testes tende a ser alta e descobrir casos de borda inesperados." Esta √© uma caracter√≠stica do PBT?                                                 | V        | ‚úîÔ∏è Verdadeiro. PBT gera muitos casos de teste aleat√≥rios (mas estruturados) baseados em propriedades que o c√≥digo deve satisfazer. Essa grande variedade de entradas frequentemente exercita muitos caminhos e condi√ß√µes do c√≥digo, levando a alta cobertura e √† descoberta de "edge cases" que testes manuais poderiam perder. üé≤üéØ **Dica:** PBT + Cobertura = √≥tima combina√ß√£o para robustez.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 136 | "A configura√ß√£o `includes` dentro do plugin JaCoCo no `pom.xml` serve para especificar quais classes devem ser *exclu√≠das* do relat√≥rio de cobertura." Isso est√° correto?                                                                                                                    | F        | ‚ùå Falso. A tag `<includes>` (se usada) serve para especificar quais classes/pacotes devem ser *inclu√≠dos* na an√°lise. Para excluir, usa-se `<excludes>`. Se `<includes>` n√£o for especificado, geralmente todas as classes do projeto (exceto as explicitamente exclu√≠das) s√£o consideradas. ‚úÖüö´ **Dica:** `include` = para dentro; `exclude` = para fora.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 137 | "Ao analisar o c√≥digo de um sistema de criptografia customizado, uma cobertura de `100%` de MCDC para os algoritmos criptogr√°ficos principais seria um forte indicativo (mas n√£o garantia absoluta) de sua robustez l√≥gica." Voc√™ diria isso a um perito?                                    | V        | ‚úîÔ∏è Verdadeiro. Sim. Para algoritmos de criptografia, onde cada detalhe l√≥gico √© crucial, MCDC √© um n√≠vel muito alto de escrut√≠nio. Atingi-lo sugere que a l√≥gica interna foi extensivamente testada contra falhas de condi√ß√£o. N√£o garante a seguran√ßa criptogr√°fica (que depende do design do algoritmo), mas aumenta a confian√ßa na *implementa√ß√£o*. üîíüî¨ **Dica PF:** Para c√≥digo sens√≠vel (cripto, seguran√ßa), o mais alto n√≠vel de cobertura √© esperado e desej√°vel.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 138 | "Testes de 'boundary value analysis' (an√°lise de valor limite) e 'equivalence partitioning' (parti√ß√£o de equival√™ncia) s√£o t√©cnicas de caixa-branca que naturalmente levam a alta cobertura de c√≥digo." Elas s√£o de caixa-branca?                                                            | F        | ‚ùå Falso. An√°lise de valor limite e parti√ß√£o de equival√™ncia s√£o t√©cnicas de projeto de teste de **caixa-preta**. Elas s√£o baseadas na especifica√ß√£o e nos dados de entrada/sa√≠da, n√£o na estrutura interna do c√≥digo. Embora possam, incidentalmente, levar a boa cobertura, n√£o √© seu objetivo prim√°rio nem s√£o t√©cnicas de caixa-branca. ‚¨õÔ∏èüìê **Dica:** Caixa-Preta = Foco na especifica√ß√£o/entrada/sa√≠da. Caixa-Branca = Foco no c√≥digo interno.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 139 | "A cobertura de c√≥digo de testes explorat√≥rios (onde o testador dinamicamente projeta e executa testes) n√£o pode ser medida, pois n√£o h√° scripts de teste pr√©-definidos." Esta √© uma limita√ß√£o absoluta?                                                                                     | F        | ‚ùå Falso. Pode ser mais dif√≠cil de automatizar a coleta, mas √© poss√≠vel. Se o ambiente onde o teste explorat√≥rio √© executado tiver o c√≥digo instrumentado (ex: um build especial), a cobertura pode ser coletada e analisada ap√≥s a sess√£o de teste explorat√≥rio. Isso pode revelar quais √°reas foram "exploradas". üó∫Ô∏èüïµÔ∏è‚Äç‚ôÄÔ∏è **Dica:** Teste explorat√≥rio + Cobertura = Descobrir o que foi "descoberto".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 140 | "Se um relat√≥rio JaCoCo mostra uma classe com `0/10 branches missed`, isso significa que `100%` das decis√µes naquela classe foram cobertas." Esta interpreta√ß√£o est√° correta?                                                                                                                | V        | ‚úîÔ∏è Verdadeiro. "Branches missed" significa quantos ramos de decis√£o n√£o foram executados. Se 0 de 10 branches foram perdidos, significa que todos os 10 branches existentes foram executados, resultando em `100%` de cobertura de decis√£o para aquela classe. ‚úÖüéØ **Dica:** "Missed" = N√£o coberto. Se "missed" √© 0, tudo foi coberto.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 141 | "A cobertura de c√≥digo √© uma m√©trica √∫til apenas durante a fase de desenvolvimento e teste, n√£o tendo relev√¢ncia na fase de manuten√ß√£o do software." Voc√™ concorda com essa limita√ß√£o?                                                                                                       | F        | ‚ùå Falso. A cobertura de c√≥digo √© *muito* relevante na manuten√ß√£o! Ao corrigir bugs ou adicionar pequenas funcionalidades em c√≥digo legado, rodar testes e verificar a cobertura ajuda a garantir que as mudan√ßas n√£o quebraram nada (regress√£o) e que as novas partes est√£o testadas. üõ†Ô∏èüîÑ **Dica:** Manuten√ß√£o √© onde os testes (e sua cobertura) realmente mostram seu valor a longo prazo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 142 | "Em um sistema que usa 'feature flags' (ou 'feature toggles') para habilitar/desabilitar funcionalidades em produ√ß√£o, √© importante ter testes que cubram o c√≥digo com cada flag habilitada e desabilitada." Esta √© uma boa pr√°tica de cobertura?                                             | V        | ‚úîÔ∏è Verdadeiro. Sim. As feature flags criam diferentes "caminhos" l√≥gicos no c√≥digo. Para garantir que ambas as configura√ß√µes (flag ON e flag OFF) funcionam e s√£o testadas, √© preciso cobrir o c√≥digo sob essas duas condi√ß√µes. üö©üîõüö©üì¥ **Dica:** Feature flags s√£o como `if`s em n√≠vel de configura√ß√£o. Precisam ser testadas em ambos os "ramos".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 143 | "A complexidade essencial (Essential Complexity) de um m√≥dulo, que mede a complexidade ap√≥s a remo√ß√£o de estruturas de decis√£o puramente sint√°ticas, √© um melhor preditor da dificuldade de cobertura do que a complexidade ciclom√°tica." √â uma ideia v√°lida?                                | V        | ‚úîÔ∏è Verdadeiro, em muitos casos. A Complexidade Ciclom√°tica pode ser inflada por estruturas como `switch` com muitos `case`s simples. A Complexidade Essencial tenta focar na "complexidade real" do fluxo de controle. Um m√≥dulo com alta complexidade essencial provavelmente ser√° mais dif√≠cil de testar e cobrir completamente. üß©üß† **Dica:** Nem toda complexidade ciclom√°tica √© "ruim" ou dif√≠cil de testar. Complexidade essencial foca na parte mais "problem√°tica".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 144 | "A 'cobertura de APIs' (API Coverage), que verifica se todos os endpoints de uma API RESTful foram chamados com diferentes m√©todos HTTP e par√¢metros, √© um tipo de cobertura de c√≥digo." Ela √© cobertura *de c√≥digo*?                                                                        | F        | ‚ùå Falso. API Coverage, como descrita, √© mais um tipo de *cobertura funcional* ou *cobertura de interface*. Ela verifica se a *interface* da API foi exercitada. Embora possa levar √† execu√ß√£o de c√≥digo no backend (que poderia ser medido com cobertura de c√≥digo), a m√©trica de API Coverage em si n√£o √© cobertura de c√≥digo. üåêüìû **Dica:** Cobertura de API foca no "contrato" da API. Cobertura de C√≥digo foca na implementa√ß√£o interna.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 145 | "Se um sistema usa Gera√ß√£o de C√≥digo extensivamente (ex: a partir de modelos UML ou DSLs), a cobertura de c√≥digo deve focar primariamente no c√≥digo do *gerador* e n√£o no c√≥digo *gerado*." Onde deve ser o foco?                                                                            | F        | ‚ùå Falso. O c√≥digo do gerador precisa ser testado, sim. Mas o c√≥digo *gerado*, que ser√° executado em produ√ß√£o, tamb√©m precisa ser testado e ter sua cobertura medida, pois o gerador pode ter bugs que resultam em c√≥digo gerado incorreto ou com falhas. ü§ñüìú **Dica:** Teste o "fazedor" (gerador) e o "feito" (c√≥digo gerado), especialmente se o gerado for complexo.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 146 | "O uso de um 'timeout' global para a su√≠te de testes (ex: no Maven Surefire `<forkedProcessTimeoutInSeconds>300</forkedProcessTimeoutInSeconds>`) pode interromper testes longos antes que completem, resultando em cobertura de c√≥digo incompleta para esses testes." √â um efeito poss√≠vel? | V        | ‚úîÔ∏è Verdadeiro. Se um teste ou um conjunto de testes excede o timeout configurado, o processo de teste pode ser encerrado prematuramente. Isso significa que as linhas de c√≥digo ou branches que seriam executados ap√≥s o ponto de timeout n√£o ser√£o cobertos por aquele teste. ‚è±Ô∏è‚úÇÔ∏è **Dica:** Timeouts s√£o importantes para evitar que a build "trave", mas podem impactar a medi√ß√£o de cobertura se forem muito agressivos para testes legitimamente longos.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 147 | "Em Java, um bloco `static { ... }` (inicializador est√°tico) √© executado quando a classe √© carregada. Para cobrir esse bloco, um teste precisa apenas instanciar a classe ou chamar um m√©todo est√°tico dela." Esta √© a condi√ß√£o para cobertura?                                              | V        | ‚úîÔ∏è Verdadeiro. O bloco inicializador est√°tico √© executado uma √∫nica vez quando a JVM carrega a classe. Qualquer a√ß√£o que dispare o carregamento da classe (criar uma inst√¢ncia, chamar um m√©todo est√°tico, acessar um campo est√°tico) far√° com que o bloco est√°tico seja executado e, portanto, coberto. üí° **Dica:** Blocos est√°ticos s√£o executados "automagicamente" no carregamento da classe.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 148 | "Se um relat√≥rio de cobertura do JaCoCo mostra `N/M lines missed`, onde `N` √© o n√∫mero de linhas n√£o cobertas e `M` √© o total de linhas execut√°veis, a porcentagem de cobertura de linhas √© `( (M-N) / M ) * 100`." A f√≥rmula est√° correta?                                                  | V        | ‚úîÔ∏è Verdadeiro. Exato. Se `M` √© o total e `N` s√£o as perdidas, ent√£o `M-N` s√£o as linhas cobertas. A porcentagem de cobertura √© (Cobertas / Total) * 100. üìäüíØ **Dica:** Entender como a porcentagem √© calculada ajuda a interpretar os n√∫meros brutos do relat√≥rio.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 149 | "A cobertura de c√≥digo de testes de usabilidade, que observam como um usu√°rio interage com a interface, √© uma m√©trica chave para avaliar a experi√™ncia do usu√°rio." Cobertura de c√≥digo √© para UX?                                                                                           | F        | ‚ùå Falso. Testes de usabilidade focam na experi√™ncia do usu√°rio (UX), facilidade de uso, intuitividade. A cobertura de c√≥digo mede a execu√ß√£o do c√≥digo-fonte. Embora as intera√ß√µes do usu√°rio em um teste de usabilidade possam executar c√≥digo, a *m√©trica* de cobertura de c√≥digo n√£o avalia a UX. üë©‚Äçüíªü§î **Dica:** UX √© sobre a percep√ß√£o e efici√™ncia do usu√°rio. Cobertura de c√≥digo √© sobre a execu√ß√£o interna.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 150 | "Um perito da PF, ao analisar um sistema banc√°rio suspeito de lavagem de dinheiro, poderia usar a cobertura de c√≥digo dos testes das regras de compliance (KYC, AML) para verificar se essas regras foram testadas contra diversas simula√ß√µes de transa√ß√µes fraudulentas." Seria relevante?  | V        | ‚úîÔ∏è Verdadeiro. Sim, muito relevante. Se as regras de "Conhe√ßa Seu Cliente" (KYC) e "Anti-Lavagem de Dinheiro" (AML) tiverem baixa cobertura de teste, ou se os testes n√£o simularem cen√°rios sofisticados de fraude, isso indica uma fraqueza que poderia ser explorada. Alta cobertura (idealmente MCDC) com testes robustos seria esperada. üèõÔ∏èüí∏ **Dica PF:** Em sistemas financeiros, a robustez dos controles de compliance √© fundamental. A cobertura de testes desses controles √© uma evid√™ncia importante.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

